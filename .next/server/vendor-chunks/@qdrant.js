"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@qdrant";
exports.ids = ["vendor-chunks/@qdrant"];
exports.modules = {

/***/ "(rsc)/./node_modules/@qdrant/js-client-rest/dist/esm/api-client.js":
/*!********************************************************************!*\
  !*** ./node_modules/@qdrant/js-client-rest/dist/esm/api-client.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createApis: () => (/* binding */ createApis),\n/* harmony export */   createClient: () => (/* binding */ createClient)\n/* harmony export */ });\n/* harmony import */ var _qdrant_openapi_typescript_fetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @qdrant/openapi-typescript-fetch */ \"(rsc)/./node_modules/@qdrant/openapi-typescript-fetch/dist/esm/index.js\");\n/* harmony import */ var _dispatcher_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dispatcher.js */ \"(rsc)/./node_modules/@qdrant/js-client-rest/dist/esm/dispatcher.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors.js */ \"(rsc)/./node_modules/@qdrant/js-client-rest/dist/esm/errors.js\");\n/* harmony import */ var _openapi_generated_api_client_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./openapi/generated_api_client.js */ \"(rsc)/./node_modules/@qdrant/js-client-rest/dist/esm/openapi/generated_api_client.js\");\n\n\n\n\nfunction createApis(baseUrl, args) {\n    const client = createClient(baseUrl, args);\n    return (0,_openapi_generated_api_client_js__WEBPACK_IMPORTED_MODULE_1__.createClientApi)(client);\n}\nfunction createClient(baseUrl, { headers, timeout, connections }) {\n    const use = [];\n    if (Number.isFinite(timeout)) {\n        use.push(async (url, init, next) => {\n            const controller = new AbortController();\n            const id = setTimeout(() => controller.abort(), timeout);\n            try {\n                return await next(url, Object.assign(init, { signal: controller.signal }));\n            }\n            catch (e) {\n                if (e instanceof Error && e.name === 'AbortError') {\n                    throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.QdrantClientTimeoutError(e.message);\n                }\n                throw e;\n            }\n            finally {\n                clearTimeout(id);\n            }\n        });\n    }\n    use.push(async (url, init, next) => {\n        let response;\n        try {\n            response = await next(url, init);\n            if (response.status === 200 || response.status === 201) {\n                return response;\n            }\n        }\n        catch (error) {\n            if (error instanceof _qdrant_openapi_typescript_fetch__WEBPACK_IMPORTED_MODULE_0__.ApiError && error.status === 429) {\n                const retryAfterHeader = error.headers.get('retry-after')?.[0];\n                if (retryAfterHeader) {\n                    throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.QdrantClientResourceExhaustedError(error.message, retryAfterHeader);\n                }\n            }\n            throw error;\n        }\n        throw _errors_js__WEBPACK_IMPORTED_MODULE_2__.QdrantClientUnexpectedResponseError.forResponse(response);\n    });\n    const client = _qdrant_openapi_typescript_fetch__WEBPACK_IMPORTED_MODULE_0__.Fetcher.for();\n    // Configure client with 'undici' agent which is used in Node 18+\n    client.configure({\n        baseUrl,\n        init: {\n            headers,\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            dispatcher: typeof process !== 'undefined' &&\n                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                process.versions?.node\n                ? (0,_dispatcher_js__WEBPACK_IMPORTED_MODULE_3__.createDispatcher)(connections)\n                : undefined,\n        },\n        use,\n    });\n    return client;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHFkcmFudC9qcy1jbGllbnQtcmVzdC9kaXN0L2VzbS9hcGktY2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFxRTtBQUNsQjtBQUM4RTtBQUM3RDtBQUM3RDtBQUNQO0FBQ0EsV0FBVyxpRkFBZTtBQUMxQjtBQUNPLGlDQUFpQywrQkFBK0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELDJCQUEyQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZ0VBQXdCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxzRUFBUTtBQUN6QztBQUNBO0FBQ0EsOEJBQThCLDBFQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMkVBQW1DO0FBQ2pELEtBQUs7QUFDTCxtQkFBbUIscUVBQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdFQUFnQjtBQUNsQztBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtc2FnZS1ib3QvLi9ub2RlX21vZHVsZXMvQHFkcmFudC9qcy1jbGllbnQtcmVzdC9kaXN0L2VzbS9hcGktY2xpZW50LmpzPzJiODgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXBpRXJyb3IsIEZldGNoZXIgfSBmcm9tICdAcWRyYW50L29wZW5hcGktdHlwZXNjcmlwdC1mZXRjaCc7XG5pbXBvcnQgeyBjcmVhdGVEaXNwYXRjaGVyIH0gZnJvbSAnLi9kaXNwYXRjaGVyLmpzJztcbmltcG9ydCB7IFFkcmFudENsaWVudFJlc291cmNlRXhoYXVzdGVkRXJyb3IsIFFkcmFudENsaWVudFRpbWVvdXRFcnJvciwgUWRyYW50Q2xpZW50VW5leHBlY3RlZFJlc3BvbnNlRXJyb3IsIH0gZnJvbSAnLi9lcnJvcnMuanMnO1xuaW1wb3J0IHsgY3JlYXRlQ2xpZW50QXBpIH0gZnJvbSAnLi9vcGVuYXBpL2dlbmVyYXRlZF9hcGlfY2xpZW50LmpzJztcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVBcGlzKGJhc2VVcmwsIGFyZ3MpIHtcbiAgICBjb25zdCBjbGllbnQgPSBjcmVhdGVDbGllbnQoYmFzZVVybCwgYXJncyk7XG4gICAgcmV0dXJuIGNyZWF0ZUNsaWVudEFwaShjbGllbnQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNsaWVudChiYXNlVXJsLCB7IGhlYWRlcnMsIHRpbWVvdXQsIGNvbm5lY3Rpb25zIH0pIHtcbiAgICBjb25zdCB1c2UgPSBbXTtcbiAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHRpbWVvdXQpKSB7XG4gICAgICAgIHVzZS5wdXNoKGFzeW5jICh1cmwsIGluaXQsIG5leHQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgICAgICBjb25zdCBpZCA9IHNldFRpbWVvdXQoKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLCB0aW1lb3V0KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IG5leHQodXJsLCBPYmplY3QuYXNzaWduKGluaXQsIHsgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFFkcmFudENsaWVudFRpbWVvdXRFcnJvcihlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVzZS5wdXNoKGFzeW5jICh1cmwsIGluaXQsIG5leHQpID0+IHtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBuZXh0KHVybCwgaW5pdCk7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDAgfHwgcmVzcG9uc2Uuc3RhdHVzID09PSAyMDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBBcGlFcnJvciAmJiBlcnJvci5zdGF0dXMgPT09IDQyOSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldHJ5QWZ0ZXJIZWFkZXIgPSBlcnJvci5oZWFkZXJzLmdldCgncmV0cnktYWZ0ZXInKT8uWzBdO1xuICAgICAgICAgICAgICAgIGlmIChyZXRyeUFmdGVySGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBRZHJhbnRDbGllbnRSZXNvdXJjZUV4aGF1c3RlZEVycm9yKGVycm9yLm1lc3NhZ2UsIHJldHJ5QWZ0ZXJIZWFkZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IFFkcmFudENsaWVudFVuZXhwZWN0ZWRSZXNwb25zZUVycm9yLmZvclJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICB9KTtcbiAgICBjb25zdCBjbGllbnQgPSBGZXRjaGVyLmZvcigpO1xuICAgIC8vIENvbmZpZ3VyZSBjbGllbnQgd2l0aCAndW5kaWNpJyBhZ2VudCB3aGljaCBpcyB1c2VkIGluIE5vZGUgMTgrXG4gICAgY2xpZW50LmNvbmZpZ3VyZSh7XG4gICAgICAgIGJhc2VVcmwsXG4gICAgICAgIGluaXQ6IHtcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gICAgICAgICAgICBkaXNwYXRjaGVyOiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgICAgICAgICAgICAgIHByb2Nlc3MudmVyc2lvbnM/Lm5vZGVcbiAgICAgICAgICAgICAgICA/IGNyZWF0ZURpc3BhdGNoZXIoY29ubmVjdGlvbnMpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH0sXG4gICAgICAgIHVzZSxcbiAgICB9KTtcbiAgICByZXR1cm4gY2xpZW50O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@qdrant/js-client-rest/dist/esm/api-client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@qdrant/js-client-rest/dist/esm/client-version.js":
/*!************************************************************************!*\
  !*** ./node_modules/@qdrant/js-client-rest/dist/esm/client-version.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClientVersion: () => (/* binding */ ClientVersion),\n/* harmony export */   PACKAGE_VERSION: () => (/* binding */ PACKAGE_VERSION)\n/* harmony export */ });\nconst PACKAGE_VERSION = '1.15.1';\nconst ClientVersion = {\n    /**\n     * Parses a version string into a structured Version object.\n     * @param version - The version string to parse (e.g., \"1.2.3\").\n     * @returns A Version object.\n     * @throws If the version format is invalid.\n     */\n    parseVersion(version) {\n        if (!version) {\n            throw new Error('Version is null');\n        }\n        let major = undefined;\n        let minor = undefined;\n        [major, minor] = version.split('.', 2);\n        major = parseInt(major, 10);\n        minor = parseInt(minor, 10);\n        if (isNaN(major) || isNaN(minor)) {\n            throw new Error(`Unable to parse version, expected format: x.y[.z], found: ${version}`);\n        }\n        return {\n            major,\n            minor,\n        };\n    },\n    /**\n     * Checks if the client version is compatible with the server version.\n     * @param clientVersion - The client version string.\n     * @param serverVersion - The server version string.\n     * @returns True if compatible, otherwise false.\n     */\n    isCompatible(clientVersion, serverVersion) {\n        if (!clientVersion || !serverVersion) {\n            console.debug(`Unable to compare versions with null values. Client: ${clientVersion}, Server: ${serverVersion}`);\n            return false;\n        }\n        if (clientVersion === serverVersion)\n            return true;\n        try {\n            const client = ClientVersion.parseVersion(clientVersion);\n            const server = ClientVersion.parseVersion(serverVersion);\n            return client.major === server.major && Math.abs(client.minor - server.minor) <= 1;\n        }\n        catch (error) {\n            console.debug(`Unable to compare versions: ${error}`);\n            return false;\n        }\n    },\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHFkcmFudC9qcy1jbGllbnQtcmVzdC9kaXN0L2VzbS9jbGllbnQtdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFPO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RixRQUFRO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRixjQUFjLFlBQVksY0FBYztBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxNQUFNO0FBQy9EO0FBQ0E7QUFDQSxLQUFLO0FBQ0wiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC1zYWdlLWJvdC8uL25vZGVfbW9kdWxlcy9AcWRyYW50L2pzLWNsaWVudC1yZXN0L2Rpc3QvZXNtL2NsaWVudC12ZXJzaW9uLmpzPzM0MTciXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IFBBQ0tBR0VfVkVSU0lPTiA9ICcxLjE1LjEnO1xuZXhwb3J0IGNvbnN0IENsaWVudFZlcnNpb24gPSB7XG4gICAgLyoqXG4gICAgICogUGFyc2VzIGEgdmVyc2lvbiBzdHJpbmcgaW50byBhIHN0cnVjdHVyZWQgVmVyc2lvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHZlcnNpb24gLSBUaGUgdmVyc2lvbiBzdHJpbmcgdG8gcGFyc2UgKGUuZy4sIFwiMS4yLjNcIikuXG4gICAgICogQHJldHVybnMgQSBWZXJzaW9uIG9iamVjdC5cbiAgICAgKiBAdGhyb3dzIElmIHRoZSB2ZXJzaW9uIGZvcm1hdCBpcyBpbnZhbGlkLlxuICAgICAqL1xuICAgIHBhcnNlVmVyc2lvbih2ZXJzaW9uKSB7XG4gICAgICAgIGlmICghdmVyc2lvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWZXJzaW9uIGlzIG51bGwnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbWFqb3IgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBtaW5vciA9IHVuZGVmaW5lZDtcbiAgICAgICAgW21ham9yLCBtaW5vcl0gPSB2ZXJzaW9uLnNwbGl0KCcuJywgMik7XG4gICAgICAgIG1ham9yID0gcGFyc2VJbnQobWFqb3IsIDEwKTtcbiAgICAgICAgbWlub3IgPSBwYXJzZUludChtaW5vciwgMTApO1xuICAgICAgICBpZiAoaXNOYU4obWFqb3IpIHx8IGlzTmFOKG1pbm9yKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gcGFyc2UgdmVyc2lvbiwgZXhwZWN0ZWQgZm9ybWF0OiB4LnlbLnpdLCBmb3VuZDogJHt2ZXJzaW9ufWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtYWpvcixcbiAgICAgICAgICAgIG1pbm9yLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBjbGllbnQgdmVyc2lvbiBpcyBjb21wYXRpYmxlIHdpdGggdGhlIHNlcnZlciB2ZXJzaW9uLlxuICAgICAqIEBwYXJhbSBjbGllbnRWZXJzaW9uIC0gVGhlIGNsaWVudCB2ZXJzaW9uIHN0cmluZy5cbiAgICAgKiBAcGFyYW0gc2VydmVyVmVyc2lvbiAtIFRoZSBzZXJ2ZXIgdmVyc2lvbiBzdHJpbmcuXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiBjb21wYXRpYmxlLCBvdGhlcndpc2UgZmFsc2UuXG4gICAgICovXG4gICAgaXNDb21wYXRpYmxlKGNsaWVudFZlcnNpb24sIHNlcnZlclZlcnNpb24pIHtcbiAgICAgICAgaWYgKCFjbGllbnRWZXJzaW9uIHx8ICFzZXJ2ZXJWZXJzaW9uKSB7XG4gICAgICAgICAgICBjb25zb2xlLmRlYnVnKGBVbmFibGUgdG8gY29tcGFyZSB2ZXJzaW9ucyB3aXRoIG51bGwgdmFsdWVzLiBDbGllbnQ6ICR7Y2xpZW50VmVyc2lvbn0sIFNlcnZlcjogJHtzZXJ2ZXJWZXJzaW9ufWApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbGllbnRWZXJzaW9uID09PSBzZXJ2ZXJWZXJzaW9uKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjbGllbnQgPSBDbGllbnRWZXJzaW9uLnBhcnNlVmVyc2lvbihjbGllbnRWZXJzaW9uKTtcbiAgICAgICAgICAgIGNvbnN0IHNlcnZlciA9IENsaWVudFZlcnNpb24ucGFyc2VWZXJzaW9uKHNlcnZlclZlcnNpb24pO1xuICAgICAgICAgICAgcmV0dXJuIGNsaWVudC5tYWpvciA9PT0gc2VydmVyLm1ham9yICYmIE1hdGguYWJzKGNsaWVudC5taW5vciAtIHNlcnZlci5taW5vcikgPD0gMTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoYFVuYWJsZSB0byBjb21wYXJlIHZlcnNpb25zOiAke2Vycm9yfWApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSxcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@qdrant/js-client-rest/dist/esm/client-version.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@qdrant/js-client-rest/dist/esm/dispatcher.js":
/*!********************************************************************!*\
  !*** ./node_modules/@qdrant/js-client-rest/dist/esm/dispatcher.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createDispatcher: () => (/* binding */ createDispatcher)\n/* harmony export */ });\n/* harmony import */ var undici__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! undici */ \"(rsc)/./node_modules/undici/index.js\");\n/* eslint-disable @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-return */\n\nconst createDispatcher = (connections = 25) => \n// eslint-disable-next-line @typescript-eslint/no-unsafe-return\nnew undici__WEBPACK_IMPORTED_MODULE_0__.Agent({\n    // timeouts are handled by AbortSignal in our middleware\n    bodyTimeout: 0,\n    headersTimeout: 0,\n    // https://stackoverflow.com/a/36437932/558180\n    // pipelining: 1,\n    // a sensible max connections value\n    connections,\n    // will be overriden by header Keep-Alive, just as sensible default\n    keepAliveTimeout: 10000,\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHFkcmFudC9qcy1jbGllbnQtcmVzdC9kaXN0L2VzbS9kaXNwYXRjaGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDK0I7QUFDeEI7QUFDUDtBQUNBLElBQUkseUNBQUs7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtc2FnZS1ib3QvLi9ub2RlX21vZHVsZXMvQHFkcmFudC9qcy1jbGllbnQtcmVzdC9kaXN0L2VzbS9kaXNwYXRjaGVyLmpzPzMzYjQiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1jYWxsLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVybiAqL1xuaW1wb3J0IHsgQWdlbnQgfSBmcm9tICd1bmRpY2knO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZURpc3BhdGNoZXIgPSAoY29ubmVjdGlvbnMgPSAyNSkgPT4gXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cbm5ldyBBZ2VudCh7XG4gICAgLy8gdGltZW91dHMgYXJlIGhhbmRsZWQgYnkgQWJvcnRTaWduYWwgaW4gb3VyIG1pZGRsZXdhcmVcbiAgICBib2R5VGltZW91dDogMCxcbiAgICBoZWFkZXJzVGltZW91dDogMCxcbiAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzY0Mzc5MzIvNTU4MTgwXG4gICAgLy8gcGlwZWxpbmluZzogMSxcbiAgICAvLyBhIHNlbnNpYmxlIG1heCBjb25uZWN0aW9ucyB2YWx1ZVxuICAgIGNvbm5lY3Rpb25zLFxuICAgIC8vIHdpbGwgYmUgb3ZlcnJpZGVuIGJ5IGhlYWRlciBLZWVwLUFsaXZlLCBqdXN0IGFzIHNlbnNpYmxlIGRlZmF1bHRcbiAgICBrZWVwQWxpdmVUaW1lb3V0OiAxMDAwMCxcbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@qdrant/js-client-rest/dist/esm/dispatcher.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@qdrant/js-client-rest/dist/esm/errors.js":
/*!****************************************************************!*\
  !*** ./node_modules/@qdrant/js-client-rest/dist/esm/errors.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QdrantClientConfigError: () => (/* binding */ QdrantClientConfigError),\n/* harmony export */   QdrantClientResourceExhaustedError: () => (/* binding */ QdrantClientResourceExhaustedError),\n/* harmony export */   QdrantClientTimeoutError: () => (/* binding */ QdrantClientTimeoutError),\n/* harmony export */   QdrantClientUnexpectedResponseError: () => (/* binding */ QdrantClientUnexpectedResponseError)\n/* harmony export */ });\nconst MAX_CONTENT = 200;\nclass CustomError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = this.constructor.name;\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\nclass QdrantClientUnexpectedResponseError extends CustomError {\n    static forResponse(response) {\n        const statusCodeStr = `${response.status}`;\n        const reasonPhraseStr = !response.statusText ? '(Unrecognized Status Code)' : `(${response.statusText})`;\n        const statusStr = `${statusCodeStr} ${reasonPhraseStr}`.trim();\n        const dataStr = response.data ? JSON.stringify(response.data, null, 2) : null;\n        let shortContent = '';\n        if (dataStr) {\n            shortContent = dataStr.length <= MAX_CONTENT ? dataStr : dataStr.slice(0, -4) + ' ...';\n        }\n        const rawContentStr = `Raw response content:\\n${shortContent}`;\n        return new QdrantClientUnexpectedResponseError(`Unexpected Response: ${statusStr}\\n${rawContentStr}`);\n    }\n}\nclass QdrantClientConfigError extends CustomError {\n}\nclass QdrantClientTimeoutError extends CustomError {\n}\nclass QdrantClientResourceExhaustedError extends CustomError {\n    constructor(message, retryAfter) {\n        super(message);\n        const retryAfterNumber = Number(retryAfter);\n        if (isNaN(retryAfterNumber)) {\n            throw new CustomError(`Invalid retryAfter value: ${retryAfter}`);\n        }\n        this.retry_after = retryAfterNumber;\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHFkcmFudC9qcy1jbGllbnQtcmVzdC9kaXN0L2VzbS9lcnJvcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsaUNBQWlDLGdCQUFnQjtBQUNqRCwwRkFBMEYsb0JBQW9CO0FBQzlHLDZCQUE2QixlQUFlLEVBQUUsZ0JBQWdCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsYUFBYTtBQUNyRSwrRUFBK0UsVUFBVSxJQUFJLGNBQWM7QUFDM0c7QUFDQTtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxXQUFXO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC1zYWdlLWJvdC8uL25vZGVfbW9kdWxlcy9AcWRyYW50L2pzLWNsaWVudC1yZXN0L2Rpc3QvZXNtL2Vycm9ycy5qcz9jY2I3Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IE1BWF9DT05URU5UID0gMjAwO1xuY2xhc3MgQ3VzdG9tRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgbmV3LnRhcmdldC5wcm90b3R5cGUpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBRZHJhbnRDbGllbnRVbmV4cGVjdGVkUmVzcG9uc2VFcnJvciBleHRlbmRzIEN1c3RvbUVycm9yIHtcbiAgICBzdGF0aWMgZm9yUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICAgICAgY29uc3Qgc3RhdHVzQ29kZVN0ciA9IGAke3Jlc3BvbnNlLnN0YXR1c31gO1xuICAgICAgICBjb25zdCByZWFzb25QaHJhc2VTdHIgPSAhcmVzcG9uc2Uuc3RhdHVzVGV4dCA/ICcoVW5yZWNvZ25pemVkIFN0YXR1cyBDb2RlKScgOiBgKCR7cmVzcG9uc2Uuc3RhdHVzVGV4dH0pYDtcbiAgICAgICAgY29uc3Qgc3RhdHVzU3RyID0gYCR7c3RhdHVzQ29kZVN0cn0gJHtyZWFzb25QaHJhc2VTdHJ9YC50cmltKCk7XG4gICAgICAgIGNvbnN0IGRhdGFTdHIgPSByZXNwb25zZS5kYXRhID8gSlNPTi5zdHJpbmdpZnkocmVzcG9uc2UuZGF0YSwgbnVsbCwgMikgOiBudWxsO1xuICAgICAgICBsZXQgc2hvcnRDb250ZW50ID0gJyc7XG4gICAgICAgIGlmIChkYXRhU3RyKSB7XG4gICAgICAgICAgICBzaG9ydENvbnRlbnQgPSBkYXRhU3RyLmxlbmd0aCA8PSBNQVhfQ09OVEVOVCA/IGRhdGFTdHIgOiBkYXRhU3RyLnNsaWNlKDAsIC00KSArICcgLi4uJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByYXdDb250ZW50U3RyID0gYFJhdyByZXNwb25zZSBjb250ZW50OlxcbiR7c2hvcnRDb250ZW50fWA7XG4gICAgICAgIHJldHVybiBuZXcgUWRyYW50Q2xpZW50VW5leHBlY3RlZFJlc3BvbnNlRXJyb3IoYFVuZXhwZWN0ZWQgUmVzcG9uc2U6ICR7c3RhdHVzU3RyfVxcbiR7cmF3Q29udGVudFN0cn1gKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgUWRyYW50Q2xpZW50Q29uZmlnRXJyb3IgZXh0ZW5kcyBDdXN0b21FcnJvciB7XG59XG5leHBvcnQgY2xhc3MgUWRyYW50Q2xpZW50VGltZW91dEVycm9yIGV4dGVuZHMgQ3VzdG9tRXJyb3Ige1xufVxuZXhwb3J0IGNsYXNzIFFkcmFudENsaWVudFJlc291cmNlRXhoYXVzdGVkRXJyb3IgZXh0ZW5kcyBDdXN0b21FcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgcmV0cnlBZnRlcikge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgY29uc3QgcmV0cnlBZnRlck51bWJlciA9IE51bWJlcihyZXRyeUFmdGVyKTtcbiAgICAgICAgaWYgKGlzTmFOKHJldHJ5QWZ0ZXJOdW1iZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ3VzdG9tRXJyb3IoYEludmFsaWQgcmV0cnlBZnRlciB2YWx1ZTogJHtyZXRyeUFmdGVyfWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmV0cnlfYWZ0ZXIgPSByZXRyeUFmdGVyTnVtYmVyO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgbmV3LnRhcmdldC5wcm90b3R5cGUpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@qdrant/js-client-rest/dist/esm/errors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@qdrant/js-client-rest/dist/esm/openapi/generated_api_client.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@qdrant/js-client-rest/dist/esm/openapi/generated_api_client.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createClientApi: () => (/* binding */ createClientApi)\n/* harmony export */ });\n// AUTOMATICALLY GENERATED FILE. DO NOT EDIT!\nfunction createClientApi(client) {\n    return {\n        /** Create shard key */\n        createShardKey: client\n            .path('/collections/{collection_name}/shards')\n            .method('put')\n            .create({\n            timeout: true,\n        }),\n        /** Delete shard key */\n        deleteShardKey: client\n            .path('/collections/{collection_name}/shards/delete')\n            .method('post')\n            .create({\n            timeout: true,\n        }),\n        /**\n             * Returns information about the running Qdrant instance\n             * @description Returns information about the running Qdrant instance like version and commit id\n             */\n        root: client\n            .path('/')\n            .method('get')\n            .create(),\n        /**\n             * Collect telemetry data\n             * @description Collect telemetry data including app info, system info, collections info, cluster info, configs and statistics\n             */\n        telemetry: client\n            .path('/telemetry')\n            .method('get')\n            .create(),\n        /**\n             * Collect Prometheus metrics data\n             * @description Collect metrics data including app info, collections info, cluster info and statistics\n             */\n        metrics: client\n            .path('/metrics')\n            .method('get')\n            .create(),\n        /**\n             * Get lock options\n             * @deprecated\n             * @description Get lock options. If write is locked, all write operations and collection creation are forbidden\n             */\n        getLocks: client\n            .path('/locks')\n            .method('get')\n            .create(),\n        /**\n             * Set lock options\n             * @deprecated\n             * @description Set lock options. If write is locked, all write operations and collection creation are forbidden. Returns previous lock options\n             */\n        postLocks: client\n            .path('/locks')\n            .method('post')\n            .create(),\n        /**\n             * Kubernetes healthz endpoint\n             * @description An endpoint for health checking used in Kubernetes.\n             */\n        healthz: client\n            .path('/healthz')\n            .method('get')\n            .create(),\n        /**\n             * Kubernetes livez endpoint\n             * @description An endpoint for health checking used in Kubernetes.\n             */\n        livez: client\n            .path('/livez')\n            .method('get')\n            .create(),\n        /**\n             * Kubernetes readyz endpoint\n             * @description An endpoint for health checking used in Kubernetes.\n             */\n        readyz: client\n            .path('/readyz')\n            .method('get')\n            .create(),\n        /**\n             * Get issues\n             * @description Get a report of performance issues and configuration suggestions\n             */\n        getIssues: client\n            .path('/issues')\n            .method('get')\n            .create(),\n        /**\n             * Clear issues\n             * @description Removes all issues reported so far\n             */\n        clearIssues: client\n            .path('/issues')\n            .method('delete')\n            .create(),\n        /**\n             * Get cluster status info\n             * @description Get information about the current state and composition of the cluster\n             */\n        clusterStatus: client\n            .path('/cluster')\n            .method('get')\n            .create(),\n        /** Tries to recover current peer Raft state. */\n        recoverCurrentPeer: client\n            .path('/cluster/recover')\n            .method('post')\n            .create(),\n        /**\n             * Remove peer from the cluster\n             * @description Tries to remove peer from the cluster. Will return an error if peer has shards on it.\n             */\n        removePeer: client\n            .path('/cluster/peer/{peer_id}')\n            .method('delete')\n            .create({\n            force: true,\n        }),\n        /**\n             * List collections\n             * @description Get list name of all existing collections\n             */\n        getCollections: client\n            .path('/collections')\n            .method('get')\n            .create(),\n        /**\n             * Collection info\n             * @description Get detailed information about specified existing collection\n             */\n        getCollection: client\n            .path('/collections/{collection_name}')\n            .method('get')\n            .create(),\n        /**\n             * Create collection\n             * @description Create new collection with given parameters\n             */\n        createCollection: client\n            .path('/collections/{collection_name}')\n            .method('put')\n            .create({\n            timeout: true,\n        }),\n        /**\n             * Delete collection\n             * @description Drop collection and all associated data\n             */\n        deleteCollection: client\n            .path('/collections/{collection_name}')\n            .method('delete')\n            .create({\n            timeout: true,\n        }),\n        /**\n             * Update collection parameters\n             * @description Update parameters of the existing collection\n             */\n        updateCollection: client\n            .path('/collections/{collection_name}')\n            .method('patch')\n            .create({\n            timeout: true,\n        }),\n        /** Update aliases of the collections */\n        updateAliases: client\n            .path('/collections/aliases')\n            .method('post')\n            .create({\n            timeout: true,\n        }),\n        /**\n             * Create index for field in collection\n             * @description Create index for field in collection\n             */\n        createFieldIndex: client\n            .path('/collections/{collection_name}/index')\n            .method('put')\n            .create({\n            wait: true,\n            ordering: true,\n        }),\n        /**\n             * Check the existence of a collection\n             * @description Returns \"true\" if the given collection name exists, and \"false\" otherwise\n             */\n        collectionExists: client\n            .path('/collections/{collection_name}/exists')\n            .method('get')\n            .create(),\n        /**\n             * Delete index for field in collection\n             * @description Delete field index for collection\n             */\n        deleteFieldIndex: client\n            .path('/collections/{collection_name}/index/{field_name}')\n            .method('delete')\n            .create({\n            wait: true,\n            ordering: true,\n        }),\n        /**\n             * Collection cluster info\n             * @description Get cluster information for a collection\n             */\n        collectionClusterInfo: client\n            .path('/collections/{collection_name}/cluster')\n            .method('get')\n            .create(),\n        /** Update collection cluster setup */\n        updateCollectionCluster: client\n            .path('/collections/{collection_name}/cluster')\n            .method('post')\n            .create({\n            timeout: true,\n        }),\n        /**\n             * List aliases for collection\n             * @description Get list of all aliases for a collection\n             */\n        getCollectionAliases: client\n            .path('/collections/{collection_name}/aliases')\n            .method('get')\n            .create(),\n        /**\n             * List collections aliases\n             * @description Get list of all existing collections aliases\n             */\n        getCollectionsAliases: client\n            .path('/aliases')\n            .method('get')\n            .create(),\n        /**\n             * Recover from an uploaded snapshot\n             * @description Recover local collection data from an uploaded snapshot. This will overwrite any data, stored on this node, for the collection. If collection does not exist - it will be created.\n             */\n        recoverFromUploadedSnapshot: client\n            .path('/collections/{collection_name}/snapshots/upload')\n            .method('post')\n            .create({\n            wait: true,\n            priority: true,\n            checksum: true,\n        }),\n        /**\n             * Recover from a snapshot\n             * @description Recover local collection data from a snapshot. This will overwrite any data, stored on this node, for the collection. If collection does not exist - it will be created.\n             */\n        recoverFromSnapshot: client\n            .path('/collections/{collection_name}/snapshots/recover')\n            .method('put')\n            .create({\n            wait: true,\n        }),\n        /**\n             * List collection snapshots\n             * @description Get list of snapshots for a collection\n             */\n        listSnapshots: client\n            .path('/collections/{collection_name}/snapshots')\n            .method('get')\n            .create(),\n        /**\n             * Create collection snapshot\n             * @description Create new snapshot for a collection\n             */\n        createSnapshot: client\n            .path('/collections/{collection_name}/snapshots')\n            .method('post')\n            .create({\n            wait: true,\n        }),\n        /**\n             * Download collection snapshot\n             * @description Download specified snapshot from a collection as a file\n             */\n        getSnapshot: client\n            .path('/collections/{collection_name}/snapshots/{snapshot_name}')\n            .method('get')\n            .create(),\n        /**\n             * Delete collection snapshot\n             * @description Delete snapshot for a collection\n             */\n        deleteSnapshot: client\n            .path('/collections/{collection_name}/snapshots/{snapshot_name}')\n            .method('delete')\n            .create({\n            wait: true,\n        }),\n        /**\n             * List of storage snapshots\n             * @description Get list of snapshots of the whole storage\n             */\n        listFullSnapshots: client\n            .path('/snapshots')\n            .method('get')\n            .create(),\n        /**\n             * Create storage snapshot\n             * @description Create new snapshot of the whole storage\n             */\n        createFullSnapshot: client\n            .path('/snapshots')\n            .method('post')\n            .create({\n            wait: true,\n        }),\n        /**\n             * Download storage snapshot\n             * @description Download specified snapshot of the whole storage as a file\n             */\n        getFullSnapshot: client\n            .path('/snapshots/{snapshot_name}')\n            .method('get')\n            .create(),\n        /**\n             * Delete storage snapshot\n             * @description Delete snapshot of the whole storage\n             */\n        deleteFullSnapshot: client\n            .path('/snapshots/{snapshot_name}')\n            .method('delete')\n            .create({\n            wait: true,\n        }),\n        /**\n             * Recover shard from an uploaded snapshot\n             * @description Recover shard of a local collection from an uploaded snapshot. This will overwrite any data, stored on this node, for the collection shard.\n             */\n        recoverShardFromUploadedSnapshot: client\n            .path('/collections/{collection_name}/shards/{shard_id}/snapshots/upload')\n            .method('post')\n            .create({\n            wait: true,\n            priority: true,\n            checksum: true,\n        }),\n        /**\n             * Recover from a snapshot\n             * @description Recover shard of a local collection data from a snapshot. This will overwrite any data, stored in this shard, for the collection.\n             */\n        recoverShardFromSnapshot: client\n            .path('/collections/{collection_name}/shards/{shard_id}/snapshots/recover')\n            .method('put')\n            .create({\n            wait: true,\n        }),\n        /**\n             * List shards snapshots for a collection\n             * @description Get list of snapshots for a shard of a collection\n             */\n        listShardSnapshots: client\n            .path('/collections/{collection_name}/shards/{shard_id}/snapshots')\n            .method('get')\n            .create(),\n        /**\n             * Create shard snapshot\n             * @description Create new snapshot of a shard for a collection\n             */\n        createShardSnapshot: client\n            .path('/collections/{collection_name}/shards/{shard_id}/snapshots')\n            .method('post')\n            .create({\n            wait: true,\n        }),\n        /**\n             * Download collection snapshot\n             * @description Download specified snapshot of a shard from a collection as a file\n             */\n        getShardSnapshot: client\n            .path('/collections/{collection_name}/shards/{shard_id}/snapshots/{snapshot_name}')\n            .method('get')\n            .create(),\n        /**\n             * Delete shard snapshot\n             * @description Delete snapshot of a shard for a collection\n             */\n        deleteShardSnapshot: client\n            .path('/collections/{collection_name}/shards/{shard_id}/snapshots/{snapshot_name}')\n            .method('delete')\n            .create({\n            wait: true,\n        }),\n        /**\n             * Get point\n             * @description Retrieve full information of single point by id\n             */\n        getPoint: client\n            .path('/collections/{collection_name}/points/{id}')\n            .method('get')\n            .create(),\n        /**\n             * Upsert points\n             * @description Perform insert + updates on points. If point with given ID already exists - it will be overwritten.\n             */\n        upsertPoints: client\n            .path('/collections/{collection_name}/points')\n            .method('put')\n            .create({\n            wait: true,\n            ordering: true,\n        }),\n        /**\n             * Get points\n             * @description Retrieve multiple points by specified IDs\n             */\n        getPoints: client\n            .path('/collections/{collection_name}/points')\n            .method('post')\n            .create({\n            consistency: true,\n            timeout: true,\n        }),\n        /**\n             * Delete points\n             * @description Delete points\n             */\n        deletePoints: client\n            .path('/collections/{collection_name}/points/delete')\n            .method('post')\n            .create({\n            wait: true,\n            ordering: true,\n        }),\n        /**\n             * Update vectors\n             * @description Update specified named vectors on points, keep unspecified vectors intact.\n             */\n        updateVectors: client\n            .path('/collections/{collection_name}/points/vectors')\n            .method('put')\n            .create({\n            wait: true,\n            ordering: true,\n        }),\n        /**\n             * Delete vectors\n             * @description Delete named vectors from the given points.\n             */\n        deleteVectors: client\n            .path('/collections/{collection_name}/points/vectors/delete')\n            .method('post')\n            .create({\n            wait: true,\n            ordering: true,\n        }),\n        /**\n             * Overwrite payload\n             * @description Replace full payload of points with new one\n             */\n        overwritePayload: client\n            .path('/collections/{collection_name}/points/payload')\n            .method('put')\n            .create({\n            wait: true,\n            ordering: true,\n        }),\n        /**\n             * Set payload\n             * @description Set payload values for points\n             */\n        setPayload: client\n            .path('/collections/{collection_name}/points/payload')\n            .method('post')\n            .create({\n            wait: true,\n            ordering: true,\n        }),\n        /**\n             * Delete payload\n             * @description Delete specified key payload for points\n             */\n        deletePayload: client\n            .path('/collections/{collection_name}/points/payload/delete')\n            .method('post')\n            .create({\n            wait: true,\n            ordering: true,\n        }),\n        /**\n             * Clear payload\n             * @description Remove all payload for specified points\n             */\n        clearPayload: client\n            .path('/collections/{collection_name}/points/payload/clear')\n            .method('post')\n            .create({\n            wait: true,\n            ordering: true,\n        }),\n        /**\n             * Batch update points\n             * @description Apply a series of update operations for points, vectors and payloads\n             */\n        batchUpdate: client\n            .path('/collections/{collection_name}/points/batch')\n            .method('post')\n            .create({\n            wait: true,\n            ordering: true,\n        }),\n        /**\n             * Scroll points\n             * @description Scroll request - paginate over all points which matches given filtering condition\n             */\n        scrollPoints: client\n            .path('/collections/{collection_name}/points/scroll')\n            .method('post')\n            .create({\n            consistency: true,\n            timeout: true,\n        }),\n        /**\n             * Search points\n             * @deprecated\n             * @description Retrieve closest points based on vector similarity and given filtering conditions\n             */\n        searchPoints: client\n            .path('/collections/{collection_name}/points/search')\n            .method('post')\n            .create({\n            consistency: true,\n            timeout: true,\n        }),\n        /**\n             * Search batch points\n             * @deprecated\n             * @description Retrieve by batch the closest points based on vector similarity and given filtering conditions\n             */\n        searchBatchPoints: client\n            .path('/collections/{collection_name}/points/search/batch')\n            .method('post')\n            .create({\n            consistency: true,\n            timeout: true,\n        }),\n        /**\n             * Search point groups\n             * @deprecated\n             * @description Retrieve closest points based on vector similarity and given filtering conditions, grouped by a given payload field\n             */\n        searchPointGroups: client\n            .path('/collections/{collection_name}/points/search/groups')\n            .method('post')\n            .create({\n            consistency: true,\n            timeout: true,\n        }),\n        /**\n             * Recommend points\n             * @deprecated\n             * @description Look for the points which are closer to stored positive examples and at the same time further to negative examples.\n             */\n        recommendPoints: client\n            .path('/collections/{collection_name}/points/recommend')\n            .method('post')\n            .create({\n            consistency: true,\n            timeout: true,\n        }),\n        /**\n             * Recommend batch points\n             * @deprecated\n             * @description Look for the points which are closer to stored positive examples and at the same time further to negative examples.\n             */\n        recommendBatchPoints: client\n            .path('/collections/{collection_name}/points/recommend/batch')\n            .method('post')\n            .create({\n            consistency: true,\n            timeout: true,\n        }),\n        /**\n             * Recommend point groups\n             * @deprecated\n             * @description Look for the points which are closer to stored positive examples and at the same time further to negative examples, grouped by a given payload field.\n             */\n        recommendPointGroups: client\n            .path('/collections/{collection_name}/points/recommend/groups')\n            .method('post')\n            .create({\n            consistency: true,\n            timeout: true,\n        }),\n        /**\n             * Discover points\n             * @deprecated\n             * @description Use context and a target to find the most similar points to the target, constrained by the context.\n             * When using only the context (without a target), a special search - called context search - is performed where pairs of points are used to generate a loss that guides the search towards the zone where most positive examples overlap. This means that the score minimizes the scenario of finding a point closer to a negative than to a positive part of a pair.\n             * Since the score of a context relates to loss, the maximum score a point can get is 0.0, and it becomes normal that many points can have a score of 0.0.\n             * When using target (with or without context), the score behaves a little different: The  integer part of the score represents the rank with respect to the context, while the decimal part of the score relates to the distance to the target. The context part of the score for  each pair is calculated +1 if the point is closer to a positive than to a negative part of a pair,  and -1 otherwise.\n             */\n        discoverPoints: client\n            .path('/collections/{collection_name}/points/discover')\n            .method('post')\n            .create({\n            consistency: true,\n            timeout: true,\n        }),\n        /**\n             * Discover batch points\n             * @deprecated\n             * @description Look for points based on target and/or positive and negative example pairs, in batch.\n             */\n        discoverBatchPoints: client\n            .path('/collections/{collection_name}/points/discover/batch')\n            .method('post')\n            .create({\n            consistency: true,\n            timeout: true,\n        }),\n        /**\n             * Count points\n             * @description Count points which matches given filtering condition\n             */\n        countPoints: client\n            .path('/collections/{collection_name}/points/count')\n            .method('post')\n            .create({\n            timeout: true,\n        }),\n        /**\n             * Facet a payload key with a given filter.\n             * @description Count points that satisfy the given filter for each unique value of a payload key.\n             */\n        facet: client\n            .path('/collections/{collection_name}/facet')\n            .method('post')\n            .create({\n            timeout: true,\n            consistency: true,\n        }),\n        /**\n             * Query points\n             * @description Universally query points. This endpoint covers all capabilities of search, recommend, discover, filters. But also enables hybrid and multi-stage queries.\n             */\n        queryPoints: client\n            .path('/collections/{collection_name}/points/query')\n            .method('post')\n            .create({\n            consistency: true,\n            timeout: true,\n        }),\n        /**\n             * Query points in batch\n             * @description Universally query points in batch. This endpoint covers all capabilities of search, recommend, discover, filters. But also enables hybrid and multi-stage queries.\n             */\n        queryBatchPoints: client\n            .path('/collections/{collection_name}/points/query/batch')\n            .method('post')\n            .create({\n            consistency: true,\n            timeout: true,\n        }),\n        /**\n             * Query points, grouped by a given payload field\n             * @description Universally query points, grouped by a given payload field\n             */\n        queryPointsGroups: client\n            .path('/collections/{collection_name}/points/query/groups')\n            .method('post')\n            .create({\n            consistency: true,\n            timeout: true,\n        }),\n        /**\n             * Search points matrix distance pairs\n             * @description Compute distance matrix for sampled points with a pair based output format\n             */\n        searchMatrixPairs: client\n            .path('/collections/{collection_name}/points/search/matrix/pairs')\n            .method('post')\n            .create({\n            consistency: true,\n            timeout: true,\n        }),\n        /**\n             * Search points matrix distance offsets\n             * @description Compute distance matrix for sampled points with an offset based output format\n             */\n        searchMatrixOffsets: client\n            .path('/collections/{collection_name}/points/search/matrix/offsets')\n            .method('post')\n            .create({\n            consistency: true,\n            timeout: true,\n        }),\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHFkcmFudC9qcy1jbGllbnQtcmVzdC9kaXN0L2VzbS9vcGVuYXBpL2dlbmVyYXRlZF9hcGlfY2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdCQUFnQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdCQUFnQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0JBQWdCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdCQUFnQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0JBQWdCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0JBQWdCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdCQUFnQixRQUFRLFdBQVc7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0JBQWdCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdCQUFnQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0JBQWdCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0JBQWdCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdCQUFnQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0IsWUFBWSxjQUFjO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdCQUFnQixZQUFZLGNBQWM7QUFDM0U7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixjQUFjO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGNBQWM7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0JBQWdCLFNBQVMsU0FBUztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0JBQWdCLFNBQVMsU0FBUztBQUNuRTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0IsU0FBUyxTQUFTO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdCQUFnQixTQUFTLFNBQVM7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0JBQWdCLFNBQVMsU0FBUyxZQUFZLGNBQWM7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0JBQWdCLFNBQVMsU0FBUyxZQUFZLGNBQWM7QUFDN0Y7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0JBQWdCLFNBQVMsR0FBRztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdCQUFnQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0JBQWdCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdCQUFnQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0JBQWdCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdCQUFnQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0JBQWdCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0JBQWdCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdCQUFnQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdCQUFnQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdCQUFnQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdCQUFnQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdCQUFnQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdCQUFnQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtc2FnZS1ib3QvLi9ub2RlX21vZHVsZXMvQHFkcmFudC9qcy1jbGllbnQtcmVzdC9kaXN0L2VzbS9vcGVuYXBpL2dlbmVyYXRlZF9hcGlfY2xpZW50LmpzP2I4MGUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQVVUT01BVElDQUxMWSBHRU5FUkFURUQgRklMRS4gRE8gTk9UIEVESVQhXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2xpZW50QXBpKGNsaWVudCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKiBDcmVhdGUgc2hhcmQga2V5ICovXG4gICAgICAgIGNyZWF0ZVNoYXJkS2V5OiBjbGllbnRcbiAgICAgICAgICAgIC5wYXRoKCcvY29sbGVjdGlvbnMve2NvbGxlY3Rpb25fbmFtZX0vc2hhcmRzJylcbiAgICAgICAgICAgIC5tZXRob2QoJ3B1dCcpXG4gICAgICAgICAgICAuY3JlYXRlKHtcbiAgICAgICAgICAgIHRpbWVvdXQ6IHRydWUsXG4gICAgICAgIH0pLFxuICAgICAgICAvKiogRGVsZXRlIHNoYXJkIGtleSAqL1xuICAgICAgICBkZWxldGVTaGFyZEtleTogY2xpZW50XG4gICAgICAgICAgICAucGF0aCgnL2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uX25hbWV9L3NoYXJkcy9kZWxldGUnKVxuICAgICAgICAgICAgLm1ldGhvZCgncG9zdCcpXG4gICAgICAgICAgICAuY3JlYXRlKHtcbiAgICAgICAgICAgIHRpbWVvdXQ6IHRydWUsXG4gICAgICAgIH0pLFxuICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHVybnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJ1bm5pbmcgUWRyYW50IGluc3RhbmNlXG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcnVubmluZyBRZHJhbnQgaW5zdGFuY2UgbGlrZSB2ZXJzaW9uIGFuZCBjb21taXQgaWRcbiAgICAgICAgICAgICAqL1xuICAgICAgICByb290OiBjbGllbnRcbiAgICAgICAgICAgIC5wYXRoKCcvJylcbiAgICAgICAgICAgIC5tZXRob2QoJ2dldCcpXG4gICAgICAgICAgICAuY3JlYXRlKCksXG4gICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ29sbGVjdCB0ZWxlbWV0cnkgZGF0YVxuICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIENvbGxlY3QgdGVsZW1ldHJ5IGRhdGEgaW5jbHVkaW5nIGFwcCBpbmZvLCBzeXN0ZW0gaW5mbywgY29sbGVjdGlvbnMgaW5mbywgY2x1c3RlciBpbmZvLCBjb25maWdzIGFuZCBzdGF0aXN0aWNzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgdGVsZW1ldHJ5OiBjbGllbnRcbiAgICAgICAgICAgIC5wYXRoKCcvdGVsZW1ldHJ5JylcbiAgICAgICAgICAgIC5tZXRob2QoJ2dldCcpXG4gICAgICAgICAgICAuY3JlYXRlKCksXG4gICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ29sbGVjdCBQcm9tZXRoZXVzIG1ldHJpY3MgZGF0YVxuICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIENvbGxlY3QgbWV0cmljcyBkYXRhIGluY2x1ZGluZyBhcHAgaW5mbywgY29sbGVjdGlvbnMgaW5mbywgY2x1c3RlciBpbmZvIGFuZCBzdGF0aXN0aWNzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgbWV0cmljczogY2xpZW50XG4gICAgICAgICAgICAucGF0aCgnL21ldHJpY3MnKVxuICAgICAgICAgICAgLm1ldGhvZCgnZ2V0JylcbiAgICAgICAgICAgIC5jcmVhdGUoKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgbG9jayBvcHRpb25zXG4gICAgICAgICAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIEdldCBsb2NrIG9wdGlvbnMuIElmIHdyaXRlIGlzIGxvY2tlZCwgYWxsIHdyaXRlIG9wZXJhdGlvbnMgYW5kIGNvbGxlY3Rpb24gY3JlYXRpb24gYXJlIGZvcmJpZGRlblxuICAgICAgICAgICAgICovXG4gICAgICAgIGdldExvY2tzOiBjbGllbnRcbiAgICAgICAgICAgIC5wYXRoKCcvbG9ja3MnKVxuICAgICAgICAgICAgLm1ldGhvZCgnZ2V0JylcbiAgICAgICAgICAgIC5jcmVhdGUoKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTZXQgbG9jayBvcHRpb25zXG4gICAgICAgICAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIFNldCBsb2NrIG9wdGlvbnMuIElmIHdyaXRlIGlzIGxvY2tlZCwgYWxsIHdyaXRlIG9wZXJhdGlvbnMgYW5kIGNvbGxlY3Rpb24gY3JlYXRpb24gYXJlIGZvcmJpZGRlbi4gUmV0dXJucyBwcmV2aW91cyBsb2NrIG9wdGlvbnNcbiAgICAgICAgICAgICAqL1xuICAgICAgICBwb3N0TG9ja3M6IGNsaWVudFxuICAgICAgICAgICAgLnBhdGgoJy9sb2NrcycpXG4gICAgICAgICAgICAubWV0aG9kKCdwb3N0JylcbiAgICAgICAgICAgIC5jcmVhdGUoKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBLdWJlcm5ldGVzIGhlYWx0aHogZW5kcG9pbnRcbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiBBbiBlbmRwb2ludCBmb3IgaGVhbHRoIGNoZWNraW5nIHVzZWQgaW4gS3ViZXJuZXRlcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICBoZWFsdGh6OiBjbGllbnRcbiAgICAgICAgICAgIC5wYXRoKCcvaGVhbHRoeicpXG4gICAgICAgICAgICAubWV0aG9kKCdnZXQnKVxuICAgICAgICAgICAgLmNyZWF0ZSgpLFxuICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEt1YmVybmV0ZXMgbGl2ZXogZW5kcG9pbnRcbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiBBbiBlbmRwb2ludCBmb3IgaGVhbHRoIGNoZWNraW5nIHVzZWQgaW4gS3ViZXJuZXRlcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICBsaXZlejogY2xpZW50XG4gICAgICAgICAgICAucGF0aCgnL2xpdmV6JylcbiAgICAgICAgICAgIC5tZXRob2QoJ2dldCcpXG4gICAgICAgICAgICAuY3JlYXRlKCksXG4gICAgICAgIC8qKlxuICAgICAgICAgICAgICogS3ViZXJuZXRlcyByZWFkeXogZW5kcG9pbnRcbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiBBbiBlbmRwb2ludCBmb3IgaGVhbHRoIGNoZWNraW5nIHVzZWQgaW4gS3ViZXJuZXRlcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICByZWFkeXo6IGNsaWVudFxuICAgICAgICAgICAgLnBhdGgoJy9yZWFkeXonKVxuICAgICAgICAgICAgLm1ldGhvZCgnZ2V0JylcbiAgICAgICAgICAgIC5jcmVhdGUoKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgaXNzdWVzXG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24gR2V0IGEgcmVwb3J0IG9mIHBlcmZvcm1hbmNlIGlzc3VlcyBhbmQgY29uZmlndXJhdGlvbiBzdWdnZXN0aW9uc1xuICAgICAgICAgICAgICovXG4gICAgICAgIGdldElzc3VlczogY2xpZW50XG4gICAgICAgICAgICAucGF0aCgnL2lzc3VlcycpXG4gICAgICAgICAgICAubWV0aG9kKCdnZXQnKVxuICAgICAgICAgICAgLmNyZWF0ZSgpLFxuICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENsZWFyIGlzc3Vlc1xuICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIFJlbW92ZXMgYWxsIGlzc3VlcyByZXBvcnRlZCBzbyBmYXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICBjbGVhcklzc3VlczogY2xpZW50XG4gICAgICAgICAgICAucGF0aCgnL2lzc3VlcycpXG4gICAgICAgICAgICAubWV0aG9kKCdkZWxldGUnKVxuICAgICAgICAgICAgLmNyZWF0ZSgpLFxuICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCBjbHVzdGVyIHN0YXR1cyBpbmZvXG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24gR2V0IGluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50IHN0YXRlIGFuZCBjb21wb3NpdGlvbiBvZiB0aGUgY2x1c3RlclxuICAgICAgICAgICAgICovXG4gICAgICAgIGNsdXN0ZXJTdGF0dXM6IGNsaWVudFxuICAgICAgICAgICAgLnBhdGgoJy9jbHVzdGVyJylcbiAgICAgICAgICAgIC5tZXRob2QoJ2dldCcpXG4gICAgICAgICAgICAuY3JlYXRlKCksXG4gICAgICAgIC8qKiBUcmllcyB0byByZWNvdmVyIGN1cnJlbnQgcGVlciBSYWZ0IHN0YXRlLiAqL1xuICAgICAgICByZWNvdmVyQ3VycmVudFBlZXI6IGNsaWVudFxuICAgICAgICAgICAgLnBhdGgoJy9jbHVzdGVyL3JlY292ZXInKVxuICAgICAgICAgICAgLm1ldGhvZCgncG9zdCcpXG4gICAgICAgICAgICAuY3JlYXRlKCksXG4gICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVtb3ZlIHBlZXIgZnJvbSB0aGUgY2x1c3RlclxuICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIFRyaWVzIHRvIHJlbW92ZSBwZWVyIGZyb20gdGhlIGNsdXN0ZXIuIFdpbGwgcmV0dXJuIGFuIGVycm9yIGlmIHBlZXIgaGFzIHNoYXJkcyBvbiBpdC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICByZW1vdmVQZWVyOiBjbGllbnRcbiAgICAgICAgICAgIC5wYXRoKCcvY2x1c3Rlci9wZWVyL3twZWVyX2lkfScpXG4gICAgICAgICAgICAubWV0aG9kKCdkZWxldGUnKVxuICAgICAgICAgICAgLmNyZWF0ZSh7XG4gICAgICAgICAgICBmb3JjZTogdHJ1ZSxcbiAgICAgICAgfSksXG4gICAgICAgIC8qKlxuICAgICAgICAgICAgICogTGlzdCBjb2xsZWN0aW9uc1xuICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIEdldCBsaXN0IG5hbWUgb2YgYWxsIGV4aXN0aW5nIGNvbGxlY3Rpb25zXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgZ2V0Q29sbGVjdGlvbnM6IGNsaWVudFxuICAgICAgICAgICAgLnBhdGgoJy9jb2xsZWN0aW9ucycpXG4gICAgICAgICAgICAubWV0aG9kKCdnZXQnKVxuICAgICAgICAgICAgLmNyZWF0ZSgpLFxuICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENvbGxlY3Rpb24gaW5mb1xuICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIEdldCBkZXRhaWxlZCBpbmZvcm1hdGlvbiBhYm91dCBzcGVjaWZpZWQgZXhpc3RpbmcgY29sbGVjdGlvblxuICAgICAgICAgICAgICovXG4gICAgICAgIGdldENvbGxlY3Rpb246IGNsaWVudFxuICAgICAgICAgICAgLnBhdGgoJy9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbl9uYW1lfScpXG4gICAgICAgICAgICAubWV0aG9kKCdnZXQnKVxuICAgICAgICAgICAgLmNyZWF0ZSgpLFxuICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENyZWF0ZSBjb2xsZWN0aW9uXG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlIG5ldyBjb2xsZWN0aW9uIHdpdGggZ2l2ZW4gcGFyYW1ldGVyc1xuICAgICAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZUNvbGxlY3Rpb246IGNsaWVudFxuICAgICAgICAgICAgLnBhdGgoJy9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbl9uYW1lfScpXG4gICAgICAgICAgICAubWV0aG9kKCdwdXQnKVxuICAgICAgICAgICAgLmNyZWF0ZSh7XG4gICAgICAgICAgICB0aW1lb3V0OiB0cnVlLFxuICAgICAgICB9KSxcbiAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEZWxldGUgY29sbGVjdGlvblxuICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIERyb3AgY29sbGVjdGlvbiBhbmQgYWxsIGFzc29jaWF0ZWQgZGF0YVxuICAgICAgICAgICAgICovXG4gICAgICAgIGRlbGV0ZUNvbGxlY3Rpb246IGNsaWVudFxuICAgICAgICAgICAgLnBhdGgoJy9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbl9uYW1lfScpXG4gICAgICAgICAgICAubWV0aG9kKCdkZWxldGUnKVxuICAgICAgICAgICAgLmNyZWF0ZSh7XG4gICAgICAgICAgICB0aW1lb3V0OiB0cnVlLFxuICAgICAgICB9KSxcbiAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBVcGRhdGUgY29sbGVjdGlvbiBwYXJhbWV0ZXJzXG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24gVXBkYXRlIHBhcmFtZXRlcnMgb2YgdGhlIGV4aXN0aW5nIGNvbGxlY3Rpb25cbiAgICAgICAgICAgICAqL1xuICAgICAgICB1cGRhdGVDb2xsZWN0aW9uOiBjbGllbnRcbiAgICAgICAgICAgIC5wYXRoKCcvY29sbGVjdGlvbnMve2NvbGxlY3Rpb25fbmFtZX0nKVxuICAgICAgICAgICAgLm1ldGhvZCgncGF0Y2gnKVxuICAgICAgICAgICAgLmNyZWF0ZSh7XG4gICAgICAgICAgICB0aW1lb3V0OiB0cnVlLFxuICAgICAgICB9KSxcbiAgICAgICAgLyoqIFVwZGF0ZSBhbGlhc2VzIG9mIHRoZSBjb2xsZWN0aW9ucyAqL1xuICAgICAgICB1cGRhdGVBbGlhc2VzOiBjbGllbnRcbiAgICAgICAgICAgIC5wYXRoKCcvY29sbGVjdGlvbnMvYWxpYXNlcycpXG4gICAgICAgICAgICAubWV0aG9kKCdwb3N0JylcbiAgICAgICAgICAgIC5jcmVhdGUoe1xuICAgICAgICAgICAgdGltZW91dDogdHJ1ZSxcbiAgICAgICAgfSksXG4gICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ3JlYXRlIGluZGV4IGZvciBmaWVsZCBpbiBjb2xsZWN0aW9uXG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlIGluZGV4IGZvciBmaWVsZCBpbiBjb2xsZWN0aW9uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlRmllbGRJbmRleDogY2xpZW50XG4gICAgICAgICAgICAucGF0aCgnL2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uX25hbWV9L2luZGV4JylcbiAgICAgICAgICAgIC5tZXRob2QoJ3B1dCcpXG4gICAgICAgICAgICAuY3JlYXRlKHtcbiAgICAgICAgICAgIHdhaXQ6IHRydWUsXG4gICAgICAgICAgICBvcmRlcmluZzogdHJ1ZSxcbiAgICAgICAgfSksXG4gICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ2hlY2sgdGhlIGV4aXN0ZW5jZSBvZiBhIGNvbGxlY3Rpb25cbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIFwidHJ1ZVwiIGlmIHRoZSBnaXZlbiBjb2xsZWN0aW9uIG5hbWUgZXhpc3RzLCBhbmQgXCJmYWxzZVwiIG90aGVyd2lzZVxuICAgICAgICAgICAgICovXG4gICAgICAgIGNvbGxlY3Rpb25FeGlzdHM6IGNsaWVudFxuICAgICAgICAgICAgLnBhdGgoJy9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbl9uYW1lfS9leGlzdHMnKVxuICAgICAgICAgICAgLm1ldGhvZCgnZ2V0JylcbiAgICAgICAgICAgIC5jcmVhdGUoKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEZWxldGUgaW5kZXggZm9yIGZpZWxkIGluIGNvbGxlY3Rpb25cbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiBEZWxldGUgZmllbGQgaW5kZXggZm9yIGNvbGxlY3Rpb25cbiAgICAgICAgICAgICAqL1xuICAgICAgICBkZWxldGVGaWVsZEluZGV4OiBjbGllbnRcbiAgICAgICAgICAgIC5wYXRoKCcvY29sbGVjdGlvbnMve2NvbGxlY3Rpb25fbmFtZX0vaW5kZXgve2ZpZWxkX25hbWV9JylcbiAgICAgICAgICAgIC5tZXRob2QoJ2RlbGV0ZScpXG4gICAgICAgICAgICAuY3JlYXRlKHtcbiAgICAgICAgICAgIHdhaXQ6IHRydWUsXG4gICAgICAgICAgICBvcmRlcmluZzogdHJ1ZSxcbiAgICAgICAgfSksXG4gICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ29sbGVjdGlvbiBjbHVzdGVyIGluZm9cbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiBHZXQgY2x1c3RlciBpbmZvcm1hdGlvbiBmb3IgYSBjb2xsZWN0aW9uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgY29sbGVjdGlvbkNsdXN0ZXJJbmZvOiBjbGllbnRcbiAgICAgICAgICAgIC5wYXRoKCcvY29sbGVjdGlvbnMve2NvbGxlY3Rpb25fbmFtZX0vY2x1c3RlcicpXG4gICAgICAgICAgICAubWV0aG9kKCdnZXQnKVxuICAgICAgICAgICAgLmNyZWF0ZSgpLFxuICAgICAgICAvKiogVXBkYXRlIGNvbGxlY3Rpb24gY2x1c3RlciBzZXR1cCAqL1xuICAgICAgICB1cGRhdGVDb2xsZWN0aW9uQ2x1c3RlcjogY2xpZW50XG4gICAgICAgICAgICAucGF0aCgnL2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uX25hbWV9L2NsdXN0ZXInKVxuICAgICAgICAgICAgLm1ldGhvZCgncG9zdCcpXG4gICAgICAgICAgICAuY3JlYXRlKHtcbiAgICAgICAgICAgIHRpbWVvdXQ6IHRydWUsXG4gICAgICAgIH0pLFxuICAgICAgICAvKipcbiAgICAgICAgICAgICAqIExpc3QgYWxpYXNlcyBmb3IgY29sbGVjdGlvblxuICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIEdldCBsaXN0IG9mIGFsbCBhbGlhc2VzIGZvciBhIGNvbGxlY3Rpb25cbiAgICAgICAgICAgICAqL1xuICAgICAgICBnZXRDb2xsZWN0aW9uQWxpYXNlczogY2xpZW50XG4gICAgICAgICAgICAucGF0aCgnL2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uX25hbWV9L2FsaWFzZXMnKVxuICAgICAgICAgICAgLm1ldGhvZCgnZ2V0JylcbiAgICAgICAgICAgIC5jcmVhdGUoKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBMaXN0IGNvbGxlY3Rpb25zIGFsaWFzZXNcbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiBHZXQgbGlzdCBvZiBhbGwgZXhpc3RpbmcgY29sbGVjdGlvbnMgYWxpYXNlc1xuICAgICAgICAgICAgICovXG4gICAgICAgIGdldENvbGxlY3Rpb25zQWxpYXNlczogY2xpZW50XG4gICAgICAgICAgICAucGF0aCgnL2FsaWFzZXMnKVxuICAgICAgICAgICAgLm1ldGhvZCgnZ2V0JylcbiAgICAgICAgICAgIC5jcmVhdGUoKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZWNvdmVyIGZyb20gYW4gdXBsb2FkZWQgc25hcHNob3RcbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiBSZWNvdmVyIGxvY2FsIGNvbGxlY3Rpb24gZGF0YSBmcm9tIGFuIHVwbG9hZGVkIHNuYXBzaG90LiBUaGlzIHdpbGwgb3ZlcndyaXRlIGFueSBkYXRhLCBzdG9yZWQgb24gdGhpcyBub2RlLCBmb3IgdGhlIGNvbGxlY3Rpb24uIElmIGNvbGxlY3Rpb24gZG9lcyBub3QgZXhpc3QgLSBpdCB3aWxsIGJlIGNyZWF0ZWQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgcmVjb3ZlckZyb21VcGxvYWRlZFNuYXBzaG90OiBjbGllbnRcbiAgICAgICAgICAgIC5wYXRoKCcvY29sbGVjdGlvbnMve2NvbGxlY3Rpb25fbmFtZX0vc25hcHNob3RzL3VwbG9hZCcpXG4gICAgICAgICAgICAubWV0aG9kKCdwb3N0JylcbiAgICAgICAgICAgIC5jcmVhdGUoe1xuICAgICAgICAgICAgd2FpdDogdHJ1ZSxcbiAgICAgICAgICAgIHByaW9yaXR5OiB0cnVlLFxuICAgICAgICAgICAgY2hlY2tzdW06IHRydWUsXG4gICAgICAgIH0pLFxuICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlY292ZXIgZnJvbSBhIHNuYXBzaG90XG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24gUmVjb3ZlciBsb2NhbCBjb2xsZWN0aW9uIGRhdGEgZnJvbSBhIHNuYXBzaG90LiBUaGlzIHdpbGwgb3ZlcndyaXRlIGFueSBkYXRhLCBzdG9yZWQgb24gdGhpcyBub2RlLCBmb3IgdGhlIGNvbGxlY3Rpb24uIElmIGNvbGxlY3Rpb24gZG9lcyBub3QgZXhpc3QgLSBpdCB3aWxsIGJlIGNyZWF0ZWQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgcmVjb3ZlckZyb21TbmFwc2hvdDogY2xpZW50XG4gICAgICAgICAgICAucGF0aCgnL2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uX25hbWV9L3NuYXBzaG90cy9yZWNvdmVyJylcbiAgICAgICAgICAgIC5tZXRob2QoJ3B1dCcpXG4gICAgICAgICAgICAuY3JlYXRlKHtcbiAgICAgICAgICAgIHdhaXQ6IHRydWUsXG4gICAgICAgIH0pLFxuICAgICAgICAvKipcbiAgICAgICAgICAgICAqIExpc3QgY29sbGVjdGlvbiBzbmFwc2hvdHNcbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiBHZXQgbGlzdCBvZiBzbmFwc2hvdHMgZm9yIGEgY29sbGVjdGlvblxuICAgICAgICAgICAgICovXG4gICAgICAgIGxpc3RTbmFwc2hvdHM6IGNsaWVudFxuICAgICAgICAgICAgLnBhdGgoJy9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbl9uYW1lfS9zbmFwc2hvdHMnKVxuICAgICAgICAgICAgLm1ldGhvZCgnZ2V0JylcbiAgICAgICAgICAgIC5jcmVhdGUoKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDcmVhdGUgY29sbGVjdGlvbiBzbmFwc2hvdFxuICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIENyZWF0ZSBuZXcgc25hcHNob3QgZm9yIGEgY29sbGVjdGlvblxuICAgICAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZVNuYXBzaG90OiBjbGllbnRcbiAgICAgICAgICAgIC5wYXRoKCcvY29sbGVjdGlvbnMve2NvbGxlY3Rpb25fbmFtZX0vc25hcHNob3RzJylcbiAgICAgICAgICAgIC5tZXRob2QoJ3Bvc3QnKVxuICAgICAgICAgICAgLmNyZWF0ZSh7XG4gICAgICAgICAgICB3YWl0OiB0cnVlLFxuICAgICAgICB9KSxcbiAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEb3dubG9hZCBjb2xsZWN0aW9uIHNuYXBzaG90XG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24gRG93bmxvYWQgc3BlY2lmaWVkIHNuYXBzaG90IGZyb20gYSBjb2xsZWN0aW9uIGFzIGEgZmlsZVxuICAgICAgICAgICAgICovXG4gICAgICAgIGdldFNuYXBzaG90OiBjbGllbnRcbiAgICAgICAgICAgIC5wYXRoKCcvY29sbGVjdGlvbnMve2NvbGxlY3Rpb25fbmFtZX0vc25hcHNob3RzL3tzbmFwc2hvdF9uYW1lfScpXG4gICAgICAgICAgICAubWV0aG9kKCdnZXQnKVxuICAgICAgICAgICAgLmNyZWF0ZSgpLFxuICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERlbGV0ZSBjb2xsZWN0aW9uIHNuYXBzaG90XG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24gRGVsZXRlIHNuYXBzaG90IGZvciBhIGNvbGxlY3Rpb25cbiAgICAgICAgICAgICAqL1xuICAgICAgICBkZWxldGVTbmFwc2hvdDogY2xpZW50XG4gICAgICAgICAgICAucGF0aCgnL2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uX25hbWV9L3NuYXBzaG90cy97c25hcHNob3RfbmFtZX0nKVxuICAgICAgICAgICAgLm1ldGhvZCgnZGVsZXRlJylcbiAgICAgICAgICAgIC5jcmVhdGUoe1xuICAgICAgICAgICAgd2FpdDogdHJ1ZSxcbiAgICAgICAgfSksXG4gICAgICAgIC8qKlxuICAgICAgICAgICAgICogTGlzdCBvZiBzdG9yYWdlIHNuYXBzaG90c1xuICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIEdldCBsaXN0IG9mIHNuYXBzaG90cyBvZiB0aGUgd2hvbGUgc3RvcmFnZVxuICAgICAgICAgICAgICovXG4gICAgICAgIGxpc3RGdWxsU25hcHNob3RzOiBjbGllbnRcbiAgICAgICAgICAgIC5wYXRoKCcvc25hcHNob3RzJylcbiAgICAgICAgICAgIC5tZXRob2QoJ2dldCcpXG4gICAgICAgICAgICAuY3JlYXRlKCksXG4gICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ3JlYXRlIHN0b3JhZ2Ugc25hcHNob3RcbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiBDcmVhdGUgbmV3IHNuYXBzaG90IG9mIHRoZSB3aG9sZSBzdG9yYWdlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlRnVsbFNuYXBzaG90OiBjbGllbnRcbiAgICAgICAgICAgIC5wYXRoKCcvc25hcHNob3RzJylcbiAgICAgICAgICAgIC5tZXRob2QoJ3Bvc3QnKVxuICAgICAgICAgICAgLmNyZWF0ZSh7XG4gICAgICAgICAgICB3YWl0OiB0cnVlLFxuICAgICAgICB9KSxcbiAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEb3dubG9hZCBzdG9yYWdlIHNuYXBzaG90XG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24gRG93bmxvYWQgc3BlY2lmaWVkIHNuYXBzaG90IG9mIHRoZSB3aG9sZSBzdG9yYWdlIGFzIGEgZmlsZVxuICAgICAgICAgICAgICovXG4gICAgICAgIGdldEZ1bGxTbmFwc2hvdDogY2xpZW50XG4gICAgICAgICAgICAucGF0aCgnL3NuYXBzaG90cy97c25hcHNob3RfbmFtZX0nKVxuICAgICAgICAgICAgLm1ldGhvZCgnZ2V0JylcbiAgICAgICAgICAgIC5jcmVhdGUoKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEZWxldGUgc3RvcmFnZSBzbmFwc2hvdFxuICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIERlbGV0ZSBzbmFwc2hvdCBvZiB0aGUgd2hvbGUgc3RvcmFnZVxuICAgICAgICAgICAgICovXG4gICAgICAgIGRlbGV0ZUZ1bGxTbmFwc2hvdDogY2xpZW50XG4gICAgICAgICAgICAucGF0aCgnL3NuYXBzaG90cy97c25hcHNob3RfbmFtZX0nKVxuICAgICAgICAgICAgLm1ldGhvZCgnZGVsZXRlJylcbiAgICAgICAgICAgIC5jcmVhdGUoe1xuICAgICAgICAgICAgd2FpdDogdHJ1ZSxcbiAgICAgICAgfSksXG4gICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVjb3ZlciBzaGFyZCBmcm9tIGFuIHVwbG9hZGVkIHNuYXBzaG90XG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24gUmVjb3ZlciBzaGFyZCBvZiBhIGxvY2FsIGNvbGxlY3Rpb24gZnJvbSBhbiB1cGxvYWRlZCBzbmFwc2hvdC4gVGhpcyB3aWxsIG92ZXJ3cml0ZSBhbnkgZGF0YSwgc3RvcmVkIG9uIHRoaXMgbm9kZSwgZm9yIHRoZSBjb2xsZWN0aW9uIHNoYXJkLlxuICAgICAgICAgICAgICovXG4gICAgICAgIHJlY292ZXJTaGFyZEZyb21VcGxvYWRlZFNuYXBzaG90OiBjbGllbnRcbiAgICAgICAgICAgIC5wYXRoKCcvY29sbGVjdGlvbnMve2NvbGxlY3Rpb25fbmFtZX0vc2hhcmRzL3tzaGFyZF9pZH0vc25hcHNob3RzL3VwbG9hZCcpXG4gICAgICAgICAgICAubWV0aG9kKCdwb3N0JylcbiAgICAgICAgICAgIC5jcmVhdGUoe1xuICAgICAgICAgICAgd2FpdDogdHJ1ZSxcbiAgICAgICAgICAgIHByaW9yaXR5OiB0cnVlLFxuICAgICAgICAgICAgY2hlY2tzdW06IHRydWUsXG4gICAgICAgIH0pLFxuICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlY292ZXIgZnJvbSBhIHNuYXBzaG90XG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24gUmVjb3ZlciBzaGFyZCBvZiBhIGxvY2FsIGNvbGxlY3Rpb24gZGF0YSBmcm9tIGEgc25hcHNob3QuIFRoaXMgd2lsbCBvdmVyd3JpdGUgYW55IGRhdGEsIHN0b3JlZCBpbiB0aGlzIHNoYXJkLCBmb3IgdGhlIGNvbGxlY3Rpb24uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgcmVjb3ZlclNoYXJkRnJvbVNuYXBzaG90OiBjbGllbnRcbiAgICAgICAgICAgIC5wYXRoKCcvY29sbGVjdGlvbnMve2NvbGxlY3Rpb25fbmFtZX0vc2hhcmRzL3tzaGFyZF9pZH0vc25hcHNob3RzL3JlY292ZXInKVxuICAgICAgICAgICAgLm1ldGhvZCgncHV0JylcbiAgICAgICAgICAgIC5jcmVhdGUoe1xuICAgICAgICAgICAgd2FpdDogdHJ1ZSxcbiAgICAgICAgfSksXG4gICAgICAgIC8qKlxuICAgICAgICAgICAgICogTGlzdCBzaGFyZHMgc25hcHNob3RzIGZvciBhIGNvbGxlY3Rpb25cbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiBHZXQgbGlzdCBvZiBzbmFwc2hvdHMgZm9yIGEgc2hhcmQgb2YgYSBjb2xsZWN0aW9uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgbGlzdFNoYXJkU25hcHNob3RzOiBjbGllbnRcbiAgICAgICAgICAgIC5wYXRoKCcvY29sbGVjdGlvbnMve2NvbGxlY3Rpb25fbmFtZX0vc2hhcmRzL3tzaGFyZF9pZH0vc25hcHNob3RzJylcbiAgICAgICAgICAgIC5tZXRob2QoJ2dldCcpXG4gICAgICAgICAgICAuY3JlYXRlKCksXG4gICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ3JlYXRlIHNoYXJkIHNuYXBzaG90XG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlIG5ldyBzbmFwc2hvdCBvZiBhIHNoYXJkIGZvciBhIGNvbGxlY3Rpb25cbiAgICAgICAgICAgICAqL1xuICAgICAgICBjcmVhdGVTaGFyZFNuYXBzaG90OiBjbGllbnRcbiAgICAgICAgICAgIC5wYXRoKCcvY29sbGVjdGlvbnMve2NvbGxlY3Rpb25fbmFtZX0vc2hhcmRzL3tzaGFyZF9pZH0vc25hcHNob3RzJylcbiAgICAgICAgICAgIC5tZXRob2QoJ3Bvc3QnKVxuICAgICAgICAgICAgLmNyZWF0ZSh7XG4gICAgICAgICAgICB3YWl0OiB0cnVlLFxuICAgICAgICB9KSxcbiAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEb3dubG9hZCBjb2xsZWN0aW9uIHNuYXBzaG90XG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24gRG93bmxvYWQgc3BlY2lmaWVkIHNuYXBzaG90IG9mIGEgc2hhcmQgZnJvbSBhIGNvbGxlY3Rpb24gYXMgYSBmaWxlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgZ2V0U2hhcmRTbmFwc2hvdDogY2xpZW50XG4gICAgICAgICAgICAucGF0aCgnL2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uX25hbWV9L3NoYXJkcy97c2hhcmRfaWR9L3NuYXBzaG90cy97c25hcHNob3RfbmFtZX0nKVxuICAgICAgICAgICAgLm1ldGhvZCgnZ2V0JylcbiAgICAgICAgICAgIC5jcmVhdGUoKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEZWxldGUgc2hhcmQgc25hcHNob3RcbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiBEZWxldGUgc25hcHNob3Qgb2YgYSBzaGFyZCBmb3IgYSBjb2xsZWN0aW9uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgZGVsZXRlU2hhcmRTbmFwc2hvdDogY2xpZW50XG4gICAgICAgICAgICAucGF0aCgnL2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uX25hbWV9L3NoYXJkcy97c2hhcmRfaWR9L3NuYXBzaG90cy97c25hcHNob3RfbmFtZX0nKVxuICAgICAgICAgICAgLm1ldGhvZCgnZGVsZXRlJylcbiAgICAgICAgICAgIC5jcmVhdGUoe1xuICAgICAgICAgICAgd2FpdDogdHJ1ZSxcbiAgICAgICAgfSksXG4gICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0IHBvaW50XG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24gUmV0cmlldmUgZnVsbCBpbmZvcm1hdGlvbiBvZiBzaW5nbGUgcG9pbnQgYnkgaWRcbiAgICAgICAgICAgICAqL1xuICAgICAgICBnZXRQb2ludDogY2xpZW50XG4gICAgICAgICAgICAucGF0aCgnL2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uX25hbWV9L3BvaW50cy97aWR9JylcbiAgICAgICAgICAgIC5tZXRob2QoJ2dldCcpXG4gICAgICAgICAgICAuY3JlYXRlKCksXG4gICAgICAgIC8qKlxuICAgICAgICAgICAgICogVXBzZXJ0IHBvaW50c1xuICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIFBlcmZvcm0gaW5zZXJ0ICsgdXBkYXRlcyBvbiBwb2ludHMuIElmIHBvaW50IHdpdGggZ2l2ZW4gSUQgYWxyZWFkeSBleGlzdHMgLSBpdCB3aWxsIGJlIG92ZXJ3cml0dGVuLlxuICAgICAgICAgICAgICovXG4gICAgICAgIHVwc2VydFBvaW50czogY2xpZW50XG4gICAgICAgICAgICAucGF0aCgnL2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uX25hbWV9L3BvaW50cycpXG4gICAgICAgICAgICAubWV0aG9kKCdwdXQnKVxuICAgICAgICAgICAgLmNyZWF0ZSh7XG4gICAgICAgICAgICB3YWl0OiB0cnVlLFxuICAgICAgICAgICAgb3JkZXJpbmc6IHRydWUsXG4gICAgICAgIH0pLFxuICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCBwb2ludHNcbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiBSZXRyaWV2ZSBtdWx0aXBsZSBwb2ludHMgYnkgc3BlY2lmaWVkIElEc1xuICAgICAgICAgICAgICovXG4gICAgICAgIGdldFBvaW50czogY2xpZW50XG4gICAgICAgICAgICAucGF0aCgnL2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uX25hbWV9L3BvaW50cycpXG4gICAgICAgICAgICAubWV0aG9kKCdwb3N0JylcbiAgICAgICAgICAgIC5jcmVhdGUoe1xuICAgICAgICAgICAgY29uc2lzdGVuY3k6IHRydWUsXG4gICAgICAgICAgICB0aW1lb3V0OiB0cnVlLFxuICAgICAgICB9KSxcbiAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEZWxldGUgcG9pbnRzXG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24gRGVsZXRlIHBvaW50c1xuICAgICAgICAgICAgICovXG4gICAgICAgIGRlbGV0ZVBvaW50czogY2xpZW50XG4gICAgICAgICAgICAucGF0aCgnL2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uX25hbWV9L3BvaW50cy9kZWxldGUnKVxuICAgICAgICAgICAgLm1ldGhvZCgncG9zdCcpXG4gICAgICAgICAgICAuY3JlYXRlKHtcbiAgICAgICAgICAgIHdhaXQ6IHRydWUsXG4gICAgICAgICAgICBvcmRlcmluZzogdHJ1ZSxcbiAgICAgICAgfSksXG4gICAgICAgIC8qKlxuICAgICAgICAgICAgICogVXBkYXRlIHZlY3RvcnNcbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiBVcGRhdGUgc3BlY2lmaWVkIG5hbWVkIHZlY3RvcnMgb24gcG9pbnRzLCBrZWVwIHVuc3BlY2lmaWVkIHZlY3RvcnMgaW50YWN0LlxuICAgICAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZVZlY3RvcnM6IGNsaWVudFxuICAgICAgICAgICAgLnBhdGgoJy9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbl9uYW1lfS9wb2ludHMvdmVjdG9ycycpXG4gICAgICAgICAgICAubWV0aG9kKCdwdXQnKVxuICAgICAgICAgICAgLmNyZWF0ZSh7XG4gICAgICAgICAgICB3YWl0OiB0cnVlLFxuICAgICAgICAgICAgb3JkZXJpbmc6IHRydWUsXG4gICAgICAgIH0pLFxuICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERlbGV0ZSB2ZWN0b3JzXG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24gRGVsZXRlIG5hbWVkIHZlY3RvcnMgZnJvbSB0aGUgZ2l2ZW4gcG9pbnRzLlxuICAgICAgICAgICAgICovXG4gICAgICAgIGRlbGV0ZVZlY3RvcnM6IGNsaWVudFxuICAgICAgICAgICAgLnBhdGgoJy9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbl9uYW1lfS9wb2ludHMvdmVjdG9ycy9kZWxldGUnKVxuICAgICAgICAgICAgLm1ldGhvZCgncG9zdCcpXG4gICAgICAgICAgICAuY3JlYXRlKHtcbiAgICAgICAgICAgIHdhaXQ6IHRydWUsXG4gICAgICAgICAgICBvcmRlcmluZzogdHJ1ZSxcbiAgICAgICAgfSksXG4gICAgICAgIC8qKlxuICAgICAgICAgICAgICogT3ZlcndyaXRlIHBheWxvYWRcbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiBSZXBsYWNlIGZ1bGwgcGF5bG9hZCBvZiBwb2ludHMgd2l0aCBuZXcgb25lXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgb3ZlcndyaXRlUGF5bG9hZDogY2xpZW50XG4gICAgICAgICAgICAucGF0aCgnL2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uX25hbWV9L3BvaW50cy9wYXlsb2FkJylcbiAgICAgICAgICAgIC5tZXRob2QoJ3B1dCcpXG4gICAgICAgICAgICAuY3JlYXRlKHtcbiAgICAgICAgICAgIHdhaXQ6IHRydWUsXG4gICAgICAgICAgICBvcmRlcmluZzogdHJ1ZSxcbiAgICAgICAgfSksXG4gICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2V0IHBheWxvYWRcbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiBTZXQgcGF5bG9hZCB2YWx1ZXMgZm9yIHBvaW50c1xuICAgICAgICAgICAgICovXG4gICAgICAgIHNldFBheWxvYWQ6IGNsaWVudFxuICAgICAgICAgICAgLnBhdGgoJy9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbl9uYW1lfS9wb2ludHMvcGF5bG9hZCcpXG4gICAgICAgICAgICAubWV0aG9kKCdwb3N0JylcbiAgICAgICAgICAgIC5jcmVhdGUoe1xuICAgICAgICAgICAgd2FpdDogdHJ1ZSxcbiAgICAgICAgICAgIG9yZGVyaW5nOiB0cnVlLFxuICAgICAgICB9KSxcbiAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEZWxldGUgcGF5bG9hZFxuICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIERlbGV0ZSBzcGVjaWZpZWQga2V5IHBheWxvYWQgZm9yIHBvaW50c1xuICAgICAgICAgICAgICovXG4gICAgICAgIGRlbGV0ZVBheWxvYWQ6IGNsaWVudFxuICAgICAgICAgICAgLnBhdGgoJy9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbl9uYW1lfS9wb2ludHMvcGF5bG9hZC9kZWxldGUnKVxuICAgICAgICAgICAgLm1ldGhvZCgncG9zdCcpXG4gICAgICAgICAgICAuY3JlYXRlKHtcbiAgICAgICAgICAgIHdhaXQ6IHRydWUsXG4gICAgICAgICAgICBvcmRlcmluZzogdHJ1ZSxcbiAgICAgICAgfSksXG4gICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ2xlYXIgcGF5bG9hZFxuICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIFJlbW92ZSBhbGwgcGF5bG9hZCBmb3Igc3BlY2lmaWVkIHBvaW50c1xuICAgICAgICAgICAgICovXG4gICAgICAgIGNsZWFyUGF5bG9hZDogY2xpZW50XG4gICAgICAgICAgICAucGF0aCgnL2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uX25hbWV9L3BvaW50cy9wYXlsb2FkL2NsZWFyJylcbiAgICAgICAgICAgIC5tZXRob2QoJ3Bvc3QnKVxuICAgICAgICAgICAgLmNyZWF0ZSh7XG4gICAgICAgICAgICB3YWl0OiB0cnVlLFxuICAgICAgICAgICAgb3JkZXJpbmc6IHRydWUsXG4gICAgICAgIH0pLFxuICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEJhdGNoIHVwZGF0ZSBwb2ludHNcbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiBBcHBseSBhIHNlcmllcyBvZiB1cGRhdGUgb3BlcmF0aW9ucyBmb3IgcG9pbnRzLCB2ZWN0b3JzIGFuZCBwYXlsb2Fkc1xuICAgICAgICAgICAgICovXG4gICAgICAgIGJhdGNoVXBkYXRlOiBjbGllbnRcbiAgICAgICAgICAgIC5wYXRoKCcvY29sbGVjdGlvbnMve2NvbGxlY3Rpb25fbmFtZX0vcG9pbnRzL2JhdGNoJylcbiAgICAgICAgICAgIC5tZXRob2QoJ3Bvc3QnKVxuICAgICAgICAgICAgLmNyZWF0ZSh7XG4gICAgICAgICAgICB3YWl0OiB0cnVlLFxuICAgICAgICAgICAgb3JkZXJpbmc6IHRydWUsXG4gICAgICAgIH0pLFxuICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNjcm9sbCBwb2ludHNcbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiBTY3JvbGwgcmVxdWVzdCAtIHBhZ2luYXRlIG92ZXIgYWxsIHBvaW50cyB3aGljaCBtYXRjaGVzIGdpdmVuIGZpbHRlcmluZyBjb25kaXRpb25cbiAgICAgICAgICAgICAqL1xuICAgICAgICBzY3JvbGxQb2ludHM6IGNsaWVudFxuICAgICAgICAgICAgLnBhdGgoJy9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbl9uYW1lfS9wb2ludHMvc2Nyb2xsJylcbiAgICAgICAgICAgIC5tZXRob2QoJ3Bvc3QnKVxuICAgICAgICAgICAgLmNyZWF0ZSh7XG4gICAgICAgICAgICBjb25zaXN0ZW5jeTogdHJ1ZSxcbiAgICAgICAgICAgIHRpbWVvdXQ6IHRydWUsXG4gICAgICAgIH0pLFxuICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNlYXJjaCBwb2ludHNcbiAgICAgICAgICAgICAqIEBkZXByZWNhdGVkXG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24gUmV0cmlldmUgY2xvc2VzdCBwb2ludHMgYmFzZWQgb24gdmVjdG9yIHNpbWlsYXJpdHkgYW5kIGdpdmVuIGZpbHRlcmluZyBjb25kaXRpb25zXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgc2VhcmNoUG9pbnRzOiBjbGllbnRcbiAgICAgICAgICAgIC5wYXRoKCcvY29sbGVjdGlvbnMve2NvbGxlY3Rpb25fbmFtZX0vcG9pbnRzL3NlYXJjaCcpXG4gICAgICAgICAgICAubWV0aG9kKCdwb3N0JylcbiAgICAgICAgICAgIC5jcmVhdGUoe1xuICAgICAgICAgICAgY29uc2lzdGVuY3k6IHRydWUsXG4gICAgICAgICAgICB0aW1lb3V0OiB0cnVlLFxuICAgICAgICB9KSxcbiAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTZWFyY2ggYmF0Y2ggcG9pbnRzXG4gICAgICAgICAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIFJldHJpZXZlIGJ5IGJhdGNoIHRoZSBjbG9zZXN0IHBvaW50cyBiYXNlZCBvbiB2ZWN0b3Igc2ltaWxhcml0eSBhbmQgZ2l2ZW4gZmlsdGVyaW5nIGNvbmRpdGlvbnNcbiAgICAgICAgICAgICAqL1xuICAgICAgICBzZWFyY2hCYXRjaFBvaW50czogY2xpZW50XG4gICAgICAgICAgICAucGF0aCgnL2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uX25hbWV9L3BvaW50cy9zZWFyY2gvYmF0Y2gnKVxuICAgICAgICAgICAgLm1ldGhvZCgncG9zdCcpXG4gICAgICAgICAgICAuY3JlYXRlKHtcbiAgICAgICAgICAgIGNvbnNpc3RlbmN5OiB0cnVlLFxuICAgICAgICAgICAgdGltZW91dDogdHJ1ZSxcbiAgICAgICAgfSksXG4gICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2VhcmNoIHBvaW50IGdyb3Vwc1xuICAgICAgICAgICAgICogQGRlcHJlY2F0ZWRcbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiBSZXRyaWV2ZSBjbG9zZXN0IHBvaW50cyBiYXNlZCBvbiB2ZWN0b3Igc2ltaWxhcml0eSBhbmQgZ2l2ZW4gZmlsdGVyaW5nIGNvbmRpdGlvbnMsIGdyb3VwZWQgYnkgYSBnaXZlbiBwYXlsb2FkIGZpZWxkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgc2VhcmNoUG9pbnRHcm91cHM6IGNsaWVudFxuICAgICAgICAgICAgLnBhdGgoJy9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbl9uYW1lfS9wb2ludHMvc2VhcmNoL2dyb3VwcycpXG4gICAgICAgICAgICAubWV0aG9kKCdwb3N0JylcbiAgICAgICAgICAgIC5jcmVhdGUoe1xuICAgICAgICAgICAgY29uc2lzdGVuY3k6IHRydWUsXG4gICAgICAgICAgICB0aW1lb3V0OiB0cnVlLFxuICAgICAgICB9KSxcbiAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZWNvbW1lbmQgcG9pbnRzXG4gICAgICAgICAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIExvb2sgZm9yIHRoZSBwb2ludHMgd2hpY2ggYXJlIGNsb3NlciB0byBzdG9yZWQgcG9zaXRpdmUgZXhhbXBsZXMgYW5kIGF0IHRoZSBzYW1lIHRpbWUgZnVydGhlciB0byBuZWdhdGl2ZSBleGFtcGxlcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICByZWNvbW1lbmRQb2ludHM6IGNsaWVudFxuICAgICAgICAgICAgLnBhdGgoJy9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbl9uYW1lfS9wb2ludHMvcmVjb21tZW5kJylcbiAgICAgICAgICAgIC5tZXRob2QoJ3Bvc3QnKVxuICAgICAgICAgICAgLmNyZWF0ZSh7XG4gICAgICAgICAgICBjb25zaXN0ZW5jeTogdHJ1ZSxcbiAgICAgICAgICAgIHRpbWVvdXQ6IHRydWUsXG4gICAgICAgIH0pLFxuICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlY29tbWVuZCBiYXRjaCBwb2ludHNcbiAgICAgICAgICAgICAqIEBkZXByZWNhdGVkXG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24gTG9vayBmb3IgdGhlIHBvaW50cyB3aGljaCBhcmUgY2xvc2VyIHRvIHN0b3JlZCBwb3NpdGl2ZSBleGFtcGxlcyBhbmQgYXQgdGhlIHNhbWUgdGltZSBmdXJ0aGVyIHRvIG5lZ2F0aXZlIGV4YW1wbGVzLlxuICAgICAgICAgICAgICovXG4gICAgICAgIHJlY29tbWVuZEJhdGNoUG9pbnRzOiBjbGllbnRcbiAgICAgICAgICAgIC5wYXRoKCcvY29sbGVjdGlvbnMve2NvbGxlY3Rpb25fbmFtZX0vcG9pbnRzL3JlY29tbWVuZC9iYXRjaCcpXG4gICAgICAgICAgICAubWV0aG9kKCdwb3N0JylcbiAgICAgICAgICAgIC5jcmVhdGUoe1xuICAgICAgICAgICAgY29uc2lzdGVuY3k6IHRydWUsXG4gICAgICAgICAgICB0aW1lb3V0OiB0cnVlLFxuICAgICAgICB9KSxcbiAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZWNvbW1lbmQgcG9pbnQgZ3JvdXBzXG4gICAgICAgICAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIExvb2sgZm9yIHRoZSBwb2ludHMgd2hpY2ggYXJlIGNsb3NlciB0byBzdG9yZWQgcG9zaXRpdmUgZXhhbXBsZXMgYW5kIGF0IHRoZSBzYW1lIHRpbWUgZnVydGhlciB0byBuZWdhdGl2ZSBleGFtcGxlcywgZ3JvdXBlZCBieSBhIGdpdmVuIHBheWxvYWQgZmllbGQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgcmVjb21tZW5kUG9pbnRHcm91cHM6IGNsaWVudFxuICAgICAgICAgICAgLnBhdGgoJy9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbl9uYW1lfS9wb2ludHMvcmVjb21tZW5kL2dyb3VwcycpXG4gICAgICAgICAgICAubWV0aG9kKCdwb3N0JylcbiAgICAgICAgICAgIC5jcmVhdGUoe1xuICAgICAgICAgICAgY29uc2lzdGVuY3k6IHRydWUsXG4gICAgICAgICAgICB0aW1lb3V0OiB0cnVlLFxuICAgICAgICB9KSxcbiAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEaXNjb3ZlciBwb2ludHNcbiAgICAgICAgICAgICAqIEBkZXByZWNhdGVkXG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24gVXNlIGNvbnRleHQgYW5kIGEgdGFyZ2V0IHRvIGZpbmQgdGhlIG1vc3Qgc2ltaWxhciBwb2ludHMgdG8gdGhlIHRhcmdldCwgY29uc3RyYWluZWQgYnkgdGhlIGNvbnRleHQuXG4gICAgICAgICAgICAgKiBXaGVuIHVzaW5nIG9ubHkgdGhlIGNvbnRleHQgKHdpdGhvdXQgYSB0YXJnZXQpLCBhIHNwZWNpYWwgc2VhcmNoIC0gY2FsbGVkIGNvbnRleHQgc2VhcmNoIC0gaXMgcGVyZm9ybWVkIHdoZXJlIHBhaXJzIG9mIHBvaW50cyBhcmUgdXNlZCB0byBnZW5lcmF0ZSBhIGxvc3MgdGhhdCBndWlkZXMgdGhlIHNlYXJjaCB0b3dhcmRzIHRoZSB6b25lIHdoZXJlIG1vc3QgcG9zaXRpdmUgZXhhbXBsZXMgb3ZlcmxhcC4gVGhpcyBtZWFucyB0aGF0IHRoZSBzY29yZSBtaW5pbWl6ZXMgdGhlIHNjZW5hcmlvIG9mIGZpbmRpbmcgYSBwb2ludCBjbG9zZXIgdG8gYSBuZWdhdGl2ZSB0aGFuIHRvIGEgcG9zaXRpdmUgcGFydCBvZiBhIHBhaXIuXG4gICAgICAgICAgICAgKiBTaW5jZSB0aGUgc2NvcmUgb2YgYSBjb250ZXh0IHJlbGF0ZXMgdG8gbG9zcywgdGhlIG1heGltdW0gc2NvcmUgYSBwb2ludCBjYW4gZ2V0IGlzIDAuMCwgYW5kIGl0IGJlY29tZXMgbm9ybWFsIHRoYXQgbWFueSBwb2ludHMgY2FuIGhhdmUgYSBzY29yZSBvZiAwLjAuXG4gICAgICAgICAgICAgKiBXaGVuIHVzaW5nIHRhcmdldCAod2l0aCBvciB3aXRob3V0IGNvbnRleHQpLCB0aGUgc2NvcmUgYmVoYXZlcyBhIGxpdHRsZSBkaWZmZXJlbnQ6IFRoZSAgaW50ZWdlciBwYXJ0IG9mIHRoZSBzY29yZSByZXByZXNlbnRzIHRoZSByYW5rIHdpdGggcmVzcGVjdCB0byB0aGUgY29udGV4dCwgd2hpbGUgdGhlIGRlY2ltYWwgcGFydCBvZiB0aGUgc2NvcmUgcmVsYXRlcyB0byB0aGUgZGlzdGFuY2UgdG8gdGhlIHRhcmdldC4gVGhlIGNvbnRleHQgcGFydCBvZiB0aGUgc2NvcmUgZm9yICBlYWNoIHBhaXIgaXMgY2FsY3VsYXRlZCArMSBpZiB0aGUgcG9pbnQgaXMgY2xvc2VyIHRvIGEgcG9zaXRpdmUgdGhhbiB0byBhIG5lZ2F0aXZlIHBhcnQgb2YgYSBwYWlyLCAgYW5kIC0xIG90aGVyd2lzZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICBkaXNjb3ZlclBvaW50czogY2xpZW50XG4gICAgICAgICAgICAucGF0aCgnL2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uX25hbWV9L3BvaW50cy9kaXNjb3ZlcicpXG4gICAgICAgICAgICAubWV0aG9kKCdwb3N0JylcbiAgICAgICAgICAgIC5jcmVhdGUoe1xuICAgICAgICAgICAgY29uc2lzdGVuY3k6IHRydWUsXG4gICAgICAgICAgICB0aW1lb3V0OiB0cnVlLFxuICAgICAgICB9KSxcbiAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEaXNjb3ZlciBiYXRjaCBwb2ludHNcbiAgICAgICAgICAgICAqIEBkZXByZWNhdGVkXG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24gTG9vayBmb3IgcG9pbnRzIGJhc2VkIG9uIHRhcmdldCBhbmQvb3IgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIGV4YW1wbGUgcGFpcnMsIGluIGJhdGNoLlxuICAgICAgICAgICAgICovXG4gICAgICAgIGRpc2NvdmVyQmF0Y2hQb2ludHM6IGNsaWVudFxuICAgICAgICAgICAgLnBhdGgoJy9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbl9uYW1lfS9wb2ludHMvZGlzY292ZXIvYmF0Y2gnKVxuICAgICAgICAgICAgLm1ldGhvZCgncG9zdCcpXG4gICAgICAgICAgICAuY3JlYXRlKHtcbiAgICAgICAgICAgIGNvbnNpc3RlbmN5OiB0cnVlLFxuICAgICAgICAgICAgdGltZW91dDogdHJ1ZSxcbiAgICAgICAgfSksXG4gICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ291bnQgcG9pbnRzXG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24gQ291bnQgcG9pbnRzIHdoaWNoIG1hdGNoZXMgZ2l2ZW4gZmlsdGVyaW5nIGNvbmRpdGlvblxuICAgICAgICAgICAgICovXG4gICAgICAgIGNvdW50UG9pbnRzOiBjbGllbnRcbiAgICAgICAgICAgIC5wYXRoKCcvY29sbGVjdGlvbnMve2NvbGxlY3Rpb25fbmFtZX0vcG9pbnRzL2NvdW50JylcbiAgICAgICAgICAgIC5tZXRob2QoJ3Bvc3QnKVxuICAgICAgICAgICAgLmNyZWF0ZSh7XG4gICAgICAgICAgICB0aW1lb3V0OiB0cnVlLFxuICAgICAgICB9KSxcbiAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBGYWNldCBhIHBheWxvYWQga2V5IHdpdGggYSBnaXZlbiBmaWx0ZXIuXG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24gQ291bnQgcG9pbnRzIHRoYXQgc2F0aXNmeSB0aGUgZ2l2ZW4gZmlsdGVyIGZvciBlYWNoIHVuaXF1ZSB2YWx1ZSBvZiBhIHBheWxvYWQga2V5LlxuICAgICAgICAgICAgICovXG4gICAgICAgIGZhY2V0OiBjbGllbnRcbiAgICAgICAgICAgIC5wYXRoKCcvY29sbGVjdGlvbnMve2NvbGxlY3Rpb25fbmFtZX0vZmFjZXQnKVxuICAgICAgICAgICAgLm1ldGhvZCgncG9zdCcpXG4gICAgICAgICAgICAuY3JlYXRlKHtcbiAgICAgICAgICAgIHRpbWVvdXQ6IHRydWUsXG4gICAgICAgICAgICBjb25zaXN0ZW5jeTogdHJ1ZSxcbiAgICAgICAgfSksXG4gICAgICAgIC8qKlxuICAgICAgICAgICAgICogUXVlcnkgcG9pbnRzXG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24gVW5pdmVyc2FsbHkgcXVlcnkgcG9pbnRzLiBUaGlzIGVuZHBvaW50IGNvdmVycyBhbGwgY2FwYWJpbGl0aWVzIG9mIHNlYXJjaCwgcmVjb21tZW5kLCBkaXNjb3ZlciwgZmlsdGVycy4gQnV0IGFsc28gZW5hYmxlcyBoeWJyaWQgYW5kIG11bHRpLXN0YWdlIHF1ZXJpZXMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgcXVlcnlQb2ludHM6IGNsaWVudFxuICAgICAgICAgICAgLnBhdGgoJy9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbl9uYW1lfS9wb2ludHMvcXVlcnknKVxuICAgICAgICAgICAgLm1ldGhvZCgncG9zdCcpXG4gICAgICAgICAgICAuY3JlYXRlKHtcbiAgICAgICAgICAgIGNvbnNpc3RlbmN5OiB0cnVlLFxuICAgICAgICAgICAgdGltZW91dDogdHJ1ZSxcbiAgICAgICAgfSksXG4gICAgICAgIC8qKlxuICAgICAgICAgICAgICogUXVlcnkgcG9pbnRzIGluIGJhdGNoXG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24gVW5pdmVyc2FsbHkgcXVlcnkgcG9pbnRzIGluIGJhdGNoLiBUaGlzIGVuZHBvaW50IGNvdmVycyBhbGwgY2FwYWJpbGl0aWVzIG9mIHNlYXJjaCwgcmVjb21tZW5kLCBkaXNjb3ZlciwgZmlsdGVycy4gQnV0IGFsc28gZW5hYmxlcyBoeWJyaWQgYW5kIG11bHRpLXN0YWdlIHF1ZXJpZXMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgcXVlcnlCYXRjaFBvaW50czogY2xpZW50XG4gICAgICAgICAgICAucGF0aCgnL2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uX25hbWV9L3BvaW50cy9xdWVyeS9iYXRjaCcpXG4gICAgICAgICAgICAubWV0aG9kKCdwb3N0JylcbiAgICAgICAgICAgIC5jcmVhdGUoe1xuICAgICAgICAgICAgY29uc2lzdGVuY3k6IHRydWUsXG4gICAgICAgICAgICB0aW1lb3V0OiB0cnVlLFxuICAgICAgICB9KSxcbiAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBRdWVyeSBwb2ludHMsIGdyb3VwZWQgYnkgYSBnaXZlbiBwYXlsb2FkIGZpZWxkXG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24gVW5pdmVyc2FsbHkgcXVlcnkgcG9pbnRzLCBncm91cGVkIGJ5IGEgZ2l2ZW4gcGF5bG9hZCBmaWVsZFxuICAgICAgICAgICAgICovXG4gICAgICAgIHF1ZXJ5UG9pbnRzR3JvdXBzOiBjbGllbnRcbiAgICAgICAgICAgIC5wYXRoKCcvY29sbGVjdGlvbnMve2NvbGxlY3Rpb25fbmFtZX0vcG9pbnRzL3F1ZXJ5L2dyb3VwcycpXG4gICAgICAgICAgICAubWV0aG9kKCdwb3N0JylcbiAgICAgICAgICAgIC5jcmVhdGUoe1xuICAgICAgICAgICAgY29uc2lzdGVuY3k6IHRydWUsXG4gICAgICAgICAgICB0aW1lb3V0OiB0cnVlLFxuICAgICAgICB9KSxcbiAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTZWFyY2ggcG9pbnRzIG1hdHJpeCBkaXN0YW5jZSBwYWlyc1xuICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIENvbXB1dGUgZGlzdGFuY2UgbWF0cml4IGZvciBzYW1wbGVkIHBvaW50cyB3aXRoIGEgcGFpciBiYXNlZCBvdXRwdXQgZm9ybWF0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgc2VhcmNoTWF0cml4UGFpcnM6IGNsaWVudFxuICAgICAgICAgICAgLnBhdGgoJy9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbl9uYW1lfS9wb2ludHMvc2VhcmNoL21hdHJpeC9wYWlycycpXG4gICAgICAgICAgICAubWV0aG9kKCdwb3N0JylcbiAgICAgICAgICAgIC5jcmVhdGUoe1xuICAgICAgICAgICAgY29uc2lzdGVuY3k6IHRydWUsXG4gICAgICAgICAgICB0aW1lb3V0OiB0cnVlLFxuICAgICAgICB9KSxcbiAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTZWFyY2ggcG9pbnRzIG1hdHJpeCBkaXN0YW5jZSBvZmZzZXRzXG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24gQ29tcHV0ZSBkaXN0YW5jZSBtYXRyaXggZm9yIHNhbXBsZWQgcG9pbnRzIHdpdGggYW4gb2Zmc2V0IGJhc2VkIG91dHB1dCBmb3JtYXRcbiAgICAgICAgICAgICAqL1xuICAgICAgICBzZWFyY2hNYXRyaXhPZmZzZXRzOiBjbGllbnRcbiAgICAgICAgICAgIC5wYXRoKCcvY29sbGVjdGlvbnMve2NvbGxlY3Rpb25fbmFtZX0vcG9pbnRzL3NlYXJjaC9tYXRyaXgvb2Zmc2V0cycpXG4gICAgICAgICAgICAubWV0aG9kKCdwb3N0JylcbiAgICAgICAgICAgIC5jcmVhdGUoe1xuICAgICAgICAgICAgY29uc2lzdGVuY3k6IHRydWUsXG4gICAgICAgICAgICB0aW1lb3V0OiB0cnVlLFxuICAgICAgICB9KSxcbiAgICB9O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@qdrant/js-client-rest/dist/esm/openapi/generated_api_client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@qdrant/js-client-rest/dist/esm/qdrant-client.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@qdrant/js-client-rest/dist/esm/qdrant-client.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QdrantClient: () => (/* binding */ QdrantClient)\n/* harmony export */ });\n/* harmony import */ var _sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @sevinf/maybe */ \"(rsc)/./node_modules/@sevinf/maybe/dist/esm/maybe.js\");\n/* harmony import */ var _api_client_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./api-client.js */ \"(rsc)/./node_modules/@qdrant/js-client-rest/dist/esm/api-client.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(rsc)/./node_modules/@qdrant/js-client-rest/dist/esm/errors.js\");\n/* harmony import */ var _client_version_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./client-version.js */ \"(rsc)/./node_modules/@qdrant/js-client-rest/dist/esm/client-version.js\");\n/* eslint-disable @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call */\n\n\n\n\nclass QdrantClient {\n    constructor({ url, host, apiKey, https, prefix, port = 6333, timeout = 300000, checkCompatibility = true, ...args } = {}) {\n        this._https = https ?? typeof apiKey === 'string';\n        this._scheme = this._https ? 'https' : 'http';\n        this._prefix = prefix ?? '';\n        if (this._prefix.length > 0 && !this._prefix.startsWith('/')) {\n            this._prefix = `/${this._prefix}`;\n        }\n        if (url && host) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.QdrantClientConfigError(`Only one of \\`url\\`, \\`host\\` params can be set. Url is ${url}, host is ${host}`);\n        }\n        if (host && (host.startsWith('http://') || host.startsWith('https://') || /:\\d+$/.test(host))) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.QdrantClientConfigError('The `host` param is not expected to contain neither protocol (http:// or https://) nor port (:6333).\\n' +\n                'Try to use the `url` parameter instead.');\n        }\n        else if (url) {\n            if (!(url.startsWith('http://') || url.startsWith('https://'))) {\n                throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.QdrantClientConfigError('The `url` param expected to contain a valid URL starting with a protocol (http:// or https://).');\n            }\n            const parsedUrl = new URL(url);\n            this._host = parsedUrl.hostname;\n            this._port = parsedUrl.port ? Number(parsedUrl.port) : port;\n            this._scheme = parsedUrl.protocol.replace(':', '');\n            if (this._prefix.length > 0 && parsedUrl.pathname !== '/') {\n                throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.QdrantClientConfigError('Prefix can be set either in `url` or in `prefix`.\\n' +\n                    `url is ${url}, prefix is ${parsedUrl.pathname}`);\n            }\n        }\n        else {\n            this._port = port;\n            this._host = host ?? '127.0.0.1';\n        }\n        const headers = new Headers([['user-agent', 'qdrant-js/' + String(_client_version_js__WEBPACK_IMPORTED_MODULE_1__.PACKAGE_VERSION)]]);\n        const metadata = args.headers ?? {};\n        Object.keys(metadata).forEach((field) => {\n            if (metadata[field]) {\n                headers.set(field, String(metadata[field]));\n            }\n        });\n        if (typeof apiKey === 'string') {\n            if (this._scheme === 'http') {\n                console.warn('Api key is used with unsecure connection.');\n            }\n            headers.set('api-key', apiKey);\n        }\n        const address = this._port ? `${this._host}:${this._port}` : this._host;\n        this._restUri = `${this._scheme}://${address}${this._prefix}`;\n        const connections = args.maxConnections;\n        const restArgs = { headers, timeout, connections };\n        this._openApiClient = (0,_api_client_js__WEBPACK_IMPORTED_MODULE_2__.createApis)(this._restUri, restArgs);\n        if (checkCompatibility) {\n            this._openApiClient\n                .root({})\n                .then((response) => {\n                const serverVersion = response.data.version;\n                if (!_client_version_js__WEBPACK_IMPORTED_MODULE_1__.ClientVersion.isCompatible(_client_version_js__WEBPACK_IMPORTED_MODULE_1__.PACKAGE_VERSION, serverVersion)) {\n                    console.warn(`Client version ${_client_version_js__WEBPACK_IMPORTED_MODULE_1__.PACKAGE_VERSION} is incompatible with server version ${serverVersion}. Major versions should match and minor version difference must not exceed 1. Set checkCompatibility=false to skip version check.`);\n                }\n            })\n                .catch(() => {\n                console.warn(`Failed to obtain server version. Unable to check client-server compatibility. Set checkCompatibility=false to skip version check.`);\n            });\n        }\n    }\n    /**\n     * API getter\n     *\n     * @returns An instance of an API, generated from OpenAPI schema.\n     */\n    api() {\n        return this._openApiClient;\n    }\n    /**\n     * Search for points in multiple collections\n     *\n     * @param collectionName Name of the collection\n     * @param {object} args -\n     *     - searches: List of search requests\n     *     - consistency: Read consistency of the search. Defines how many replicas should be queried before returning the result.\n     *         Values:\n     *             number - number of replicas to query, values should present in all queried replicas\n     *             'majority' - query all replicas, but return values present in the majority of replicas\n     *             'quorum' - query the majority of replicas, return values present in all of them\n     *             'all' - query all replicas, and return values present in all replicas\n     *     - timeout: If set, overrides global timeout setting for this request. Unit is seconds.\n     * @returns List of search responses\n     */\n    async searchBatch(collection_name, { searches, consistency, timeout, }) {\n        const response = await this._openApiClient.searchBatchPoints({\n            collection_name,\n            consistency,\n            timeout,\n            searches,\n        });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('Search batch returned empty');\n    }\n    /**\n     * Search for closest vectors in collection taking into account filtering conditions\n     *\n     * @param collection_name Collection to search in\n     * @param {object} args -\n     *      - shard_key: Specify in which shards to look for the points, if not specified - look in all shards\n     *      - vector:\n     *          Search for vectors closest to this.\n     *          Can be either a vector itself, or a named vector, or a tuple of vector name and vector itself\n     *      - filter:\n     *          - Exclude vectors which doesn't fit given conditions.\n     *          - If `None` - search among all vectors\n     *      - params: Additional search params\n     *      - limit: How many results return\n     *      - offset:\n     *          Offset of the first result to return.\n     *          May be used to paginate results.\n     *          Note: large offset values may cause performance issues.\n     *      - with_payload:\n     *          - Specify which stored payload should be attached to the result.\n     *          - If `True` - attach all payload\n     *          - If `False` - do not attach any payload\n     *          - If List of string - include only specified fields\n     *          - If `PayloadSelector` - use explicit rules\n     *      - with_vector:\n     *          - If `True` - Attach stored vector to the search result.\n     *          - If `False` - Do not attach vector.\n     *          - If List of string - include only specified fields\n     *          - Default: `False`\n     *      - score_threshold:\n     *          Define a minimal score threshold for the result.\n     *          If defined, less similar results will not be returned.\n     *          Score of the returned result might be higher or smaller than the threshold depending\n     *          on the Distance function used.\n     *          E.g. for cosine similarity only higher scores will be returned.\n     *      - consistency:\n     *          Read consistency of the search. Defines how many replicas should be queried before returning the result.\n     *          Values:\n     *              - int - number of replicas to query, values should present in all queried replicas\n     *              - 'majority' - query all replicas, but return values present in the majority of replicas\n     *              - 'quorum' - query the majority of replicas, return values present in all of them\n     *              - 'all' - query all replicas, and return values present in all replicas\n     *      - timeout: If set, overrides global timeout setting for this request. Unit is seconds.\n     * @example\n     *     // Search with filter\n     *     client.search(\n     *         \"test_collection\",\n     *         {\n     *             vector: [1.0, 0.1, 0.2, 0.7],\n     *             filter: {\n     *                 must: [\n     *                     {\n     *                         key: 'color',\n     *                         range: {\n     *                             color: 'red'\n     *                         }\n     *                     }\n     *                 ]\n     *             )\n     *         }\n     *     )\n     * @returns List of found close points with similarity scores.\n     */\n    async search(collection_name, { shard_key, vector, limit = 10, offset = 0, filter, params, with_payload = true, with_vector = false, score_threshold, consistency, timeout, }) {\n        const response = await this._openApiClient.searchPoints({\n            collection_name,\n            consistency,\n            timeout,\n            shard_key,\n            vector,\n            limit,\n            offset,\n            filter,\n            params,\n            with_payload,\n            with_vector,\n            score_threshold,\n        });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('Search returned empty');\n    }\n    /**\n     * Perform multiple recommend requests in batch mode\n     * @param collection_name Name of the collection\n     * @param {object} args\n     *     - searches: List of recommend requests\n     *     - consistency:\n     *         Read consistency of the search. Defines how many replicas should be queried before returning the result.\n     *         Values:\n     *             - number - number of replicas to query, values should present in all queried replicas\n     *             - 'majority' - query all replicas, but return values present in the majority of replicas\n     *             - 'quorum' - query the majority of replicas, return values present in all of them\n     *             - 'all' - query all replicas, and return values present in all replicas\n     *     - timeout: If set, overrides global timeout setting for this request. Unit is seconds.\n     * @returns List of recommend responses\n     */\n    async recommendBatch(collection_name, { searches, consistency, timeout, }) {\n        const response = await this._openApiClient.recommendBatchPoints({\n            collection_name,\n            searches,\n            consistency,\n            timeout,\n        });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orElse([]);\n    }\n    /**\n     * @alias recommendBatch\n     */\n    async recommend_batch(collection_name, { searches, consistency, timeout, }) {\n        const response = await this._openApiClient.recommendBatchPoints({\n            collection_name,\n            searches,\n            consistency,\n            timeout,\n        });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orElse([]);\n    }\n    /**\n     * Recommendation request. Provides positive and negative examples of the vectors,\n     * which can be ids of points that are already stored in the collection, raw vectors, or even ids and vectors combined.\n     * Service should look for the points which are closer to positive examples and at the same time further to negative examples.\n     * The concrete way of how to compare negative and positive distances is up to the `strategy` chosen.\n     * @param collection_name Collection to search in\n     * @param {object} args\n     *     - shard_key: Specify in which shards to look for the points, if not specified - look in all shards\n     *     - positive:\n     *         List of stored point IDs, which should be used as reference for similarity search.\n     *         If there is only one ID provided - this request is equivalent to the regular search with vector of that point.\n     *         If there are more than one IDs, Qdrant will attempt to search for similar to all of them.\n     *         Recommendation for multiple vectors is experimental. Its behaviour may change in the future.\n     *     - negative:\n     *         List of stored point IDs, which should be dissimilar to the search result.\n     *         Negative examples is an experimental functionality. Its behaviour may change in the future.\n     *     - strategy:\n     *         How to use positive and negative examples to find the results.\n     *     - query_filter:\n     *         - Exclude vectors which doesn't fit given conditions.\n     *         - If `None` - search among all vectors\n     *     - search_params: Additional search params\n     *     - limit: How many results return\n     *         - Default: `10`\n     *     - offset:\n     *         Offset of the first result to return.\n     *         May be used to paginate results.\n     *         Note: large offset values may cause performance issues.\n     *         - Default: `0`\n     *     - with_payload:\n     *         - Specify which stored payload should be attached to the result.\n     *         - If `True` - attach all payload\n     *         - If `False` - do not attach any payload\n     *         - If List of string - include only specified fields\n     *         - If `PayloadSelector` - use explicit rules\n     *         - Default: `true`\n     *     - with_vector:\n     *         - If `True` - Attach stored vector to the search result.\n     *         - If `False` - Do not attach vector.\n     *         - If List of string - include only specified fields\n     *         - Default: `false`\n     *     - score_threshold:\n     *         Define a minimal score threshold for the result.\n     *         If defined, less similar results will not be returned.\n     *         Score of the returned result might be higher or smaller than the threshold depending\n     *         on the Distance function used.\n     *         E.g. for cosine similarity only higher scores will be returned.\n     *     - using:\n     *         Name of the vectors to use for recommendations.\n     *         If `None` - use default vectors.\n     *     - lookupFrom:\n     *         Defines a location (collection and vector field name), used to lookup vectors for recommendations.\n     *         If `None` - use current collection will be used.\n     *     - consistency:\n     *         Read consistency of the search. Defines how many replicas should be queried before returning the result.\n     *         Values:\n     *         - int - number of replicas to query, values should present in all queried replicas\n     *         - 'majority' - query all replicas, but return values present in the majority of replicas\n     *         - 'quorum' - query the majority of replicas, return values present in all of them\n     *         - 'all' - query all replicas, and return values present in all replicas\n     *     - timeout: If set, overrides global timeout setting for this request. Unit is seconds.\n     * @returns List of recommended points with similarity scores.\n     */\n    async recommend(collection_name, { shard_key, positive, negative, strategy, filter, params, limit = 10, offset = 0, with_payload = true, with_vector = false, score_threshold, using, lookup_from, consistency, timeout, }) {\n        const response = await this._openApiClient.recommendPoints({\n            collection_name,\n            limit,\n            shard_key,\n            positive,\n            negative,\n            strategy,\n            filter,\n            params,\n            offset,\n            with_payload,\n            with_vector,\n            score_threshold,\n            using,\n            lookup_from,\n            consistency,\n            timeout,\n        });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('Recommend points API returned empty');\n    }\n    /**\n     * Scroll over all (matching) points in the collection.\n     * @param collection_name Name of the collection\n     * @param {object} args\n     *     - shard_key: Specify in which shards to look for the points, if not specified - look in all shards\n     *     - filter: If provided - only returns points matching filtering conditions\n     *     - limit: How many points to return\n     *     - offset: If provided - skip points with ids less than given `offset`\n     *     - with_payload:\n     *         - Specify which stored payload should be attached to the result.\n     *         - If `True` - attach all payload\n     *         - If `False` - do not attach any payload\n     *         - If List of string - include only specified fields\n     *         - If `PayloadSelector` - use explicit rules\n     *         - Default: `true`\n     *     - with_vector:\n     *         - If `True` - Attach stored vector to the search result.\n     *         - If `False` - Do not attach vector.\n     *         - If List of string - include only specified fields\n     *         - Default: `false`\n     *     - consistency:\n     *         Read consistency of the search. Defines how many replicas should be queried before returning the result.\n     *         Values:\n     *         - int - number of replicas to query, values should present in all queried replicas\n     *         - 'majority' - query all replicas, but return values present in the majority of replicas\n     *         - 'quorum' - query the majority of replicas, return values present in all of them\n     *         - 'all' - query all replicas, and return values present in all replicas\n     *     - order_by:\n     *         Order the records by a payload field.\n     * @returns\n     *     A pair of (List of points) and (optional offset for the next scroll request).\n     *     If next page offset is `None` - there is no more points in the collection to scroll.\n     */\n    async scroll(collection_name, { shard_key, filter, consistency, timeout, limit = 10, offset, with_payload = true, with_vector = false, order_by, } = {}) {\n        const response = await this._openApiClient.scrollPoints({\n            collection_name,\n            shard_key,\n            limit,\n            offset,\n            filter,\n            with_payload,\n            with_vector,\n            order_by,\n            consistency,\n            timeout,\n        });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('Scroll points API returned empty');\n    }\n    /**\n     * Count points in the collection.\n     * Count points in the collection matching the given filter.\n     * @param collection_name\n     * @param {object} args\n     *     - shard_key: Specify in which shards to look for the points, if not specified - look in all shards\n     *     - filter: filtering conditions\n     *     - exact:\n     *         If `True` - provide the exact count of points matching the filter.\n     *         If `False` - provide the approximate count of points matching the filter. Works faster.\n     *         Default: `true`\n     * @returns Amount of points in the collection matching the filter.\n     */\n    async count(collection_name, { shard_key, filter, exact = true, timeout } = {}) {\n        const response = await this._openApiClient.countPoints({\n            collection_name,\n            shard_key,\n            filter,\n            exact,\n            timeout,\n        });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('Count points returned empty');\n    }\n    /**\n     * Get cluster information for a collection.\n     * @param collection_name\n     * @returns Operation result\n     */\n    async collectionClusterInfo(collection_name) {\n        const response = await this._openApiClient.collectionClusterInfo({ collection_name });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('Collection cluster info returned empty');\n    }\n    /**\n     * Update collection cluster setup\n     * @param collection_name Name of the collection\n     * @param {object} args\n     *     - timeout: If set, overrides global timeout setting for this request. Unit is seconds.\n     *     - operation: Cluster operation to perform. Can be one of:\n     *         - move_shard: Move a shard from one peer to another\n     *         - replicate_shard: Replicate a shard to another peer\n     *         - abort_transfer: Abort an ongoing shard transfer\n     *         - drop_replica: Drop a replica from a peer\n     *         - create_sharding_key: Create a new sharding key\n     *         - drop_sharding_key: Drop an existing sharding key\n     *         - restart_transfer: Restart a failed shard transfer\n     *         - start_resharding: Start resharding operation\n     *         - abort_resharding: Abort an ongoing resharding operation\n     * @returns Operation result\n     */\n    async updateCollectionCluster(collection_name, { timeout, ...operation }) {\n        const response = await this._openApiClient.updateCollectionCluster({\n            collection_name,\n            timeout,\n            ...operation,\n        });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('Update collection cluster returned empty');\n    }\n    /**\n     * Update vectors\n     * @param collection_name\n     * @param {object} args\n     *     - wait: Await for the results to be processed.\n     *         - If `true`, result will be returned only when all changes are applied\n     *         - If `false`, result will be returned immediately after the confirmation of receiving.\n     *         - Default: `true`\n     *     - ordering: Define strategy for ordering of the points. Possible values:\n     *          - 'weak'   - write operations may be reordered, works faster, default\n     *          - 'medium' - write operations go through dynamically selected leader,\n     *                      may be inconsistent for a short period of time in case of leader change\n     *          - 'strong' - Write operations go through the permanent leader,\n     *                      consistent, but may be unavailable if leader is down\n     *     - points: Points with named vectors\n     *     - shard_key: Specify in which shards to look for the points, if not specified - look in all shards\n     * @returns Operation result\n     */\n    async updateVectors(collection_name, { wait = true, ordering, points, shard_key, }) {\n        const response = await this._openApiClient.updateVectors({\n            collection_name,\n            wait,\n            ordering,\n            points,\n            shard_key,\n        });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('Update vectors returned empty');\n    }\n    /**\n     * Delete vectors\n     * @param collection_name\n     * @param {object} args\n     *     - wait: Await for the results to be processed.\n     *         - If `true`, result will be returned only when all changes are applied\n     *         - If `false`, result will be returned immediately after the confirmation of receiving.\n     *         - Default: `true`\n     *     - ordering: Define strategy for ordering of the points. Possible values:\n     *          - 'weak'   - write operations may be reordered, works faster, default\n     *          - 'medium' - write operations go through dynamically selected leader,\n     *                      may be inconsistent for a short period of time in case of leader change\n     *          - 'strong' - Write operations go through the permanent leader,\n     *                      consistent, but may be unavailable if leader is down\n     *     - points: Deletes values from each point in this list\n     *     - filter: Deletes values from points that satisfy this filter condition\n     *     - vector: Vector names\n     *     - shard_key: Specify in which shards to look for the points, if not specified - look in all shards\n     * @returns Operation result\n     */\n    async deleteVectors(collection_name, { wait = true, ordering, points, filter, vector, shard_key, }) {\n        const response = await this._openApiClient.deleteVectors({\n            collection_name,\n            wait,\n            ordering,\n            points,\n            filter,\n            vector,\n            shard_key,\n        });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('Delete vectors returned empty');\n    }\n    /**\n     * Search point groups\n     * @param collection_name\n     * @param {object} args -\n     *     - consistency: Read consistency of the search. Defines how many replicas should be queried before returning the result.\n     *         Values:\n     *             number - number of replicas to query, values should present in all queried replicas\n     *             'majority' - query all replicas, but return values present in the majority of replicas\n     *             'quorum' - query the majority of replicas, return values present in all of them\n     *             'all' - query all replicas, and return values present in all replicas\n     *     - timeout: If set, overrides global timeout setting for this request. Unit is seconds.\n     *     - shard_key: Specify in which shards to look for the points, if not specified - look in all shards\n     *     - vector: query search vector\n     *     - filter: Look only for points which satisfies this conditions\n     *     - params: Additional search params\n     *     - with_payload: Select which payload to return with the response\n     *     - with_vector: Whether to return the point vector with the result?\n     *     - score_threshold: Define a minimal score threshold for the result. If defined, less similar results will not be returned. Score of the returned result might be higher or smaller than the threshold depending on the Distance function used. E.g. for cosine similarity only higher scores will be returned.\n     *     - group_by: Payload field to group by, must be a string or number field. If the field contains more than 1 value, all values will be used for grouping. One point can be in multiple groups.\n     *     - group_size: Maximum amount of points to return per group\n     *     - limit: Maximum amount of groups to return\n     * @returns Operation result\n     */\n    async searchPointGroups(collection_name, { consistency, timeout, shard_key, vector, filter, params, with_payload = null, with_vector = null, score_threshold, group_by, group_size, limit, }) {\n        const response = await this._openApiClient.searchPointGroups({\n            collection_name,\n            consistency,\n            timeout,\n            shard_key,\n            vector,\n            filter,\n            params,\n            with_payload,\n            with_vector,\n            score_threshold,\n            group_by,\n            group_size,\n            limit,\n        });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('Search point groups returned empty');\n    }\n    /**\n     * Recommend point groups\n     * @param collection_name\n     * @param {object} args -\n     *     - consistency: Read consistency of the search. Defines how many replicas should be queried before returning the result.\n     *         Values:\n     *             number - number of replicas to query, values should present in all queried replicas\n     *             'majority' - query all replicas, but return values present in the majority of replicas\n     *             'quorum' - query the majority of replicas, return values present in all of them\n     *             'all' - query all replicas, and return values present in all replicas\n     *     - timeout: If set, overrides global timeout setting for this request. Unit is seconds.\n     *     - shard_key: Specify in which shards to look for the points, if not specified - look in all shards\n     *     - positive: Look for vectors closest to those\n     *     - negative: Try to avoid vectors like this\n     *     - strategy: How to use positive and negative examples to find the results\n     *     - filter: Look only for points which satisfies this conditions\n     *     - params: Additional search params\n     *     - with_payload: Select which payload to return with the response\n     *     - with_vector: Whether to return the point vector with the result?\n     *     - score_threshold: Define a minimal score threshold for the result. If defined, less similar results will not be returned. Score of the returned result might be higher or smaller than the threshold depending on the Distance function used. E.g. for cosine similarity only higher scores will be returned.\n     *     - using: Define which vector to use for recommendation, if not specified - try to use default vector\n     *     - lookup_from: The location used to lookup vectors. If not specified - use current collection. Note: the other collection should have the same vector size as the current collection\n     *     - group_by: Payload field to group by, must be a string or number field. If the field contains more than 1 value, all values will be used for grouping. One point can be in multiple groups.\n     *     - group_size: Maximum amount of points to return per group\n     *     - limit: Maximum amount of groups to return\n     * @returns Operation result\n     */\n    async recommendPointGroups(collection_name, { consistency, timeout, shard_key, positive, strategy, negative = [], filter, params, with_payload = null, with_vector = null, score_threshold, using = null, lookup_from = null, group_by, group_size, limit, }) {\n        const response = await this._openApiClient.recommendPointGroups({\n            collection_name,\n            consistency,\n            timeout,\n            shard_key,\n            positive,\n            negative,\n            strategy,\n            filter,\n            params,\n            with_payload,\n            with_vector,\n            score_threshold,\n            using,\n            lookup_from,\n            group_by,\n            group_size,\n            limit,\n        });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('Recommend point groups API returned empty');\n    }\n    /**\n     * Update or insert a new point into the collection.\n     * @param collection_name\n     * @param {object} args\n     *     - wait: Await for the results to be processed.\n     *         - If `true`, result will be returned only when all changes are applied\n     *         - If `false`, result will be returned immediately after the confirmation of receiving.\n     *         - Default: `true`\n     *     - ordering: Define strategy for ordering of the points. Possible values:\n     *          - 'weak'   - write operations may be reordered, works faster, default\n     *          - 'medium' - write operations go through dynamically selected leader,\n     *                      may be inconsistent for a short period of time in case of leader change\n     *          - 'strong' - Write operations go through the permanent leader,\n     *                      consistent, but may be unavailable if leader is down\n     *     - points: Batch or list of points to insert\n     * @returns Operation result\n     */\n    async upsert(collection_name, { wait = true, ordering, ...points_or_batch }) {\n        const response = await this._openApiClient.upsertPoints({\n            collection_name,\n            wait,\n            ordering,\n            ...points_or_batch,\n        });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('Upsert returned empty');\n    }\n    /**\n     * Retrieve stored points by IDs\n     * @param collection_name\n     * @param {object} args\n     *     - shard_key: Specify in which shards to look for the points, if not specified - look in all shards\n     *     - ids: list of IDs to lookup\n     *     - with_payload:\n     *         - Specify which stored payload should be attached to the result.\n     *         - If `True` - attach all payload\n     *         - If `False` - do not attach any payload\n     *         - If List of string - include only specified fields\n     *         - If `PayloadSelector` - use explicit rules\n     *         - Default: `true`\n     *     - with_vector:\n     *         - If `True` - Attach stored vector to the search result.\n     *         - If `False` - Do not attach vector.\n     *         - If List of string - Attach only specified vectors.\n     *         - Default: `false`\n     *     - consistency:\n     *         Read consistency of the search. Defines how many replicas should be queried before returning the result.\n     *             Values:\n     *                 - number - number of replicas to query, values should present in all queried replicas\n     *                 - 'majority' - query all replicas, but return values present in the majority of replicas\n     *                 - 'quorum' - query the majority of replicas, return values present in all of them\n     *                 - 'all' - query all replicas, and return values present in all replicas\n     * @returns List of points\n     */\n    async retrieve(collection_name, { shard_key, ids, with_payload = true, with_vector, consistency, timeout, }) {\n        const response = await this._openApiClient.getPoints({\n            collection_name,\n            shard_key,\n            ids,\n            with_payload,\n            with_vector,\n            consistency,\n            timeout,\n        });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('Retrieve API returned empty');\n    }\n    /**\n     * Deletes selected points from collection\n     * @param collection_name Name of the collection\n     * @param {object} args\n     *     - wait: Await for the results to be processed.\n     *         - If `true`, result will be returned only when all changes are applied\n     *         - If `false`, result will be returned immediately after the confirmation of receiving.\n     *      - ordering: Define strategy for ordering of the points. Possible values:\n     *          - 'weak'   - write operations may be reordered, works faster, default\n     *          - 'medium' - write operations go through dynamically selected leader,\n     *                      may be inconsistent for a short period of time in case of leader change\n     *          - 'strong' - Write operations go through the permanent leader,\n     *                      consistent, but may be unavailable if leader is down\n     *     - points_selector: List of affected points, filter or points selector.\n     *         Example:\n     *             - `points: [\n     *                   1, 2, 3, \"cd3b53f0-11a7-449f-bc50-d06310e7ed90\"\n     *               ]`\n     *             - `filter: {\n     *                    must: [\n     *                        {\n     *                            key: 'rand_number',\n     *                            range: {\n     *                                gte: 0.7\n     *                            }\n     *                        }\n     *                    ]\n     *                }`\n     * @returns Operation result\n     */\n    async delete(collection_name, { wait, ordering, ...points_selector }) {\n        const response = await this._openApiClient.deletePoints({\n            collection_name,\n            wait,\n            ordering,\n            ...points_selector,\n        });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('Delete points returned empty');\n    }\n    /**\n     * Sets payload values for specified points.\n     * @param collection_name Name of the collection\n     * @param {object} args\n     *     - wait: Await for the results to be processed.\n     *         - If `true`, result will be returned only when all changes are applied\n     *         - If `false`, result will be returned immediately after the confirmation of receiving.\n     *      - ordering: Define strategy for ordering of the points. Possible values:\n     *          - 'weak'   - write operations may be reordered, works faster, default\n     *          - 'medium' - write operations go through dynamically selected leader,\n     *                      may be inconsistent for a short period of time in case of leader change\n     *          - 'strong' - Write operations go through the permanent leader,\n     *                      consistent, but may be unavailable if leader is down\n     *     - payload: Key-value pairs of payload to assign\n     *     - shard_key: Specify in which shards to look for the points, if not specified - look in all shards\n     *     - key: Assigns payload to each point that satisfy this path of property\n     *     - points|filter: List of affected points, filter or points selector.\n     *         Example:\n     *             - `points: [\n     *                   1, 2, 3, \"cd3b53f0-11a7-449f-bc50-d06310e7ed90\"\n     *               ]`\n     *             - `filter: {\n     *                    must: [\n     *                        {\n     *                            key: 'rand_number',\n     *                            range: {\n     *                                gte: 0.7\n     *                            }\n     *                        }\n     *                    ]\n     *                }`\n     * @returns Operation result\n     */\n    async setPayload(collection_name, { payload, points, filter, shard_key, key, ordering, wait = true, }) {\n        const response = await this._openApiClient.setPayload({\n            collection_name,\n            payload,\n            points,\n            filter,\n            shard_key,\n            key,\n            wait,\n            ordering,\n        });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('Set payload returned empty');\n    }\n    /**\n     * Overwrites payload of the specified points\n     * After this operation is applied, only the specified payload will be present in the point.\n     * The existing payload, even if the key is not specified in the payload, will be deleted.\n     * @param collection_name Name of the collection\n     * @param {object} args\n     *     - wait: Await for the results to be processed.\n     *         - If `true`, result will be returned only when all changes are applied\n     *         - If `false`, result will be returned immediately after the confirmation of receiving.\n     *      - ordering: Define strategy for ordering of the points. Possible values:\n     *          - 'weak'   - write operations may be reordered, works faster, default\n     *          - 'medium' - write operations go through dynamically selected leader,\n     *                      may be inconsistent for a short period of time in case of leader change\n     *          - 'strong' - Write operations go through the permanent leader,\n     *                      consistent, but may be unavailable if leader is down\n     *     - payload: Key-value pairs of payload to assign\n     *     - shard_key: Specify in which shards to look for the points, if not specified - look in all shards\n     *     - key: Assigns payload to each point that satisfy this path of property\n     *     - points|filter: List of affected points, filter or points selector.\n     *         Example:\n     *             - `points: [\n     *                   1, 2, 3, \"cd3b53f0-11a7-449f-bc50-d06310e7ed90\"\n     *               ]`\n     *             - `filter: {\n     *                    must: [\n     *                        {\n     *                            key: 'rand_number',\n     *                            range: {\n     *                                gte: 0.7\n     *                            }\n     *                        }\n     *                    ]\n     *                }`\n     * @returns Operation result\n     */\n    async overwritePayload(collection_name, { ordering, payload, points, filter, shard_key, key, wait = true, }) {\n        const response = await this._openApiClient.overwritePayload({\n            collection_name,\n            payload,\n            points,\n            filter,\n            shard_key,\n            key,\n            wait,\n            ordering,\n        });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('Overwrite payload returned empty');\n    }\n    /**\n     * Remove values from point's payload\n     * @param collection_name Name of the collection\n     * @param {object} args\n     *     - wait: Await for the results to be processed.\n     *         - If `true`, result will be returned only when all changes are applied\n     *         - If `false`, result will be returned immediately after the confirmation of receiving.\n     *      - ordering: Define strategy for ordering of the points. Possible values:\n     *          - 'weak'   - write operations may be reordered, works faster, default\n     *          - 'medium' - write operations go through dynamically selected leader,\n     *                      may be inconsistent for a short period of time in case of leader change\n     *          - 'strong' - Write operations go through the permanent leader,\n     *                      consistent, but may be unavailable if leader is down\n     *     - keys: List of payload keys to remove.\n     *     - shard_key: Specify in which shards to look for the points, if not specified - look in all shards\n     *     - points|filter: List of affected points, filter or points selector.\n     *         Example:\n     *             - `points: [\n     *                   1, 2, 3, \"cd3b53f0-11a7-449f-bc50-d06310e7ed90\"\n     *               ]`\n     *             - `filter: {\n     *                    must: [\n     *                        {\n     *                            key: 'rand_number',\n     *                            range: {\n     *                                gte: 0.7\n     *                            }\n     *                        }\n     *                    ]\n     *                }`\n     * @returns Operation result\n     */\n    async deletePayload(collection_name, { ordering, keys, points, filter, shard_key, wait = true, }) {\n        const response = await this._openApiClient.deletePayload({\n            collection_name,\n            keys,\n            points,\n            filter,\n            shard_key,\n            wait,\n            ordering,\n        });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('Delete payload returned empty');\n    }\n    /**\n     * Delete all payload for selected points\n     * @param collection_name Name of the collection\n     * @param {object} args\n     *     - wait: Await for the results to be processed.\n     *         - If `true`, result will be returned only when all changes are applied\n     *         - If `false`, result will be returned immediately after the confirmation of receiving.\n     *      - ordering: Define strategy for ordering of the points. Possible values:\n     *          - 'weak'   - write operations may be reordered, works faster, default\n     *          - 'medium' - write operations go through dynamically selected leader,\n     *                      may be inconsistent for a short period of time in case of leader change\n     *          - 'strong' - Write operations go through the permanent leader,\n     *                      consistent, but may be unavailable if leader is down\n     *     - points_selector: List of affected points, filter or points selector.\n     *         Example:\n     *             - `points: [\n     *                   1, 2, 3, \"cd3b53f0-11a7-449f-bc50-d06310e7ed90\"\n     *               ]`\n     *             - `filter: {\n     *                    must: [\n     *                        {\n     *                            key: 'rand_number',\n     *                            range: {\n     *                                gte: 0.7\n     *                            }\n     *                        }\n     *                    ]\n     *                }`\n     * @returns Operation result\n     */\n    async clearPayload(collection_name, { ordering, wait = true, ...points_selector }) {\n        const response = await this._openApiClient.clearPayload({\n            collection_name,\n            wait,\n            ordering,\n            ...points_selector,\n        });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('Clear payload returned empty');\n    }\n    /**\n     * Operation for performing changes of collection aliases.\n     * Alias changes are atomic, meaning that no collection modifications can happen between alias operations.\n     * @param {object} args\n     *     - actions: List of operations to perform\n     *     - timeout: Wait for operation commit timeout in seconds. If timeout is reached, request will return with service error.\n     * @returns Operation result\n     */\n    async updateCollectionAliases({ actions, timeout }) {\n        const response = await this._openApiClient.updateAliases({ actions, timeout });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('Update aliases returned empty');\n    }\n    /**\n     * Get collection aliases\n     * @param collection_name Name of the collection\n     * @returns Collection aliases\n     */\n    async getCollectionAliases(collection_name) {\n        const response = await this._openApiClient.getCollectionAliases({ collection_name });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('Get collection aliases returned empty');\n    }\n    /**\n     * Get all aliases\n     * @returns All aliases of all collections\n     */\n    async getAliases() {\n        const response = await this._openApiClient.getCollectionsAliases({});\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('Get aliases returned empty');\n    }\n    /**\n     * Get list name of all existing collections\n     * @returns List of the collections\n     */\n    async getCollections() {\n        const response = await this._openApiClient.getCollections({});\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('Get collections returned empty');\n    }\n    /**\n     * Get detailed information about specified existing collection\n     *\n     * @param collection_name Name of the collection\n     * @returns Detailed information about the collection\n     */\n    async getCollection(collection_name) {\n        const response = await this._openApiClient.getCollection({ collection_name });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('Get collection returned empty');\n    }\n    /**\n     * Update parameters of the collection\n     *\n     * @param collection_name Name of the collection\n     * @param {object} args\n     *     - optimizer_config: Override for optimizer configuration\n     *     - collection_params: Override for collection parameters\n     *     - timeout: Wait for operation commit timeout in seconds. If timeout is reached, request will return with service error.\n     * @returns Operation result\n     */\n    async updateCollection(collection_name, args) {\n        const response = await this._openApiClient.updateCollection({\n            collection_name,\n            ...args,\n        });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('Update collection returned empty');\n    }\n    /**\n     * Removes collection and all it's data\n     * @param collection_name Name of the collection to delete\n     * @param {object} args\n     *     - timeout:\n     *         Wait for operation commit timeout in seconds.\n     *         If timeout is reached, request will return with service error.\n     * @returns Operation result\n     */\n    async deleteCollection(collection_name, args) {\n        const response = await this._openApiClient.deleteCollection({ collection_name, ...args });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('Delete collection returned empty');\n    }\n    /**\n     * Create empty collection with given parameters\n     * @returns Operation result\n     * @param collectionName Name of the collection to recreate\n     * @param {object} args\n     *     - vectors_config:\n     *         Configuration of the vector storage. Vector params contains size and distance for the vector storage.\n     *         If dict is passed, service will create a vector storage for each key in the dict.\n     *         If single VectorParams is passed, service will create a single anonymous vector storage.\n     *     - shard_number: Number of shards in collection. Default is 1, minimum is 1.\n     *     - sharding_method: Sharding method Default is Auto - points are distributed across all available shards Custom - points are distributed across shards according to shard key\n     *     - replication_factor:\n     *         Replication factor for collection. Default is 1, minimum is 1.\n     *         Defines how many copies of each shard will be created.\n     *         Have effect only in distributed mode.\n     *     - write_consistency_factor:\n     *         Write consistency factor for collection. Default is 1, minimum is 1.\n     *         Defines how many replicas should apply the operation for us to consider it successful.\n     *         Increasing this number will make the collection more resilient to inconsistencies, but will\n     *         also make it fail if not enough replicas are available.\n     *         Does not have any performance impact.\n     *         Have effect only in distributed mode.\n     *     - on_disk_payload:\n     *         If true - point`s payload will not be stored in memory.\n     *         It will be read from the disk every time it is requested.\n     *         This setting saves RAM by (slightly) increasing the response time.\n     *         Note: those payload values that are involved in filtering and are indexed - remain in RAM.\n     *     - hnsw_config: Params for HNSW index\n     *     - optimizers_config: Params for optimizer\n     *     - wal_config: Params for Write-Ahead-Log\n     *     - quantization_config: Params for quantization, if None - quantization will be disabled\n     *     - init_from: Use data stored in another collection to initialize this collection\n     *     - sparse_vectors: Sparse vector data config\n     *     - strict_mode_config: Strict mode configuration\n     *     - timeout:\n     *         Wait for operation commit timeout in seconds.\n     *         If timeout is reached, request will return with service error.\n     */\n    async createCollection(collection_name, { timeout, vectors, hnsw_config, init_from, on_disk_payload, optimizers_config, quantization_config, replication_factor, shard_number, sharding_method, wal_config, write_consistency_factor, sparse_vectors, strict_mode_config, }) {\n        const response = await this._openApiClient.createCollection({\n            collection_name,\n            timeout,\n            vectors,\n            hnsw_config,\n            init_from,\n            on_disk_payload,\n            optimizers_config,\n            quantization_config,\n            replication_factor,\n            shard_number,\n            sharding_method,\n            wal_config,\n            write_consistency_factor,\n            sparse_vectors,\n            strict_mode_config,\n        });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('Create collection returned empty');\n    }\n    /**\n     * Delete and create empty collection with given parameters\n     * @returns Operation result\n     * @param collectionName Name of the collection to recreate\n     * @param {object} args\n     *     - vectorsConfig:\n     *         Configuration of the vector storage. Vector params contains size and distance for the vector storage.\n     *         If dict is passed, service will create a vector storage for each key in the dict.\n     *         If single VectorParams is passed, service will create a single anonymous vector storage.\n     *     - shardNumber: Number of shards in collection. Default is 1, minimum is 1.\n     *     - sharding_method: Sharding method Default is Auto - points are distributed across all available shards Custom - points are distributed across shards according to shard key\n     *     - replicationFactor:\n     *         Replication factor for collection. Default is 1, minimum is 1.\n     *         Defines how many copies of each shard will be created.\n     *         Have effect only in distributed mode.\n     *     - writeConsistencyFactor:\n     *         Write consistency factor for collection. Default is 1, minimum is 1.\n     *         Defines how many replicas should apply the operation for us to consider it successful.\n     *         Increasing this number will make the collection more resilient to inconsistencies, but will\n     *         also make it fail if not enough replicas are available.\n     *         Does not have any performance impact.\n     *         Have effect only in distributed mode.\n     *     - onDiskPayload:\n     *         If true - point`s payload will not be stored in memory.\n     *         It will be read from the disk every time it is requested.\n     *         This setting saves RAM by (slightly) increasing the response time.\n     *         Note: those payload values that are involved in filtering and are indexed - remain in RAM.\n     *     - hnswConfig: Params for HNSW index\n     *     - optimizersConfig: Params for optimizer\n     *     - walConfig: Params for Write-Ahead-Log\n     *     - quantizationConfig: Params for quantization, if None - quantization will be disabled\n     *     - initFrom: Use data stored in another collection to initialize this collection\n     *     - sparse_vectors: Sparse vector data config\n     *     - strict_mode_config: Strict mode configuration\n     *     - timeout:\n     *         Wait for operation commit timeout in seconds.\n     *         If timeout is reached, request will return with service error.\n     */\n    async recreateCollection(collection_name, { timeout, vectors, hnsw_config, init_from, on_disk_payload, optimizers_config, quantization_config, replication_factor, shard_number, sharding_method, wal_config, write_consistency_factor, sparse_vectors, strict_mode_config, }) {\n        (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(await this._openApiClient.deleteCollection({\n            collection_name,\n            timeout,\n        }))\n            .get('ok')\n            .orThrow('Delete collection returned failed');\n        const response = await this._openApiClient.createCollection({\n            collection_name,\n            timeout,\n            vectors,\n            hnsw_config,\n            init_from,\n            on_disk_payload,\n            optimizers_config,\n            quantization_config,\n            replication_factor,\n            shard_number,\n            sharding_method,\n            wal_config,\n            write_consistency_factor,\n            sparse_vectors,\n            strict_mode_config,\n        });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response).orThrow('Create collection returned empty');\n    }\n    /**\n     * Creates index for a given payload field.\n     * Indexed fields allow to perform filtered search operations faster.\n     * @param collectionName Name of the collection\n     * @param {object} args\n     *     - fieldName: Name of the payload field.\n     *     - fieldSchema: Type of data to index.\n     *     - wait: Await for the results to be processed.\n     *         - If `true`, result will be returned only when all changes are applied\n     *         - If `false`, result will be returned immediately after the confirmation of receiving.\n     *     - ordering:\n     *         Define strategy for ordering of the points. Possible values:\n     *         - 'weak'   - write operations may be reordered, works faster, default\n     *         - 'medium' - write operations go through dynamically selected leader,\n     *                      may be inconsistent for a short period of time in case of leader change\n     *         - 'strong' - Write operations go through the permanent leader,\n     *                      consistent, but may be unavailable if leader is down\n     * @returns Operation Result\n     */\n    async createPayloadIndex(collection_name, { wait, ordering, field_name, field_schema, }) {\n        const response = await this._openApiClient.createFieldIndex({\n            collection_name,\n            field_name,\n            field_schema,\n            wait,\n            ordering,\n        });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('Create field index returned empty');\n    }\n    /**\n     * Removes index for a given payload field.\n     * @param collection_name Name of the collection\n     * @param field_name Name of the payload field\n     * @param {object} args\n     *     - wait: Await for the results to be processed.\n     *         - If `true`, result will be returned only when all changes are applied\n     *         - If `false`, result will be returned immediately after the confirmation of receiving.\n     *     - ordering:\n     *         Define strategy for ordering of the points. Possible values:\n     *         - 'weak'   - write operations may be reordered, works faster, default\n     *         - 'medium' - write operations go through dynamically selected leader,\n     *                      may be inconsistent for a short period of time in case of leader change\n     *         - 'strong' - Write operations go through the permanent leader,\n     *                      consistent, but may be unavailable if leader is down\n     * @returns Operation Result\n     */\n    async deletePayloadIndex(collection_name, field_name, { wait = true, ordering } = {}) {\n        const response = await this._openApiClient.deleteFieldIndex({\n            collection_name,\n            field_name,\n            wait,\n            ordering,\n        });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('Delete field index returned empty');\n    }\n    /**\n     * List all snapshots for a given collection\n     * @param collection_name Name of the collection\n     * @returns List of snapshots\n     */\n    async listSnapshots(collection_name) {\n        const response = await this._openApiClient.listSnapshots({ collection_name });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('List snapshots API returned empty');\n    }\n    /**\n     * Create snapshot for a given collection\n     * @param collection_name Name of the collection\n     * @returns Snapshot description\n     */\n    async createSnapshot(collection_name, args) {\n        const response = await this._openApiClient.createSnapshot({ collection_name, ...args });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orNull();\n    }\n    /**\n     * Delete snapshot for a given collection\n     * @param collection_name Name of the collection\n     * @param snapshot_name Snapshot id\n     * @returns True if snapshot was deleted\n     */\n    async deleteSnapshot(collection_name, snapshot_name, args) {\n        const response = await this._openApiClient.deleteSnapshot({ collection_name, snapshot_name, ...args });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('Delete snapshot API returned empty');\n    }\n    /**\n     * List all snapshots for a whole storage\n     * @returns List of snapshots\n     */\n    async listFullSnapshots() {\n        const response = await this._openApiClient.listFullSnapshots({});\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('List full snapshots API returned empty');\n    }\n    /**\n     * Create snapshot for a whole storage\n     * @returns Snapshot description\n     */\n    async createFullSnapshot(args) {\n        const response = await this._openApiClient.createFullSnapshot(args ?? {});\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('Create full snapshot API returned empty');\n    }\n    /**\n     * Delete snapshot for a whole storage\n     * @param snapshot_name Snapshot name\n     * @returns True if the snapshot was deleted\n     */\n    async deleteFullSnapshot(snapshot_name, args) {\n        const response = await this._openApiClient.deleteFullSnapshot({ snapshot_name, ...args });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('Delete full snapshot API returned empty');\n    }\n    /**\n     * Recover collection from snapshot\n     * @param collection_name Name of the collection\n     * @param {object} args\n     *     - location:\n     *         URL of the snapshot.\n     *         Example:\n     *             - URL `http://localhost:8080/collections/my_collection/snapshots/my_snapshot`\n     *             - Local path `file:///qdrant/snapshots/test_collection-2022-08-04-10-49-10.snapshot`\n     *     - priority:\n     *         Defines source of truth for snapshot recovery\n     *             - `snapshot` means - prefer snapshot data over the current state\n     *             - `replica` means - prefer existing data over the snapshot\n     *         Default: `replica`\n     *     - checksum:\n     *         SHA256 checksum to verify snapshot integrity before recovery\n     * @returns True if the snapshot was recovered\n     */\n    async recoverSnapshot(collection_name, { location, priority, checksum, api_key }) {\n        const response = await this._openApiClient.recoverFromSnapshot({\n            collection_name,\n            location,\n            priority,\n            checksum,\n            api_key,\n        });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('Recover from snapshot API returned empty');\n    }\n    /**\n     * Lock storage for writing\n     */\n    async lockStorage(reason) {\n        const response = await this._openApiClient.postLocks({ write: true, error_message: reason });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('Lock storage returned empty');\n    }\n    /**\n     * Unlock storage for writing.\n     */\n    async unlockStorage() {\n        const response = await this._openApiClient.postLocks({ write: false });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('Post locks returned empty');\n    }\n    /**\n     * Get current locks state.\n     */\n    async getLocks() {\n        const response = await this._openApiClient.getLocks({});\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('Get locks returned empty');\n    }\n    /**\n     * Batch update points\n     * Apply a series of update operations for points, vectors and payloads.\n     * @param collection_name Name of the collection\n     * @param {object} args\n     *     - wait: Await for the results to be processed.\n     *         - If `true`, result will be returned only when all changes are applied\n     *         - If `false`, result will be returned immediately after the confirmation of receiving.\n     *      - ordering: Define strategy for ordering of the points. Possible values:\n     *          - 'weak'   - write operations may be reordered, works faster, default\n     *          - 'medium' - write operations go through dynamically selected leader,\n     *                      may be inconsistent for a short period of time in case of leader change\n     *          - 'strong' - Write operations go through the permanent leader,\n     *                      consistent, but may be unavailable if leader is down\n     *      - operations: List of operations to perform\n     * @returns Operation result\n     */\n    async batchUpdate(collection_name, { wait = true, ordering, ...operations }) {\n        const response = await this._openApiClient.batchUpdate({\n            collection_name,\n            wait,\n            ordering,\n            ...operations,\n        });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('Batch update returned empty');\n    }\n    /**\n     * Recover from a snapshot\n     * @param collection_name Name of the collection\n     * @param shard_id Shard ID\n     * @returns Operation result\n     */\n    async recoverShardFromSnapshot(collection_name, shard_id, { wait = true, ...shard_snapshot_recover }) {\n        const response = await this._openApiClient.recoverShardFromSnapshot({\n            collection_name,\n            shard_id,\n            wait,\n            ...shard_snapshot_recover,\n        });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('Recover shard from snapshot returned empty');\n    }\n    /**\n     * Get list of snapshots for a shard of a collection\n     * @param collection_name Name of the collection\n     * @param shard_id Shard ID\n     * @returns Operation result\n     */\n    async listShardSnapshots(collection_name, shard_id) {\n        const response = await this._openApiClient.listShardSnapshots({\n            collection_name,\n            shard_id,\n        });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('List shard snapshots returned empty');\n    }\n    /**\n     * Create new snapshot of a shard for a collection\n     * @param collection_name Name of the collection\n     * @param shard_id Shard ID\n     * @returns Operation result\n     */\n    async createShardSnapshot(collection_name, shard_id, { wait = true }) {\n        const response = await this._openApiClient.createShardSnapshot({\n            collection_name,\n            shard_id,\n            wait,\n        });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('Create shard snapshot returned empty');\n    }\n    /**\n     * Delete snapshot of a shard for a collection\n     * @param collection_name Name of the collection\n     * @param shard_id Shard ID\n     * @param snapshot_name Snapshot name\n     * @returns Operation result\n     */\n    async deleteShardSnapshot(collection_name, shard_id, snapshot_name, { wait = true }) {\n        const response = await this._openApiClient.deleteShardSnapshot({\n            collection_name,\n            shard_id,\n            snapshot_name,\n            wait,\n        });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('Create shard snapshot returned empty');\n    }\n    /**\n     * Create shard key\n     * @param collection_name Name of the collection\n     * @param {object} args -\n     *     - shard_key: Specify in which shards to look for the points, if not specified - look in all shards\n     *     - shards_number: How many shards to create for this key If not specified, will use the default value from config\n     *     - replication_factor: How many replicas to create for each shard If not specified, will use the default value from config\n     *     - placement: Placement of shards for this key List of peer ids, that can be used to place shards for this key If not specified, will be randomly placed among all peers\n     *     - timeout: If set, overrides global timeout setting for this request. Unit is seconds.\n     * @returns Operation result\n     */\n    async createShardKey(collection_name, { shard_key, shards_number, replication_factor, placement, timeout, }) {\n        const response = await this._openApiClient.createShardKey({\n            collection_name,\n            shard_key,\n            shards_number,\n            replication_factor,\n            placement,\n            timeout,\n        });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('Create shard key returned empty');\n    }\n    /**\n     * Delete shard key\n     * @param collection_name Name of the collection\n     * @param {object} args -\n     *     - shard_key: Specify in which shards to look for the points, if not specified - look in all shards\n     *     - timeout: If set, overrides global timeout setting for this request. Unit is seconds.\n     * @returns Operation result\n     */\n    async deleteShardKey(collection_name, { shard_key, timeout }) {\n        const response = await this._openApiClient.deleteShardKey({\n            collection_name,\n            shard_key,\n            timeout,\n        });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('Create shard key returned empty');\n    }\n    /**\n     * Discover points\n     * @description Use context and a target to find the most similar points to the target, constrained by the context.\n     * When using only the context (without a target), a special search - called context search - is performed where pairs of points are used to generate a loss that guides the search towards the zone where most positive examples overlap. This means that the score minimizes the scenario of finding a point closer to a negative than to a positive part of a pair.\n     * Since the score of a context relates to loss, the maximum score a point can get is 0.0, and it becomes normal that many points can have a score of 0.0.\n     * When using target (with or without context), the score behaves a little different: The  integer part of the score represents the rank with respect to the context, while the decimal part of the score relates to the distance to the target. The context part of the score for  each pair is calculated +1 if the point is closer to a positive than to a negative part of a pair,  and -1 otherwise.\n     * @param collection_name Name of the collection\n     * @param {object} args -\n     *     - consistency: Read consistency of the search. Defines how many replicas should be queried before returning the result.\n     *         Values:\n     *             number - number of replicas to query, values should present in all queried replicas\n     *             'majority' - query all replicas, but return values present in the majority of replicas\n     *             'quorum' - query the majority of replicas, return values present in all of them\n     *             'all' - query all replicas, and return values present in all replicas\n     *     - timeout: If set, overrides global timeout setting for this request. Unit is seconds.\n     *     - shard_key: Specify in which shards to look for the points, if not specified - look in all shards\n     *     - target: Look for vectors closest to this. When using the target (with or without context), the integer part of the score represents the rank with respect to the context, while the decimal part of the score relates to the distance to the target.\n     *     - context: Pairs of { positive, negative } examples to constrain the search. When using only the context (without a target), a special search - called context search - is performed where pairs of points are used to generate a loss that guides the search towards the zone where most positive examples overlap. This means that the score minimizes the scenario of finding a point closer to a negative than to a positive part of a pair. Since the score of a context relates to loss, the maximum score a point can get is 0.0, and it becomes normal that many points can have a score of 0.0. For discovery search (when including a target), the context part of the score for each pair is calculated +1 if the point is closer to a positive than to a negative part of a pair, and -1 otherwise.\n     *     - filter: Look only for points which satisfies this conditions\n     *     - params: Additional search params\n     *     - limit: Max number of result to return\n     *     - offset: Offset of the first result to return. May be used to paginate results. Note: large offset values may cause performance issues.\n     *     - with_payload: Select which payload to return with the response\n     *     - with_vector: Whether to return the point vector with the result?\n     *     - using: Define which vector to use for recommendation, if not specified - try to use default vector\n     *     - lookup_from The location used to lookup vectors. If not specified - use current collection. Note: the other collection should have the same vector size as the current collection\n     * @returns Operation result\n     */\n    async discoverPoints(collection_name, { consistency, timeout, shard_key, target, context, params, limit, offset, with_payload, with_vector, using, lookup_from, }) {\n        const response = await this._openApiClient.discoverPoints({\n            collection_name,\n            consistency,\n            timeout,\n            shard_key,\n            target,\n            context,\n            params,\n            limit,\n            offset,\n            with_payload,\n            with_vector,\n            using,\n            lookup_from,\n        });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('Discover points returned empty');\n    }\n    /**\n     * Discover batch points\n     * @description Look for points based on target and/or positive and negative example pairs, in batch.\n     * @param collection_name Name of the collection\n     * @param {object} args -\n     *     - consistency: Read consistency of the search. Defines how many replicas should be queried before returning the result.\n     *         Values:\n     *             number - number of replicas to query, values should present in all queried replicas\n     *             'majority' - query all replicas, but return values present in the majority of replicas\n     *             'quorum' - query the majority of replicas, return values present in all of them\n     *             'all' - query all replicas, and return values present in all replicas\n     *     - timeout: If set, overrides global timeout setting for this request. Unit is seconds.\n     *     - searches: List of searches\n     * @returns Operation result\n     */\n    async discoverBatchPoints(collection_name, { consistency, timeout, searches, }) {\n        const response = await this._openApiClient.discoverBatchPoints({\n            collection_name,\n            consistency,\n            timeout,\n            searches,\n        });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('Discover batch points returned empty');\n    }\n    /**\n     * Returns information about the running Qdrant instance\n     * @description Returns information about the running Qdrant instance like version and commit id\n     * @returns Operation result\n     */\n    async versionInfo() {\n        const response = await this._openApiClient.root({});\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data).orThrow('Version Info returned empty');\n    }\n    /**\n     * Check the existence of a collection\n     * @param collection_name Name of the collection\n     * @description Returns \"true\" if the given collection name exists, and \"false\" otherwise\n     * @returns Operation result\n     */\n    async collectionExists(collection_name) {\n        const response = await this._openApiClient.collectionExists({ collection_name });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('Collection exists returned empty');\n    }\n    /**\n     * Query points\n     * @description Universally query points. This endpoint covers all capabilities of search, recommend, discover, filters. But also enables hybrid and multi-stage queries.\n     * @param collection_name Name of the collection\n     * @param {object} args -\n     *     - consistency: Read consistency of the search. Defines how many replicas should be queried before returning the result.\n     *         Values:\n     *             number - number of replicas to query, values should present in all queried replicas\n     *             'majority' - query all replicas, but return values present in the majority of replicas\n     *             'quorum' - query the majority of replicas, return values present in all of them\n     *             'all' - query all replicas, and return values present in all replicas\n     *     - timeout: If set, overrides global timeout setting for this request. Unit is seconds.\n     *     - shard_key: Specify in which shards to look for the points, if not specified - look in all shards.\n     *     - prefetch: Sub-requests to perform first. If present, the query will be performed on the results of the prefetch(es).\n     *     - query: Query to perform. If missing without prefetches, returns points ordered by their IDs.\n     *     - using: Define which vector name to use for querying. If missing, the default vector is used.\n     *     - filter: Filter conditions - return only those points that satisfy the specified conditions.\n     *     - params: Search params for when there is no prefetch\n     *     - score_threshold: Return points with scores better than this threshold.\n     *     - limit: Max number of points to return. Default is 10.\n     *     - offset: Offset of the result. Skip this many points. Default is 0\n     *     - with_vector: Options for specifying which vectors to include into the response. Default is false.\n     *     - with_payload: Options for specifying which payload to include or not. Default is false.\n     *     - lookup_from: The location to use for IDs lookup, if not specified - use the current collection and the 'using' vector Note: the other collection vectors should have the same vector size as the 'using' vector in the current collection.\n     * @returns Operation result\n     */\n    async query(collection_name, { consistency, timeout, shard_key, prefetch, query, using, filter, params, score_threshold, limit, offset, with_vector, with_payload, lookup_from, }) {\n        const response = await this._openApiClient.queryPoints({\n            collection_name,\n            consistency,\n            timeout,\n            shard_key,\n            prefetch,\n            query,\n            using,\n            filter,\n            params,\n            score_threshold,\n            limit,\n            offset,\n            with_vector,\n            with_payload,\n            lookup_from,\n        });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('Query points returned empty');\n    }\n    /**\n     * Query points in batch\n     * @description Universally query points in batch. This endpoint covers all capabilities of search, recommend, discover, filters. But also enables hybrid and multi-stage queries.\n     * @param collection_name Name of the collection\n     * @param {object} args -\n     *     - consistency: Read consistency of the search. Defines how many replicas should be queried before returning the result.\n     *         Values:\n     *             number - number of replicas to query, values should present in all queried replicas\n     *             'majority' - query all replicas, but return values present in the majority of replicas\n     *             'quorum' - query the majority of replicas, return values present in all of them\n     *             'all' - query all replicas, and return values present in all replicas\n     *     - timeout: If set, overrides global timeout setting for this request. Unit is seconds.\n     *     - searches: List of queries\n     * @returns Operation result\n     */\n    async queryBatch(collection_name, { consistency, timeout, searches, }) {\n        const response = await this._openApiClient.queryBatchPoints({\n            collection_name,\n            consistency,\n            timeout,\n            searches,\n        });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('Query points returned empty');\n    }\n    /**\n     * Query points, grouped by a given payload field\n     * @description Universally query points, grouped by a given payload field\n     * @param collection_name Name of the collection\n     * @param {object} args -\n     *     - consistency: Read consistency of the search. Defines how many replicas should be queried before returning the result.\n     *         Values:\n     *             number - number of replicas to query, values should present in all queried replicas\n     *             'majority' - query all replicas, but return values present in the majority of replicas\n     *             'quorum' - query the majority of replicas, return values present in all of them\n     *             'all' - query all replicas, and return values present in all replicas\n     *     - timeout: If set, overrides global timeout setting for this request. Unit is seconds.\n     *     - shard_key: Specify in which shards to look for the points, if not specified - look in all shards.\n     *     - prefetch: Sub-requests to perform first. If present, the query will be performed on the results of the prefetch(es).\n     *     - query: Query to perform. If missing without prefetches, returns points ordered by their IDs.\n     *     - using: Define which vector name to use for querying. If missing, the default vector is used.\n     *     - filter: Filter conditions - return only those points that satisfy the specified conditions.\n     *     - params: Search params for when there is no prefetch\n     *     - score_threshold: Return points with scores better than this threshold.\n     *     - with_vector: Options for specifying which vectors to include into the response. Default is false.\n     *     - with_payload: Options for specifying which payload to include or not. Default is false.\n     *     - group_by: Payload field to group by, must be a string or number field. If the field contains more than 1 value, all values will be used for grouping. One point can be in multiple groups.\n     *     - group_size: Maximum amount of points to return per group. Default is 3.\n     *     - limit: Maximum amount of groups to return. Default is 10.\n     *     - with_lookup: Look for points in another collection using the group ids.\n     * @returns Operation result\n     */\n    async queryGroups(collection_name, { consistency, timeout, shard_key, prefetch, query, using, filter, params, score_threshold, with_vector, with_payload, group_by, group_size, limit, with_lookup, }) {\n        const response = await this._openApiClient.queryPointsGroups({\n            collection_name,\n            consistency,\n            timeout,\n            shard_key,\n            prefetch,\n            query,\n            using,\n            filter,\n            params,\n            score_threshold,\n            with_vector,\n            with_payload,\n            group_by,\n            group_size,\n            limit,\n            with_lookup,\n        });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('Query groups returned empty');\n    }\n    /**\n     * Facet a payload key with a given filter.\n     * @description Count points that satisfy the given filter for each unique value of a payload key.\n     * @param collection_name Name of the collection\n     * @param {object} args -\n     *     - consistency: Read consistency of the search. Defines how many replicas should be queried before returning the result.\n     *         Values:\n     *             number - number of replicas to query, values should present in all queried replicas\n     *             'majority' - query all replicas, but return values present in the majority of replicas\n     *             'quorum' - query the majority of replicas, return values present in all of them\n     *             'all' - query all replicas, and return values present in all replicas\n     *     - timeout: If set, overrides global timeout setting for this request. Unit is seconds.\n     *     - shard_key: Specify in which shards to look for the points, if not specified - look in all shards.\n     *     - key: Payload key to use for faceting.\n     *     - limit: Max number of hits to return. Default is 10.\n     *     - filter: Filter conditions - only consider points that satisfy these conditions.\n     *     - exact: Whether to do a more expensive exact count for each of the values in the facet. Default is false.\n     * @returns Operation result\n     */\n    async facet(collection_name, { consistency, timeout, shard_key, key, limit, filter, exact, }) {\n        const response = await this._openApiClient.facet({\n            collection_name,\n            consistency,\n            timeout,\n            shard_key,\n            key,\n            limit,\n            filter,\n            exact,\n        });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('Facet returned empty');\n    }\n    /**\n     * Search points matrix distance pairs.\n     * @description Compute distance matrix for sampled points with a pair based output format.\n     * @param collection_name Name of the collection\n     * @param {object} args -\n     *     - consistency: Read consistency of the search. Defines how many replicas should be queried before returning the result.\n     *         Values:\n     *             number - number of replicas to query, values should present in all queried replicas\n     *             'majority' - query all replicas, but return values present in the majority of replicas\n     *             'quorum' - query the majority of replicas, return values present in all of them\n     *             'all' - query all replicas, and return values present in all replicas\n     *     - timeout: If set, overrides global timeout setting for this request. Unit is seconds.\n     *     - shard_key: Specify in which shards to look for the points, if not specified - look in all shards.\n     *     - filter: Look only for points which satisfies this conditions.\n     *     - sample: How many points to select and search within. Default is 10.\n     *     - limit: How many neighbours per sample to find. Default is 3.\n     *     - using: Define which vector name to use for querying. If missing, the default vector is used.\n     * @returns Operation result\n     */\n    async searchMatrixPairs(collection_name, { consistency, timeout, shard_key, filter, sample, limit, using, }) {\n        const response = await this._openApiClient.searchMatrixPairs({\n            collection_name,\n            consistency,\n            timeout,\n            shard_key,\n            filter,\n            sample,\n            limit,\n            using,\n        });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('Search points matrix pairs returned empty');\n    }\n    /**\n     * Search points matrix distance offsets.\n     * @description Compute distance matrix for sampled points with an offset based output format.\n     * @param collection_name Name of the collection\n     * @param {object} args -\n     *     - consistency: Read consistency of the search. Defines how many replicas should be queried before returning the result.\n     *         Values:\n     *             number - number of replicas to query, values should present in all queried replicas\n     *             'majority' - query all replicas, but return values present in the majority of replicas\n     *             'quorum' - query the majority of replicas, return values present in all of them\n     *             'all' - query all replicas, and return values present in all replicas\n     *     - timeout: If set, overrides global timeout setting for this request. Unit is seconds.\n     *     - shard_key: Specify in which shards to look for the points, if not specified - look in all shards.\n     *     - filter: Look only for points which satisfies this conditions.\n     *     - sample: How many points to select and search within. Default is 10.\n     *     - limit: How many neighbours per sample to find. Default is 3.\n     *     - using: Define which vector name to use for querying. If missing, the default vector is used.\n     * @returns Operation result\n     */\n    async searchMatrixOffsets(collection_name, { consistency, timeout, shard_key, filter, sample, limit, using, }) {\n        const response = await this._openApiClient.searchMatrixOffsets({\n            collection_name,\n            consistency,\n            timeout,\n            shard_key,\n            filter,\n            sample,\n            limit,\n            using,\n        });\n        return (0,_sevinf_maybe__WEBPACK_IMPORTED_MODULE_3__.maybe)(response.data.result).orThrow('Search points matrix offsets returned empty');\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHFkcmFudC9qcy1jbGllbnQtcmVzdC9kaXN0L2VzbS9xZHJhbnQtY2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDc0M7QUFDTztBQUNTO0FBQ2U7QUFDOUQ7QUFDUCxrQkFBa0Isc0dBQXNHLElBQUk7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsYUFBYTtBQUM1QztBQUNBO0FBQ0Esc0JBQXNCLCtEQUF1Qiw0REFBNEQsSUFBSSxZQUFZLEtBQUs7QUFDOUg7QUFDQTtBQUNBLHNCQUFzQiwrREFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsK0RBQXVCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwrREFBdUI7QUFDakQsOEJBQThCLElBQUksY0FBYyxtQkFBbUI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLCtEQUFlO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFdBQVcsR0FBRyxXQUFXO0FBQ2pFLDJCQUEyQixhQUFhLEtBQUssUUFBUSxFQUFFLGFBQWE7QUFDcEU7QUFDQSwyQkFBMkI7QUFDM0IsOEJBQThCLDBEQUFVO0FBQ3hDO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLHFCQUFxQiw2REFBYSxjQUFjLCtEQUFlO0FBQy9ELG1EQUFtRCwrREFBZSxFQUFFLHNDQUFzQyxjQUFjO0FBQ3hIO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxpQ0FBaUM7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxlQUFlLG9EQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsNklBQTZJO0FBQ2pMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGVBQWUsb0RBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxpQ0FBaUM7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxlQUFlLG9EQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGlDQUFpQztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGVBQWUsb0RBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx1TEFBdUw7QUFDOU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxlQUFlLG9EQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsbUhBQW1ILElBQUk7QUFDM0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxlQUFlLG9EQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywyQ0FBMkMsSUFBSTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZUFBZSxvREFBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxpQkFBaUI7QUFDNUYsZUFBZSxvREFBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCx1QkFBdUI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZUFBZSxvREFBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDJDQUEyQztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZUFBZSxvREFBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywyREFBMkQ7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxlQUFlLG9EQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGlKQUFpSjtBQUNoTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGVBQWUsb0RBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCw4TUFBOE07QUFDaFE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGVBQWUsb0RBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsMkNBQTJDO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZUFBZSxvREFBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHlFQUF5RTtBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGVBQWUsb0RBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0Esb0NBQW9DLG9DQUFvQztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGVBQWUsb0RBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0Esd0NBQXdDLGlFQUFpRTtBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZUFBZSxvREFBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsOENBQThDLGlFQUFpRTtBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZUFBZSxvREFBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsMkNBQTJDLHlEQUF5RDtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGVBQWUsb0RBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsMENBQTBDLDJDQUEyQztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGVBQWUsb0RBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msa0JBQWtCO0FBQ3RELG1FQUFtRSxrQkFBa0I7QUFDckYsZUFBZSxvREFBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxpQkFBaUI7QUFDM0YsZUFBZSxvREFBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0UsZUFBZSxvREFBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEUsZUFBZSxvREFBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGlCQUFpQjtBQUNwRixlQUFlLG9EQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGVBQWUsb0RBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLDBCQUEwQjtBQUNoRyxlQUFlLG9EQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGlPQUFpTztBQUMvUTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxlQUFlLG9EQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGlPQUFpTztBQUNqUixRQUFRLG9EQUFLO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZUFBZSxvREFBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsMkNBQTJDO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxlQUFlLG9EQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELHdCQUF3QixJQUFJO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZUFBZSxvREFBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxpQkFBaUI7QUFDcEYsZUFBZSxvREFBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSwwQkFBMEI7QUFDOUYsZUFBZSxvREFBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLHlDQUF5QztBQUM3RyxlQUFlLG9EQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RSxlQUFlLG9EQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRixlQUFlLG9EQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLHdCQUF3QjtBQUNoRyxlQUFlLG9EQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsdUNBQXVDO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxlQUFlLG9EQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Qsb0NBQW9DO0FBQ25HLGVBQWUsb0RBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxjQUFjO0FBQzdFLGVBQWUsb0RBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RCxlQUFlLG9EQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHNDQUFzQztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGVBQWUsb0RBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0Usd0NBQXdDO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZUFBZSxvREFBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGVBQWUsb0RBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsYUFBYTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxlQUFlLG9EQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsYUFBYTtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGVBQWUsb0RBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsbUVBQW1FO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGVBQWUsb0RBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsb0JBQW9CO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGVBQWUsb0RBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMscUJBQXFCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHlIQUF5SDtBQUNySztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGVBQWUsb0RBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxpQ0FBaUM7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxlQUFlLG9EQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFELGVBQWUsb0RBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxpQkFBaUI7QUFDdkYsZUFBZSxvREFBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxrSkFBa0o7QUFDckw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZUFBZSxvREFBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGlDQUFpQztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGVBQWUsb0RBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxnS0FBZ0s7QUFDek07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxlQUFlLG9EQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyw2REFBNkQ7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGVBQWUsb0RBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGdFQUFnRTtBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZUFBZSxvREFBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsZ0VBQWdFO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxlQUFlLG9EQUFLO0FBQ3BCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC1zYWdlLWJvdC8uL25vZGVfbW9kdWxlcy9AcWRyYW50L2pzLWNsaWVudC1yZXN0L2Rpc3QvZXNtL3FkcmFudC1jbGllbnQuanM/MzE3NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVybiwgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWNhbGwgKi9cbmltcG9ydCB7IG1heWJlIH0gZnJvbSAnQHNldmluZi9tYXliZSc7XG5pbXBvcnQgeyBjcmVhdGVBcGlzIH0gZnJvbSAnLi9hcGktY2xpZW50LmpzJztcbmltcG9ydCB7IFFkcmFudENsaWVudENvbmZpZ0Vycm9yIH0gZnJvbSAnLi9lcnJvcnMuanMnO1xuaW1wb3J0IHsgUEFDS0FHRV9WRVJTSU9OLCBDbGllbnRWZXJzaW9uIH0gZnJvbSAnLi9jbGllbnQtdmVyc2lvbi5qcyc7XG5leHBvcnQgY2xhc3MgUWRyYW50Q2xpZW50IHtcbiAgICBjb25zdHJ1Y3Rvcih7IHVybCwgaG9zdCwgYXBpS2V5LCBodHRwcywgcHJlZml4LCBwb3J0ID0gNjMzMywgdGltZW91dCA9IDMwMDAwMCwgY2hlY2tDb21wYXRpYmlsaXR5ID0gdHJ1ZSwgLi4uYXJncyB9ID0ge30pIHtcbiAgICAgICAgdGhpcy5faHR0cHMgPSBodHRwcyA/PyB0eXBlb2YgYXBpS2V5ID09PSAnc3RyaW5nJztcbiAgICAgICAgdGhpcy5fc2NoZW1lID0gdGhpcy5faHR0cHMgPyAnaHR0cHMnIDogJ2h0dHAnO1xuICAgICAgICB0aGlzLl9wcmVmaXggPSBwcmVmaXggPz8gJyc7XG4gICAgICAgIGlmICh0aGlzLl9wcmVmaXgubGVuZ3RoID4gMCAmJiAhdGhpcy5fcHJlZml4LnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgICAgICAgdGhpcy5fcHJlZml4ID0gYC8ke3RoaXMuX3ByZWZpeH1gO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cmwgJiYgaG9zdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFFkcmFudENsaWVudENvbmZpZ0Vycm9yKGBPbmx5IG9uZSBvZiBcXGB1cmxcXGAsIFxcYGhvc3RcXGAgcGFyYW1zIGNhbiBiZSBzZXQuIFVybCBpcyAke3VybH0sIGhvc3QgaXMgJHtob3N0fWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChob3N0ICYmIChob3N0LnN0YXJ0c1dpdGgoJ2h0dHA6Ly8nKSB8fCBob3N0LnN0YXJ0c1dpdGgoJ2h0dHBzOi8vJykgfHwgLzpcXGQrJC8udGVzdChob3N0KSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBRZHJhbnRDbGllbnRDb25maWdFcnJvcignVGhlIGBob3N0YCBwYXJhbSBpcyBub3QgZXhwZWN0ZWQgdG8gY29udGFpbiBuZWl0aGVyIHByb3RvY29sIChodHRwOi8vIG9yIGh0dHBzOi8vKSBub3IgcG9ydCAoOjYzMzMpLlxcbicgK1xuICAgICAgICAgICAgICAgICdUcnkgdG8gdXNlIHRoZSBgdXJsYCBwYXJhbWV0ZXIgaW5zdGVhZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh1cmwpIHtcbiAgICAgICAgICAgIGlmICghKHVybC5zdGFydHNXaXRoKCdodHRwOi8vJykgfHwgdXJsLnN0YXJ0c1dpdGgoJ2h0dHBzOi8vJykpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFFkcmFudENsaWVudENvbmZpZ0Vycm9yKCdUaGUgYHVybGAgcGFyYW0gZXhwZWN0ZWQgdG8gY29udGFpbiBhIHZhbGlkIFVSTCBzdGFydGluZyB3aXRoIGEgcHJvdG9jb2wgKGh0dHA6Ly8gb3IgaHR0cHM6Ly8pLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGFyc2VkVXJsID0gbmV3IFVSTCh1cmwpO1xuICAgICAgICAgICAgdGhpcy5faG9zdCA9IHBhcnNlZFVybC5ob3N0bmFtZTtcbiAgICAgICAgICAgIHRoaXMuX3BvcnQgPSBwYXJzZWRVcmwucG9ydCA/IE51bWJlcihwYXJzZWRVcmwucG9ydCkgOiBwb3J0O1xuICAgICAgICAgICAgdGhpcy5fc2NoZW1lID0gcGFyc2VkVXJsLnByb3RvY29sLnJlcGxhY2UoJzonLCAnJyk7XG4gICAgICAgICAgICBpZiAodGhpcy5fcHJlZml4Lmxlbmd0aCA+IDAgJiYgcGFyc2VkVXJsLnBhdGhuYW1lICE9PSAnLycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUWRyYW50Q2xpZW50Q29uZmlnRXJyb3IoJ1ByZWZpeCBjYW4gYmUgc2V0IGVpdGhlciBpbiBgdXJsYCBvciBpbiBgcHJlZml4YC5cXG4nICtcbiAgICAgICAgICAgICAgICAgICAgYHVybCBpcyAke3VybH0sIHByZWZpeCBpcyAke3BhcnNlZFVybC5wYXRobmFtZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3BvcnQgPSBwb3J0O1xuICAgICAgICAgICAgdGhpcy5faG9zdCA9IGhvc3QgPz8gJzEyNy4wLjAuMSc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKFtbJ3VzZXItYWdlbnQnLCAncWRyYW50LWpzLycgKyBTdHJpbmcoUEFDS0FHRV9WRVJTSU9OKV1dKTtcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBhcmdzLmhlYWRlcnMgPz8ge307XG4gICAgICAgIE9iamVjdC5rZXlzKG1ldGFkYXRhKS5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgICAgICAgICAgaWYgKG1ldGFkYXRhW2ZpZWxkXSkge1xuICAgICAgICAgICAgICAgIGhlYWRlcnMuc2V0KGZpZWxkLCBTdHJpbmcobWV0YWRhdGFbZmllbGRdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHlwZW9mIGFwaUtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zY2hlbWUgPT09ICdodHRwJykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignQXBpIGtleSBpcyB1c2VkIHdpdGggdW5zZWN1cmUgY29ubmVjdGlvbi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhlYWRlcnMuc2V0KCdhcGkta2V5JywgYXBpS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhZGRyZXNzID0gdGhpcy5fcG9ydCA/IGAke3RoaXMuX2hvc3R9OiR7dGhpcy5fcG9ydH1gIDogdGhpcy5faG9zdDtcbiAgICAgICAgdGhpcy5fcmVzdFVyaSA9IGAke3RoaXMuX3NjaGVtZX06Ly8ke2FkZHJlc3N9JHt0aGlzLl9wcmVmaXh9YDtcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbnMgPSBhcmdzLm1heENvbm5lY3Rpb25zO1xuICAgICAgICBjb25zdCByZXN0QXJncyA9IHsgaGVhZGVycywgdGltZW91dCwgY29ubmVjdGlvbnMgfTtcbiAgICAgICAgdGhpcy5fb3BlbkFwaUNsaWVudCA9IGNyZWF0ZUFwaXModGhpcy5fcmVzdFVyaSwgcmVzdEFyZ3MpO1xuICAgICAgICBpZiAoY2hlY2tDb21wYXRpYmlsaXR5KSB7XG4gICAgICAgICAgICB0aGlzLl9vcGVuQXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJvb3Qoe30pXG4gICAgICAgICAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VydmVyVmVyc2lvbiA9IHJlc3BvbnNlLmRhdGEudmVyc2lvbjtcbiAgICAgICAgICAgICAgICBpZiAoIUNsaWVudFZlcnNpb24uaXNDb21wYXRpYmxlKFBBQ0tBR0VfVkVSU0lPTiwgc2VydmVyVmVyc2lvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBDbGllbnQgdmVyc2lvbiAke1BBQ0tBR0VfVkVSU0lPTn0gaXMgaW5jb21wYXRpYmxlIHdpdGggc2VydmVyIHZlcnNpb24gJHtzZXJ2ZXJWZXJzaW9ufS4gTWFqb3IgdmVyc2lvbnMgc2hvdWxkIG1hdGNoIGFuZCBtaW5vciB2ZXJzaW9uIGRpZmZlcmVuY2UgbXVzdCBub3QgZXhjZWVkIDEuIFNldCBjaGVja0NvbXBhdGliaWxpdHk9ZmFsc2UgdG8gc2tpcCB2ZXJzaW9uIGNoZWNrLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byBvYnRhaW4gc2VydmVyIHZlcnNpb24uIFVuYWJsZSB0byBjaGVjayBjbGllbnQtc2VydmVyIGNvbXBhdGliaWxpdHkuIFNldCBjaGVja0NvbXBhdGliaWxpdHk9ZmFsc2UgdG8gc2tpcCB2ZXJzaW9uIGNoZWNrLmApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQVBJIGdldHRlclxuICAgICAqXG4gICAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgYW4gQVBJLCBnZW5lcmF0ZWQgZnJvbSBPcGVuQVBJIHNjaGVtYS5cbiAgICAgKi9cbiAgICBhcGkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcGVuQXBpQ2xpZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWFyY2ggZm9yIHBvaW50cyBpbiBtdWx0aXBsZSBjb2xsZWN0aW9uc1xuICAgICAqXG4gICAgICogQHBhcmFtIGNvbGxlY3Rpb25OYW1lIE5hbWUgb2YgdGhlIGNvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gYXJncyAtXG4gICAgICogICAgIC0gc2VhcmNoZXM6IExpc3Qgb2Ygc2VhcmNoIHJlcXVlc3RzXG4gICAgICogICAgIC0gY29uc2lzdGVuY3k6IFJlYWQgY29uc2lzdGVuY3kgb2YgdGhlIHNlYXJjaC4gRGVmaW5lcyBob3cgbWFueSByZXBsaWNhcyBzaG91bGQgYmUgcXVlcmllZCBiZWZvcmUgcmV0dXJuaW5nIHRoZSByZXN1bHQuXG4gICAgICogICAgICAgICBWYWx1ZXM6XG4gICAgICogICAgICAgICAgICAgbnVtYmVyIC0gbnVtYmVyIG9mIHJlcGxpY2FzIHRvIHF1ZXJ5LCB2YWx1ZXMgc2hvdWxkIHByZXNlbnQgaW4gYWxsIHF1ZXJpZWQgcmVwbGljYXNcbiAgICAgKiAgICAgICAgICAgICAnbWFqb3JpdHknIC0gcXVlcnkgYWxsIHJlcGxpY2FzLCBidXQgcmV0dXJuIHZhbHVlcyBwcmVzZW50IGluIHRoZSBtYWpvcml0eSBvZiByZXBsaWNhc1xuICAgICAqICAgICAgICAgICAgICdxdW9ydW0nIC0gcXVlcnkgdGhlIG1ham9yaXR5IG9mIHJlcGxpY2FzLCByZXR1cm4gdmFsdWVzIHByZXNlbnQgaW4gYWxsIG9mIHRoZW1cbiAgICAgKiAgICAgICAgICAgICAnYWxsJyAtIHF1ZXJ5IGFsbCByZXBsaWNhcywgYW5kIHJldHVybiB2YWx1ZXMgcHJlc2VudCBpbiBhbGwgcmVwbGljYXNcbiAgICAgKiAgICAgLSB0aW1lb3V0OiBJZiBzZXQsIG92ZXJyaWRlcyBnbG9iYWwgdGltZW91dCBzZXR0aW5nIGZvciB0aGlzIHJlcXVlc3QuIFVuaXQgaXMgc2Vjb25kcy5cbiAgICAgKiBAcmV0dXJucyBMaXN0IG9mIHNlYXJjaCByZXNwb25zZXNcbiAgICAgKi9cbiAgICBhc3luYyBzZWFyY2hCYXRjaChjb2xsZWN0aW9uX25hbWUsIHsgc2VhcmNoZXMsIGNvbnNpc3RlbmN5LCB0aW1lb3V0LCB9KSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fb3BlbkFwaUNsaWVudC5zZWFyY2hCYXRjaFBvaW50cyh7XG4gICAgICAgICAgICBjb2xsZWN0aW9uX25hbWUsXG4gICAgICAgICAgICBjb25zaXN0ZW5jeSxcbiAgICAgICAgICAgIHRpbWVvdXQsXG4gICAgICAgICAgICBzZWFyY2hlcyxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtYXliZShyZXNwb25zZS5kYXRhLnJlc3VsdCkub3JUaHJvdygnU2VhcmNoIGJhdGNoIHJldHVybmVkIGVtcHR5Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlYXJjaCBmb3IgY2xvc2VzdCB2ZWN0b3JzIGluIGNvbGxlY3Rpb24gdGFraW5nIGludG8gYWNjb3VudCBmaWx0ZXJpbmcgY29uZGl0aW9uc1xuICAgICAqXG4gICAgICogQHBhcmFtIGNvbGxlY3Rpb25fbmFtZSBDb2xsZWN0aW9uIHRvIHNlYXJjaCBpblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzIC1cbiAgICAgKiAgICAgIC0gc2hhcmRfa2V5OiBTcGVjaWZ5IGluIHdoaWNoIHNoYXJkcyB0byBsb29rIGZvciB0aGUgcG9pbnRzLCBpZiBub3Qgc3BlY2lmaWVkIC0gbG9vayBpbiBhbGwgc2hhcmRzXG4gICAgICogICAgICAtIHZlY3RvcjpcbiAgICAgKiAgICAgICAgICBTZWFyY2ggZm9yIHZlY3RvcnMgY2xvc2VzdCB0byB0aGlzLlxuICAgICAqICAgICAgICAgIENhbiBiZSBlaXRoZXIgYSB2ZWN0b3IgaXRzZWxmLCBvciBhIG5hbWVkIHZlY3Rvciwgb3IgYSB0dXBsZSBvZiB2ZWN0b3IgbmFtZSBhbmQgdmVjdG9yIGl0c2VsZlxuICAgICAqICAgICAgLSBmaWx0ZXI6XG4gICAgICogICAgICAgICAgLSBFeGNsdWRlIHZlY3RvcnMgd2hpY2ggZG9lc24ndCBmaXQgZ2l2ZW4gY29uZGl0aW9ucy5cbiAgICAgKiAgICAgICAgICAtIElmIGBOb25lYCAtIHNlYXJjaCBhbW9uZyBhbGwgdmVjdG9yc1xuICAgICAqICAgICAgLSBwYXJhbXM6IEFkZGl0aW9uYWwgc2VhcmNoIHBhcmFtc1xuICAgICAqICAgICAgLSBsaW1pdDogSG93IG1hbnkgcmVzdWx0cyByZXR1cm5cbiAgICAgKiAgICAgIC0gb2Zmc2V0OlxuICAgICAqICAgICAgICAgIE9mZnNldCBvZiB0aGUgZmlyc3QgcmVzdWx0IHRvIHJldHVybi5cbiAgICAgKiAgICAgICAgICBNYXkgYmUgdXNlZCB0byBwYWdpbmF0ZSByZXN1bHRzLlxuICAgICAqICAgICAgICAgIE5vdGU6IGxhcmdlIG9mZnNldCB2YWx1ZXMgbWF5IGNhdXNlIHBlcmZvcm1hbmNlIGlzc3Vlcy5cbiAgICAgKiAgICAgIC0gd2l0aF9wYXlsb2FkOlxuICAgICAqICAgICAgICAgIC0gU3BlY2lmeSB3aGljaCBzdG9yZWQgcGF5bG9hZCBzaG91bGQgYmUgYXR0YWNoZWQgdG8gdGhlIHJlc3VsdC5cbiAgICAgKiAgICAgICAgICAtIElmIGBUcnVlYCAtIGF0dGFjaCBhbGwgcGF5bG9hZFxuICAgICAqICAgICAgICAgIC0gSWYgYEZhbHNlYCAtIGRvIG5vdCBhdHRhY2ggYW55IHBheWxvYWRcbiAgICAgKiAgICAgICAgICAtIElmIExpc3Qgb2Ygc3RyaW5nIC0gaW5jbHVkZSBvbmx5IHNwZWNpZmllZCBmaWVsZHNcbiAgICAgKiAgICAgICAgICAtIElmIGBQYXlsb2FkU2VsZWN0b3JgIC0gdXNlIGV4cGxpY2l0IHJ1bGVzXG4gICAgICogICAgICAtIHdpdGhfdmVjdG9yOlxuICAgICAqICAgICAgICAgIC0gSWYgYFRydWVgIC0gQXR0YWNoIHN0b3JlZCB2ZWN0b3IgdG8gdGhlIHNlYXJjaCByZXN1bHQuXG4gICAgICogICAgICAgICAgLSBJZiBgRmFsc2VgIC0gRG8gbm90IGF0dGFjaCB2ZWN0b3IuXG4gICAgICogICAgICAgICAgLSBJZiBMaXN0IG9mIHN0cmluZyAtIGluY2x1ZGUgb25seSBzcGVjaWZpZWQgZmllbGRzXG4gICAgICogICAgICAgICAgLSBEZWZhdWx0OiBgRmFsc2VgXG4gICAgICogICAgICAtIHNjb3JlX3RocmVzaG9sZDpcbiAgICAgKiAgICAgICAgICBEZWZpbmUgYSBtaW5pbWFsIHNjb3JlIHRocmVzaG9sZCBmb3IgdGhlIHJlc3VsdC5cbiAgICAgKiAgICAgICAgICBJZiBkZWZpbmVkLCBsZXNzIHNpbWlsYXIgcmVzdWx0cyB3aWxsIG5vdCBiZSByZXR1cm5lZC5cbiAgICAgKiAgICAgICAgICBTY29yZSBvZiB0aGUgcmV0dXJuZWQgcmVzdWx0IG1pZ2h0IGJlIGhpZ2hlciBvciBzbWFsbGVyIHRoYW4gdGhlIHRocmVzaG9sZCBkZXBlbmRpbmdcbiAgICAgKiAgICAgICAgICBvbiB0aGUgRGlzdGFuY2UgZnVuY3Rpb24gdXNlZC5cbiAgICAgKiAgICAgICAgICBFLmcuIGZvciBjb3NpbmUgc2ltaWxhcml0eSBvbmx5IGhpZ2hlciBzY29yZXMgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKiAgICAgIC0gY29uc2lzdGVuY3k6XG4gICAgICogICAgICAgICAgUmVhZCBjb25zaXN0ZW5jeSBvZiB0aGUgc2VhcmNoLiBEZWZpbmVzIGhvdyBtYW55IHJlcGxpY2FzIHNob3VsZCBiZSBxdWVyaWVkIGJlZm9yZSByZXR1cm5pbmcgdGhlIHJlc3VsdC5cbiAgICAgKiAgICAgICAgICBWYWx1ZXM6XG4gICAgICogICAgICAgICAgICAgIC0gaW50IC0gbnVtYmVyIG9mIHJlcGxpY2FzIHRvIHF1ZXJ5LCB2YWx1ZXMgc2hvdWxkIHByZXNlbnQgaW4gYWxsIHF1ZXJpZWQgcmVwbGljYXNcbiAgICAgKiAgICAgICAgICAgICAgLSAnbWFqb3JpdHknIC0gcXVlcnkgYWxsIHJlcGxpY2FzLCBidXQgcmV0dXJuIHZhbHVlcyBwcmVzZW50IGluIHRoZSBtYWpvcml0eSBvZiByZXBsaWNhc1xuICAgICAqICAgICAgICAgICAgICAtICdxdW9ydW0nIC0gcXVlcnkgdGhlIG1ham9yaXR5IG9mIHJlcGxpY2FzLCByZXR1cm4gdmFsdWVzIHByZXNlbnQgaW4gYWxsIG9mIHRoZW1cbiAgICAgKiAgICAgICAgICAgICAgLSAnYWxsJyAtIHF1ZXJ5IGFsbCByZXBsaWNhcywgYW5kIHJldHVybiB2YWx1ZXMgcHJlc2VudCBpbiBhbGwgcmVwbGljYXNcbiAgICAgKiAgICAgIC0gdGltZW91dDogSWYgc2V0LCBvdmVycmlkZXMgZ2xvYmFsIHRpbWVvdXQgc2V0dGluZyBmb3IgdGhpcyByZXF1ZXN0LiBVbml0IGlzIHNlY29uZHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICAgLy8gU2VhcmNoIHdpdGggZmlsdGVyXG4gICAgICogICAgIGNsaWVudC5zZWFyY2goXG4gICAgICogICAgICAgICBcInRlc3RfY29sbGVjdGlvblwiLFxuICAgICAqICAgICAgICAge1xuICAgICAqICAgICAgICAgICAgIHZlY3RvcjogWzEuMCwgMC4xLCAwLjIsIDAuN10sXG4gICAgICogICAgICAgICAgICAgZmlsdGVyOiB7XG4gICAgICogICAgICAgICAgICAgICAgIG11c3Q6IFtcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdjb2xvcicsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHtcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6ICdyZWQnXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAqICAgICAgICAgICAgICAgICBdXG4gICAgICogICAgICAgICAgICAgKVxuICAgICAqICAgICAgICAgfVxuICAgICAqICAgICApXG4gICAgICogQHJldHVybnMgTGlzdCBvZiBmb3VuZCBjbG9zZSBwb2ludHMgd2l0aCBzaW1pbGFyaXR5IHNjb3Jlcy5cbiAgICAgKi9cbiAgICBhc3luYyBzZWFyY2goY29sbGVjdGlvbl9uYW1lLCB7IHNoYXJkX2tleSwgdmVjdG9yLCBsaW1pdCA9IDEwLCBvZmZzZXQgPSAwLCBmaWx0ZXIsIHBhcmFtcywgd2l0aF9wYXlsb2FkID0gdHJ1ZSwgd2l0aF92ZWN0b3IgPSBmYWxzZSwgc2NvcmVfdGhyZXNob2xkLCBjb25zaXN0ZW5jeSwgdGltZW91dCwgfSkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX29wZW5BcGlDbGllbnQuc2VhcmNoUG9pbnRzKHtcbiAgICAgICAgICAgIGNvbGxlY3Rpb25fbmFtZSxcbiAgICAgICAgICAgIGNvbnNpc3RlbmN5LFxuICAgICAgICAgICAgdGltZW91dCxcbiAgICAgICAgICAgIHNoYXJkX2tleSxcbiAgICAgICAgICAgIHZlY3RvcixcbiAgICAgICAgICAgIGxpbWl0LFxuICAgICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgICAgZmlsdGVyLFxuICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgd2l0aF9wYXlsb2FkLFxuICAgICAgICAgICAgd2l0aF92ZWN0b3IsXG4gICAgICAgICAgICBzY29yZV90aHJlc2hvbGQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWF5YmUocmVzcG9uc2UuZGF0YS5yZXN1bHQpLm9yVGhyb3coJ1NlYXJjaCByZXR1cm5lZCBlbXB0eScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIG11bHRpcGxlIHJlY29tbWVuZCByZXF1ZXN0cyBpbiBiYXRjaCBtb2RlXG4gICAgICogQHBhcmFtIGNvbGxlY3Rpb25fbmFtZSBOYW1lIG9mIHRoZSBjb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAgICAgKiAgICAgLSBzZWFyY2hlczogTGlzdCBvZiByZWNvbW1lbmQgcmVxdWVzdHNcbiAgICAgKiAgICAgLSBjb25zaXN0ZW5jeTpcbiAgICAgKiAgICAgICAgIFJlYWQgY29uc2lzdGVuY3kgb2YgdGhlIHNlYXJjaC4gRGVmaW5lcyBob3cgbWFueSByZXBsaWNhcyBzaG91bGQgYmUgcXVlcmllZCBiZWZvcmUgcmV0dXJuaW5nIHRoZSByZXN1bHQuXG4gICAgICogICAgICAgICBWYWx1ZXM6XG4gICAgICogICAgICAgICAgICAgLSBudW1iZXIgLSBudW1iZXIgb2YgcmVwbGljYXMgdG8gcXVlcnksIHZhbHVlcyBzaG91bGQgcHJlc2VudCBpbiBhbGwgcXVlcmllZCByZXBsaWNhc1xuICAgICAqICAgICAgICAgICAgIC0gJ21ham9yaXR5JyAtIHF1ZXJ5IGFsbCByZXBsaWNhcywgYnV0IHJldHVybiB2YWx1ZXMgcHJlc2VudCBpbiB0aGUgbWFqb3JpdHkgb2YgcmVwbGljYXNcbiAgICAgKiAgICAgICAgICAgICAtICdxdW9ydW0nIC0gcXVlcnkgdGhlIG1ham9yaXR5IG9mIHJlcGxpY2FzLCByZXR1cm4gdmFsdWVzIHByZXNlbnQgaW4gYWxsIG9mIHRoZW1cbiAgICAgKiAgICAgICAgICAgICAtICdhbGwnIC0gcXVlcnkgYWxsIHJlcGxpY2FzLCBhbmQgcmV0dXJuIHZhbHVlcyBwcmVzZW50IGluIGFsbCByZXBsaWNhc1xuICAgICAqICAgICAtIHRpbWVvdXQ6IElmIHNldCwgb3ZlcnJpZGVzIGdsb2JhbCB0aW1lb3V0IHNldHRpbmcgZm9yIHRoaXMgcmVxdWVzdC4gVW5pdCBpcyBzZWNvbmRzLlxuICAgICAqIEByZXR1cm5zIExpc3Qgb2YgcmVjb21tZW5kIHJlc3BvbnNlc1xuICAgICAqL1xuICAgIGFzeW5jIHJlY29tbWVuZEJhdGNoKGNvbGxlY3Rpb25fbmFtZSwgeyBzZWFyY2hlcywgY29uc2lzdGVuY3ksIHRpbWVvdXQsIH0pIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9vcGVuQXBpQ2xpZW50LnJlY29tbWVuZEJhdGNoUG9pbnRzKHtcbiAgICAgICAgICAgIGNvbGxlY3Rpb25fbmFtZSxcbiAgICAgICAgICAgIHNlYXJjaGVzLFxuICAgICAgICAgICAgY29uc2lzdGVuY3ksXG4gICAgICAgICAgICB0aW1lb3V0LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1heWJlKHJlc3BvbnNlLmRhdGEucmVzdWx0KS5vckVsc2UoW10pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgcmVjb21tZW5kQmF0Y2hcbiAgICAgKi9cbiAgICBhc3luYyByZWNvbW1lbmRfYmF0Y2goY29sbGVjdGlvbl9uYW1lLCB7IHNlYXJjaGVzLCBjb25zaXN0ZW5jeSwgdGltZW91dCwgfSkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX29wZW5BcGlDbGllbnQucmVjb21tZW5kQmF0Y2hQb2ludHMoe1xuICAgICAgICAgICAgY29sbGVjdGlvbl9uYW1lLFxuICAgICAgICAgICAgc2VhcmNoZXMsXG4gICAgICAgICAgICBjb25zaXN0ZW5jeSxcbiAgICAgICAgICAgIHRpbWVvdXQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWF5YmUocmVzcG9uc2UuZGF0YS5yZXN1bHQpLm9yRWxzZShbXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlY29tbWVuZGF0aW9uIHJlcXVlc3QuIFByb3ZpZGVzIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSBleGFtcGxlcyBvZiB0aGUgdmVjdG9ycyxcbiAgICAgKiB3aGljaCBjYW4gYmUgaWRzIG9mIHBvaW50cyB0aGF0IGFyZSBhbHJlYWR5IHN0b3JlZCBpbiB0aGUgY29sbGVjdGlvbiwgcmF3IHZlY3RvcnMsIG9yIGV2ZW4gaWRzIGFuZCB2ZWN0b3JzIGNvbWJpbmVkLlxuICAgICAqIFNlcnZpY2Ugc2hvdWxkIGxvb2sgZm9yIHRoZSBwb2ludHMgd2hpY2ggYXJlIGNsb3NlciB0byBwb3NpdGl2ZSBleGFtcGxlcyBhbmQgYXQgdGhlIHNhbWUgdGltZSBmdXJ0aGVyIHRvIG5lZ2F0aXZlIGV4YW1wbGVzLlxuICAgICAqIFRoZSBjb25jcmV0ZSB3YXkgb2YgaG93IHRvIGNvbXBhcmUgbmVnYXRpdmUgYW5kIHBvc2l0aXZlIGRpc3RhbmNlcyBpcyB1cCB0byB0aGUgYHN0cmF0ZWd5YCBjaG9zZW4uXG4gICAgICogQHBhcmFtIGNvbGxlY3Rpb25fbmFtZSBDb2xsZWN0aW9uIHRvIHNlYXJjaCBpblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gICAgICogICAgIC0gc2hhcmRfa2V5OiBTcGVjaWZ5IGluIHdoaWNoIHNoYXJkcyB0byBsb29rIGZvciB0aGUgcG9pbnRzLCBpZiBub3Qgc3BlY2lmaWVkIC0gbG9vayBpbiBhbGwgc2hhcmRzXG4gICAgICogICAgIC0gcG9zaXRpdmU6XG4gICAgICogICAgICAgICBMaXN0IG9mIHN0b3JlZCBwb2ludCBJRHMsIHdoaWNoIHNob3VsZCBiZSB1c2VkIGFzIHJlZmVyZW5jZSBmb3Igc2ltaWxhcml0eSBzZWFyY2guXG4gICAgICogICAgICAgICBJZiB0aGVyZSBpcyBvbmx5IG9uZSBJRCBwcm92aWRlZCAtIHRoaXMgcmVxdWVzdCBpcyBlcXVpdmFsZW50IHRvIHRoZSByZWd1bGFyIHNlYXJjaCB3aXRoIHZlY3RvciBvZiB0aGF0IHBvaW50LlxuICAgICAqICAgICAgICAgSWYgdGhlcmUgYXJlIG1vcmUgdGhhbiBvbmUgSURzLCBRZHJhbnQgd2lsbCBhdHRlbXB0IHRvIHNlYXJjaCBmb3Igc2ltaWxhciB0byBhbGwgb2YgdGhlbS5cbiAgICAgKiAgICAgICAgIFJlY29tbWVuZGF0aW9uIGZvciBtdWx0aXBsZSB2ZWN0b3JzIGlzIGV4cGVyaW1lbnRhbC4gSXRzIGJlaGF2aW91ciBtYXkgY2hhbmdlIGluIHRoZSBmdXR1cmUuXG4gICAgICogICAgIC0gbmVnYXRpdmU6XG4gICAgICogICAgICAgICBMaXN0IG9mIHN0b3JlZCBwb2ludCBJRHMsIHdoaWNoIHNob3VsZCBiZSBkaXNzaW1pbGFyIHRvIHRoZSBzZWFyY2ggcmVzdWx0LlxuICAgICAqICAgICAgICAgTmVnYXRpdmUgZXhhbXBsZXMgaXMgYW4gZXhwZXJpbWVudGFsIGZ1bmN0aW9uYWxpdHkuIEl0cyBiZWhhdmlvdXIgbWF5IGNoYW5nZSBpbiB0aGUgZnV0dXJlLlxuICAgICAqICAgICAtIHN0cmF0ZWd5OlxuICAgICAqICAgICAgICAgSG93IHRvIHVzZSBwb3NpdGl2ZSBhbmQgbmVnYXRpdmUgZXhhbXBsZXMgdG8gZmluZCB0aGUgcmVzdWx0cy5cbiAgICAgKiAgICAgLSBxdWVyeV9maWx0ZXI6XG4gICAgICogICAgICAgICAtIEV4Y2x1ZGUgdmVjdG9ycyB3aGljaCBkb2Vzbid0IGZpdCBnaXZlbiBjb25kaXRpb25zLlxuICAgICAqICAgICAgICAgLSBJZiBgTm9uZWAgLSBzZWFyY2ggYW1vbmcgYWxsIHZlY3RvcnNcbiAgICAgKiAgICAgLSBzZWFyY2hfcGFyYW1zOiBBZGRpdGlvbmFsIHNlYXJjaCBwYXJhbXNcbiAgICAgKiAgICAgLSBsaW1pdDogSG93IG1hbnkgcmVzdWx0cyByZXR1cm5cbiAgICAgKiAgICAgICAgIC0gRGVmYXVsdDogYDEwYFxuICAgICAqICAgICAtIG9mZnNldDpcbiAgICAgKiAgICAgICAgIE9mZnNldCBvZiB0aGUgZmlyc3QgcmVzdWx0IHRvIHJldHVybi5cbiAgICAgKiAgICAgICAgIE1heSBiZSB1c2VkIHRvIHBhZ2luYXRlIHJlc3VsdHMuXG4gICAgICogICAgICAgICBOb3RlOiBsYXJnZSBvZmZzZXQgdmFsdWVzIG1heSBjYXVzZSBwZXJmb3JtYW5jZSBpc3N1ZXMuXG4gICAgICogICAgICAgICAtIERlZmF1bHQ6IGAwYFxuICAgICAqICAgICAtIHdpdGhfcGF5bG9hZDpcbiAgICAgKiAgICAgICAgIC0gU3BlY2lmeSB3aGljaCBzdG9yZWQgcGF5bG9hZCBzaG91bGQgYmUgYXR0YWNoZWQgdG8gdGhlIHJlc3VsdC5cbiAgICAgKiAgICAgICAgIC0gSWYgYFRydWVgIC0gYXR0YWNoIGFsbCBwYXlsb2FkXG4gICAgICogICAgICAgICAtIElmIGBGYWxzZWAgLSBkbyBub3QgYXR0YWNoIGFueSBwYXlsb2FkXG4gICAgICogICAgICAgICAtIElmIExpc3Qgb2Ygc3RyaW5nIC0gaW5jbHVkZSBvbmx5IHNwZWNpZmllZCBmaWVsZHNcbiAgICAgKiAgICAgICAgIC0gSWYgYFBheWxvYWRTZWxlY3RvcmAgLSB1c2UgZXhwbGljaXQgcnVsZXNcbiAgICAgKiAgICAgICAgIC0gRGVmYXVsdDogYHRydWVgXG4gICAgICogICAgIC0gd2l0aF92ZWN0b3I6XG4gICAgICogICAgICAgICAtIElmIGBUcnVlYCAtIEF0dGFjaCBzdG9yZWQgdmVjdG9yIHRvIHRoZSBzZWFyY2ggcmVzdWx0LlxuICAgICAqICAgICAgICAgLSBJZiBgRmFsc2VgIC0gRG8gbm90IGF0dGFjaCB2ZWN0b3IuXG4gICAgICogICAgICAgICAtIElmIExpc3Qgb2Ygc3RyaW5nIC0gaW5jbHVkZSBvbmx5IHNwZWNpZmllZCBmaWVsZHNcbiAgICAgKiAgICAgICAgIC0gRGVmYXVsdDogYGZhbHNlYFxuICAgICAqICAgICAtIHNjb3JlX3RocmVzaG9sZDpcbiAgICAgKiAgICAgICAgIERlZmluZSBhIG1pbmltYWwgc2NvcmUgdGhyZXNob2xkIGZvciB0aGUgcmVzdWx0LlxuICAgICAqICAgICAgICAgSWYgZGVmaW5lZCwgbGVzcyBzaW1pbGFyIHJlc3VsdHMgd2lsbCBub3QgYmUgcmV0dXJuZWQuXG4gICAgICogICAgICAgICBTY29yZSBvZiB0aGUgcmV0dXJuZWQgcmVzdWx0IG1pZ2h0IGJlIGhpZ2hlciBvciBzbWFsbGVyIHRoYW4gdGhlIHRocmVzaG9sZCBkZXBlbmRpbmdcbiAgICAgKiAgICAgICAgIG9uIHRoZSBEaXN0YW5jZSBmdW5jdGlvbiB1c2VkLlxuICAgICAqICAgICAgICAgRS5nLiBmb3IgY29zaW5lIHNpbWlsYXJpdHkgb25seSBoaWdoZXIgc2NvcmVzIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICogICAgIC0gdXNpbmc6XG4gICAgICogICAgICAgICBOYW1lIG9mIHRoZSB2ZWN0b3JzIHRvIHVzZSBmb3IgcmVjb21tZW5kYXRpb25zLlxuICAgICAqICAgICAgICAgSWYgYE5vbmVgIC0gdXNlIGRlZmF1bHQgdmVjdG9ycy5cbiAgICAgKiAgICAgLSBsb29rdXBGcm9tOlxuICAgICAqICAgICAgICAgRGVmaW5lcyBhIGxvY2F0aW9uIChjb2xsZWN0aW9uIGFuZCB2ZWN0b3IgZmllbGQgbmFtZSksIHVzZWQgdG8gbG9va3VwIHZlY3RvcnMgZm9yIHJlY29tbWVuZGF0aW9ucy5cbiAgICAgKiAgICAgICAgIElmIGBOb25lYCAtIHVzZSBjdXJyZW50IGNvbGxlY3Rpb24gd2lsbCBiZSB1c2VkLlxuICAgICAqICAgICAtIGNvbnNpc3RlbmN5OlxuICAgICAqICAgICAgICAgUmVhZCBjb25zaXN0ZW5jeSBvZiB0aGUgc2VhcmNoLiBEZWZpbmVzIGhvdyBtYW55IHJlcGxpY2FzIHNob3VsZCBiZSBxdWVyaWVkIGJlZm9yZSByZXR1cm5pbmcgdGhlIHJlc3VsdC5cbiAgICAgKiAgICAgICAgIFZhbHVlczpcbiAgICAgKiAgICAgICAgIC0gaW50IC0gbnVtYmVyIG9mIHJlcGxpY2FzIHRvIHF1ZXJ5LCB2YWx1ZXMgc2hvdWxkIHByZXNlbnQgaW4gYWxsIHF1ZXJpZWQgcmVwbGljYXNcbiAgICAgKiAgICAgICAgIC0gJ21ham9yaXR5JyAtIHF1ZXJ5IGFsbCByZXBsaWNhcywgYnV0IHJldHVybiB2YWx1ZXMgcHJlc2VudCBpbiB0aGUgbWFqb3JpdHkgb2YgcmVwbGljYXNcbiAgICAgKiAgICAgICAgIC0gJ3F1b3J1bScgLSBxdWVyeSB0aGUgbWFqb3JpdHkgb2YgcmVwbGljYXMsIHJldHVybiB2YWx1ZXMgcHJlc2VudCBpbiBhbGwgb2YgdGhlbVxuICAgICAqICAgICAgICAgLSAnYWxsJyAtIHF1ZXJ5IGFsbCByZXBsaWNhcywgYW5kIHJldHVybiB2YWx1ZXMgcHJlc2VudCBpbiBhbGwgcmVwbGljYXNcbiAgICAgKiAgICAgLSB0aW1lb3V0OiBJZiBzZXQsIG92ZXJyaWRlcyBnbG9iYWwgdGltZW91dCBzZXR0aW5nIGZvciB0aGlzIHJlcXVlc3QuIFVuaXQgaXMgc2Vjb25kcy5cbiAgICAgKiBAcmV0dXJucyBMaXN0IG9mIHJlY29tbWVuZGVkIHBvaW50cyB3aXRoIHNpbWlsYXJpdHkgc2NvcmVzLlxuICAgICAqL1xuICAgIGFzeW5jIHJlY29tbWVuZChjb2xsZWN0aW9uX25hbWUsIHsgc2hhcmRfa2V5LCBwb3NpdGl2ZSwgbmVnYXRpdmUsIHN0cmF0ZWd5LCBmaWx0ZXIsIHBhcmFtcywgbGltaXQgPSAxMCwgb2Zmc2V0ID0gMCwgd2l0aF9wYXlsb2FkID0gdHJ1ZSwgd2l0aF92ZWN0b3IgPSBmYWxzZSwgc2NvcmVfdGhyZXNob2xkLCB1c2luZywgbG9va3VwX2Zyb20sIGNvbnNpc3RlbmN5LCB0aW1lb3V0LCB9KSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fb3BlbkFwaUNsaWVudC5yZWNvbW1lbmRQb2ludHMoe1xuICAgICAgICAgICAgY29sbGVjdGlvbl9uYW1lLFxuICAgICAgICAgICAgbGltaXQsXG4gICAgICAgICAgICBzaGFyZF9rZXksXG4gICAgICAgICAgICBwb3NpdGl2ZSxcbiAgICAgICAgICAgIG5lZ2F0aXZlLFxuICAgICAgICAgICAgc3RyYXRlZ3ksXG4gICAgICAgICAgICBmaWx0ZXIsXG4gICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgICB3aXRoX3BheWxvYWQsXG4gICAgICAgICAgICB3aXRoX3ZlY3RvcixcbiAgICAgICAgICAgIHNjb3JlX3RocmVzaG9sZCxcbiAgICAgICAgICAgIHVzaW5nLFxuICAgICAgICAgICAgbG9va3VwX2Zyb20sXG4gICAgICAgICAgICBjb25zaXN0ZW5jeSxcbiAgICAgICAgICAgIHRpbWVvdXQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWF5YmUocmVzcG9uc2UuZGF0YS5yZXN1bHQpLm9yVGhyb3coJ1JlY29tbWVuZCBwb2ludHMgQVBJIHJldHVybmVkIGVtcHR5Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNjcm9sbCBvdmVyIGFsbCAobWF0Y2hpbmcpIHBvaW50cyBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICAgKiBAcGFyYW0gY29sbGVjdGlvbl9uYW1lIE5hbWUgb2YgdGhlIGNvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICAgICAqICAgICAtIHNoYXJkX2tleTogU3BlY2lmeSBpbiB3aGljaCBzaGFyZHMgdG8gbG9vayBmb3IgdGhlIHBvaW50cywgaWYgbm90IHNwZWNpZmllZCAtIGxvb2sgaW4gYWxsIHNoYXJkc1xuICAgICAqICAgICAtIGZpbHRlcjogSWYgcHJvdmlkZWQgLSBvbmx5IHJldHVybnMgcG9pbnRzIG1hdGNoaW5nIGZpbHRlcmluZyBjb25kaXRpb25zXG4gICAgICogICAgIC0gbGltaXQ6IEhvdyBtYW55IHBvaW50cyB0byByZXR1cm5cbiAgICAgKiAgICAgLSBvZmZzZXQ6IElmIHByb3ZpZGVkIC0gc2tpcCBwb2ludHMgd2l0aCBpZHMgbGVzcyB0aGFuIGdpdmVuIGBvZmZzZXRgXG4gICAgICogICAgIC0gd2l0aF9wYXlsb2FkOlxuICAgICAqICAgICAgICAgLSBTcGVjaWZ5IHdoaWNoIHN0b3JlZCBwYXlsb2FkIHNob3VsZCBiZSBhdHRhY2hlZCB0byB0aGUgcmVzdWx0LlxuICAgICAqICAgICAgICAgLSBJZiBgVHJ1ZWAgLSBhdHRhY2ggYWxsIHBheWxvYWRcbiAgICAgKiAgICAgICAgIC0gSWYgYEZhbHNlYCAtIGRvIG5vdCBhdHRhY2ggYW55IHBheWxvYWRcbiAgICAgKiAgICAgICAgIC0gSWYgTGlzdCBvZiBzdHJpbmcgLSBpbmNsdWRlIG9ubHkgc3BlY2lmaWVkIGZpZWxkc1xuICAgICAqICAgICAgICAgLSBJZiBgUGF5bG9hZFNlbGVjdG9yYCAtIHVzZSBleHBsaWNpdCBydWxlc1xuICAgICAqICAgICAgICAgLSBEZWZhdWx0OiBgdHJ1ZWBcbiAgICAgKiAgICAgLSB3aXRoX3ZlY3RvcjpcbiAgICAgKiAgICAgICAgIC0gSWYgYFRydWVgIC0gQXR0YWNoIHN0b3JlZCB2ZWN0b3IgdG8gdGhlIHNlYXJjaCByZXN1bHQuXG4gICAgICogICAgICAgICAtIElmIGBGYWxzZWAgLSBEbyBub3QgYXR0YWNoIHZlY3Rvci5cbiAgICAgKiAgICAgICAgIC0gSWYgTGlzdCBvZiBzdHJpbmcgLSBpbmNsdWRlIG9ubHkgc3BlY2lmaWVkIGZpZWxkc1xuICAgICAqICAgICAgICAgLSBEZWZhdWx0OiBgZmFsc2VgXG4gICAgICogICAgIC0gY29uc2lzdGVuY3k6XG4gICAgICogICAgICAgICBSZWFkIGNvbnNpc3RlbmN5IG9mIHRoZSBzZWFyY2guIERlZmluZXMgaG93IG1hbnkgcmVwbGljYXMgc2hvdWxkIGJlIHF1ZXJpZWQgYmVmb3JlIHJldHVybmluZyB0aGUgcmVzdWx0LlxuICAgICAqICAgICAgICAgVmFsdWVzOlxuICAgICAqICAgICAgICAgLSBpbnQgLSBudW1iZXIgb2YgcmVwbGljYXMgdG8gcXVlcnksIHZhbHVlcyBzaG91bGQgcHJlc2VudCBpbiBhbGwgcXVlcmllZCByZXBsaWNhc1xuICAgICAqICAgICAgICAgLSAnbWFqb3JpdHknIC0gcXVlcnkgYWxsIHJlcGxpY2FzLCBidXQgcmV0dXJuIHZhbHVlcyBwcmVzZW50IGluIHRoZSBtYWpvcml0eSBvZiByZXBsaWNhc1xuICAgICAqICAgICAgICAgLSAncXVvcnVtJyAtIHF1ZXJ5IHRoZSBtYWpvcml0eSBvZiByZXBsaWNhcywgcmV0dXJuIHZhbHVlcyBwcmVzZW50IGluIGFsbCBvZiB0aGVtXG4gICAgICogICAgICAgICAtICdhbGwnIC0gcXVlcnkgYWxsIHJlcGxpY2FzLCBhbmQgcmV0dXJuIHZhbHVlcyBwcmVzZW50IGluIGFsbCByZXBsaWNhc1xuICAgICAqICAgICAtIG9yZGVyX2J5OlxuICAgICAqICAgICAgICAgT3JkZXIgdGhlIHJlY29yZHMgYnkgYSBwYXlsb2FkIGZpZWxkLlxuICAgICAqIEByZXR1cm5zXG4gICAgICogICAgIEEgcGFpciBvZiAoTGlzdCBvZiBwb2ludHMpIGFuZCAob3B0aW9uYWwgb2Zmc2V0IGZvciB0aGUgbmV4dCBzY3JvbGwgcmVxdWVzdCkuXG4gICAgICogICAgIElmIG5leHQgcGFnZSBvZmZzZXQgaXMgYE5vbmVgIC0gdGhlcmUgaXMgbm8gbW9yZSBwb2ludHMgaW4gdGhlIGNvbGxlY3Rpb24gdG8gc2Nyb2xsLlxuICAgICAqL1xuICAgIGFzeW5jIHNjcm9sbChjb2xsZWN0aW9uX25hbWUsIHsgc2hhcmRfa2V5LCBmaWx0ZXIsIGNvbnNpc3RlbmN5LCB0aW1lb3V0LCBsaW1pdCA9IDEwLCBvZmZzZXQsIHdpdGhfcGF5bG9hZCA9IHRydWUsIHdpdGhfdmVjdG9yID0gZmFsc2UsIG9yZGVyX2J5LCB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9vcGVuQXBpQ2xpZW50LnNjcm9sbFBvaW50cyh7XG4gICAgICAgICAgICBjb2xsZWN0aW9uX25hbWUsXG4gICAgICAgICAgICBzaGFyZF9rZXksXG4gICAgICAgICAgICBsaW1pdCxcbiAgICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICAgIGZpbHRlcixcbiAgICAgICAgICAgIHdpdGhfcGF5bG9hZCxcbiAgICAgICAgICAgIHdpdGhfdmVjdG9yLFxuICAgICAgICAgICAgb3JkZXJfYnksXG4gICAgICAgICAgICBjb25zaXN0ZW5jeSxcbiAgICAgICAgICAgIHRpbWVvdXQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWF5YmUocmVzcG9uc2UuZGF0YS5yZXN1bHQpLm9yVGhyb3coJ1Njcm9sbCBwb2ludHMgQVBJIHJldHVybmVkIGVtcHR5Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvdW50IHBvaW50cyBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICAgKiBDb3VudCBwb2ludHMgaW4gdGhlIGNvbGxlY3Rpb24gbWF0Y2hpbmcgdGhlIGdpdmVuIGZpbHRlci5cbiAgICAgKiBAcGFyYW0gY29sbGVjdGlvbl9uYW1lXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAgICAgKiAgICAgLSBzaGFyZF9rZXk6IFNwZWNpZnkgaW4gd2hpY2ggc2hhcmRzIHRvIGxvb2sgZm9yIHRoZSBwb2ludHMsIGlmIG5vdCBzcGVjaWZpZWQgLSBsb29rIGluIGFsbCBzaGFyZHNcbiAgICAgKiAgICAgLSBmaWx0ZXI6IGZpbHRlcmluZyBjb25kaXRpb25zXG4gICAgICogICAgIC0gZXhhY3Q6XG4gICAgICogICAgICAgICBJZiBgVHJ1ZWAgLSBwcm92aWRlIHRoZSBleGFjdCBjb3VudCBvZiBwb2ludHMgbWF0Y2hpbmcgdGhlIGZpbHRlci5cbiAgICAgKiAgICAgICAgIElmIGBGYWxzZWAgLSBwcm92aWRlIHRoZSBhcHByb3hpbWF0ZSBjb3VudCBvZiBwb2ludHMgbWF0Y2hpbmcgdGhlIGZpbHRlci4gV29ya3MgZmFzdGVyLlxuICAgICAqICAgICAgICAgRGVmYXVsdDogYHRydWVgXG4gICAgICogQHJldHVybnMgQW1vdW50IG9mIHBvaW50cyBpbiB0aGUgY29sbGVjdGlvbiBtYXRjaGluZyB0aGUgZmlsdGVyLlxuICAgICAqL1xuICAgIGFzeW5jIGNvdW50KGNvbGxlY3Rpb25fbmFtZSwgeyBzaGFyZF9rZXksIGZpbHRlciwgZXhhY3QgPSB0cnVlLCB0aW1lb3V0IH0gPSB7fSkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX29wZW5BcGlDbGllbnQuY291bnRQb2ludHMoe1xuICAgICAgICAgICAgY29sbGVjdGlvbl9uYW1lLFxuICAgICAgICAgICAgc2hhcmRfa2V5LFxuICAgICAgICAgICAgZmlsdGVyLFxuICAgICAgICAgICAgZXhhY3QsXG4gICAgICAgICAgICB0aW1lb3V0LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1heWJlKHJlc3BvbnNlLmRhdGEucmVzdWx0KS5vclRocm93KCdDb3VudCBwb2ludHMgcmV0dXJuZWQgZW1wdHknKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGNsdXN0ZXIgaW5mb3JtYXRpb24gZm9yIGEgY29sbGVjdGlvbi5cbiAgICAgKiBAcGFyYW0gY29sbGVjdGlvbl9uYW1lXG4gICAgICogQHJldHVybnMgT3BlcmF0aW9uIHJlc3VsdFxuICAgICAqL1xuICAgIGFzeW5jIGNvbGxlY3Rpb25DbHVzdGVySW5mbyhjb2xsZWN0aW9uX25hbWUpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9vcGVuQXBpQ2xpZW50LmNvbGxlY3Rpb25DbHVzdGVySW5mbyh7IGNvbGxlY3Rpb25fbmFtZSB9KTtcbiAgICAgICAgcmV0dXJuIG1heWJlKHJlc3BvbnNlLmRhdGEucmVzdWx0KS5vclRocm93KCdDb2xsZWN0aW9uIGNsdXN0ZXIgaW5mbyByZXR1cm5lZCBlbXB0eScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgY29sbGVjdGlvbiBjbHVzdGVyIHNldHVwXG4gICAgICogQHBhcmFtIGNvbGxlY3Rpb25fbmFtZSBOYW1lIG9mIHRoZSBjb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAgICAgKiAgICAgLSB0aW1lb3V0OiBJZiBzZXQsIG92ZXJyaWRlcyBnbG9iYWwgdGltZW91dCBzZXR0aW5nIGZvciB0aGlzIHJlcXVlc3QuIFVuaXQgaXMgc2Vjb25kcy5cbiAgICAgKiAgICAgLSBvcGVyYXRpb246IENsdXN0ZXIgb3BlcmF0aW9uIHRvIHBlcmZvcm0uIENhbiBiZSBvbmUgb2Y6XG4gICAgICogICAgICAgICAtIG1vdmVfc2hhcmQ6IE1vdmUgYSBzaGFyZCBmcm9tIG9uZSBwZWVyIHRvIGFub3RoZXJcbiAgICAgKiAgICAgICAgIC0gcmVwbGljYXRlX3NoYXJkOiBSZXBsaWNhdGUgYSBzaGFyZCB0byBhbm90aGVyIHBlZXJcbiAgICAgKiAgICAgICAgIC0gYWJvcnRfdHJhbnNmZXI6IEFib3J0IGFuIG9uZ29pbmcgc2hhcmQgdHJhbnNmZXJcbiAgICAgKiAgICAgICAgIC0gZHJvcF9yZXBsaWNhOiBEcm9wIGEgcmVwbGljYSBmcm9tIGEgcGVlclxuICAgICAqICAgICAgICAgLSBjcmVhdGVfc2hhcmRpbmdfa2V5OiBDcmVhdGUgYSBuZXcgc2hhcmRpbmcga2V5XG4gICAgICogICAgICAgICAtIGRyb3Bfc2hhcmRpbmdfa2V5OiBEcm9wIGFuIGV4aXN0aW5nIHNoYXJkaW5nIGtleVxuICAgICAqICAgICAgICAgLSByZXN0YXJ0X3RyYW5zZmVyOiBSZXN0YXJ0IGEgZmFpbGVkIHNoYXJkIHRyYW5zZmVyXG4gICAgICogICAgICAgICAtIHN0YXJ0X3Jlc2hhcmRpbmc6IFN0YXJ0IHJlc2hhcmRpbmcgb3BlcmF0aW9uXG4gICAgICogICAgICAgICAtIGFib3J0X3Jlc2hhcmRpbmc6IEFib3J0IGFuIG9uZ29pbmcgcmVzaGFyZGluZyBvcGVyYXRpb25cbiAgICAgKiBAcmV0dXJucyBPcGVyYXRpb24gcmVzdWx0XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlQ29sbGVjdGlvbkNsdXN0ZXIoY29sbGVjdGlvbl9uYW1lLCB7IHRpbWVvdXQsIC4uLm9wZXJhdGlvbiB9KSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fb3BlbkFwaUNsaWVudC51cGRhdGVDb2xsZWN0aW9uQ2x1c3Rlcih7XG4gICAgICAgICAgICBjb2xsZWN0aW9uX25hbWUsXG4gICAgICAgICAgICB0aW1lb3V0LFxuICAgICAgICAgICAgLi4ub3BlcmF0aW9uLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1heWJlKHJlc3BvbnNlLmRhdGEucmVzdWx0KS5vclRocm93KCdVcGRhdGUgY29sbGVjdGlvbiBjbHVzdGVyIHJldHVybmVkIGVtcHR5Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB2ZWN0b3JzXG4gICAgICogQHBhcmFtIGNvbGxlY3Rpb25fbmFtZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gICAgICogICAgIC0gd2FpdDogQXdhaXQgZm9yIHRoZSByZXN1bHRzIHRvIGJlIHByb2Nlc3NlZC5cbiAgICAgKiAgICAgICAgIC0gSWYgYHRydWVgLCByZXN1bHQgd2lsbCBiZSByZXR1cm5lZCBvbmx5IHdoZW4gYWxsIGNoYW5nZXMgYXJlIGFwcGxpZWRcbiAgICAgKiAgICAgICAgIC0gSWYgYGZhbHNlYCwgcmVzdWx0IHdpbGwgYmUgcmV0dXJuZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGNvbmZpcm1hdGlvbiBvZiByZWNlaXZpbmcuXG4gICAgICogICAgICAgICAtIERlZmF1bHQ6IGB0cnVlYFxuICAgICAqICAgICAtIG9yZGVyaW5nOiBEZWZpbmUgc3RyYXRlZ3kgZm9yIG9yZGVyaW5nIG9mIHRoZSBwb2ludHMuIFBvc3NpYmxlIHZhbHVlczpcbiAgICAgKiAgICAgICAgICAtICd3ZWFrJyAgIC0gd3JpdGUgb3BlcmF0aW9ucyBtYXkgYmUgcmVvcmRlcmVkLCB3b3JrcyBmYXN0ZXIsIGRlZmF1bHRcbiAgICAgKiAgICAgICAgICAtICdtZWRpdW0nIC0gd3JpdGUgb3BlcmF0aW9ucyBnbyB0aHJvdWdoIGR5bmFtaWNhbGx5IHNlbGVjdGVkIGxlYWRlcixcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICBtYXkgYmUgaW5jb25zaXN0ZW50IGZvciBhIHNob3J0IHBlcmlvZCBvZiB0aW1lIGluIGNhc2Ugb2YgbGVhZGVyIGNoYW5nZVxuICAgICAqICAgICAgICAgIC0gJ3N0cm9uZycgLSBXcml0ZSBvcGVyYXRpb25zIGdvIHRocm91Z2ggdGhlIHBlcm1hbmVudCBsZWFkZXIsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgY29uc2lzdGVudCwgYnV0IG1heSBiZSB1bmF2YWlsYWJsZSBpZiBsZWFkZXIgaXMgZG93blxuICAgICAqICAgICAtIHBvaW50czogUG9pbnRzIHdpdGggbmFtZWQgdmVjdG9yc1xuICAgICAqICAgICAtIHNoYXJkX2tleTogU3BlY2lmeSBpbiB3aGljaCBzaGFyZHMgdG8gbG9vayBmb3IgdGhlIHBvaW50cywgaWYgbm90IHNwZWNpZmllZCAtIGxvb2sgaW4gYWxsIHNoYXJkc1xuICAgICAqIEByZXR1cm5zIE9wZXJhdGlvbiByZXN1bHRcbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVWZWN0b3JzKGNvbGxlY3Rpb25fbmFtZSwgeyB3YWl0ID0gdHJ1ZSwgb3JkZXJpbmcsIHBvaW50cywgc2hhcmRfa2V5LCB9KSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fb3BlbkFwaUNsaWVudC51cGRhdGVWZWN0b3JzKHtcbiAgICAgICAgICAgIGNvbGxlY3Rpb25fbmFtZSxcbiAgICAgICAgICAgIHdhaXQsXG4gICAgICAgICAgICBvcmRlcmluZyxcbiAgICAgICAgICAgIHBvaW50cyxcbiAgICAgICAgICAgIHNoYXJkX2tleSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtYXliZShyZXNwb25zZS5kYXRhLnJlc3VsdCkub3JUaHJvdygnVXBkYXRlIHZlY3RvcnMgcmV0dXJuZWQgZW1wdHknKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIHZlY3RvcnNcbiAgICAgKiBAcGFyYW0gY29sbGVjdGlvbl9uYW1lXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAgICAgKiAgICAgLSB3YWl0OiBBd2FpdCBmb3IgdGhlIHJlc3VsdHMgdG8gYmUgcHJvY2Vzc2VkLlxuICAgICAqICAgICAgICAgLSBJZiBgdHJ1ZWAsIHJlc3VsdCB3aWxsIGJlIHJldHVybmVkIG9ubHkgd2hlbiBhbGwgY2hhbmdlcyBhcmUgYXBwbGllZFxuICAgICAqICAgICAgICAgLSBJZiBgZmFsc2VgLCByZXN1bHQgd2lsbCBiZSByZXR1cm5lZCBpbW1lZGlhdGVseSBhZnRlciB0aGUgY29uZmlybWF0aW9uIG9mIHJlY2VpdmluZy5cbiAgICAgKiAgICAgICAgIC0gRGVmYXVsdDogYHRydWVgXG4gICAgICogICAgIC0gb3JkZXJpbmc6IERlZmluZSBzdHJhdGVneSBmb3Igb3JkZXJpbmcgb2YgdGhlIHBvaW50cy4gUG9zc2libGUgdmFsdWVzOlxuICAgICAqICAgICAgICAgIC0gJ3dlYWsnICAgLSB3cml0ZSBvcGVyYXRpb25zIG1heSBiZSByZW9yZGVyZWQsIHdvcmtzIGZhc3RlciwgZGVmYXVsdFxuICAgICAqICAgICAgICAgIC0gJ21lZGl1bScgLSB3cml0ZSBvcGVyYXRpb25zIGdvIHRocm91Z2ggZHluYW1pY2FsbHkgc2VsZWN0ZWQgbGVhZGVyLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIG1heSBiZSBpbmNvbnNpc3RlbnQgZm9yIGEgc2hvcnQgcGVyaW9kIG9mIHRpbWUgaW4gY2FzZSBvZiBsZWFkZXIgY2hhbmdlXG4gICAgICogICAgICAgICAgLSAnc3Ryb25nJyAtIFdyaXRlIG9wZXJhdGlvbnMgZ28gdGhyb3VnaCB0aGUgcGVybWFuZW50IGxlYWRlcixcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICBjb25zaXN0ZW50LCBidXQgbWF5IGJlIHVuYXZhaWxhYmxlIGlmIGxlYWRlciBpcyBkb3duXG4gICAgICogICAgIC0gcG9pbnRzOiBEZWxldGVzIHZhbHVlcyBmcm9tIGVhY2ggcG9pbnQgaW4gdGhpcyBsaXN0XG4gICAgICogICAgIC0gZmlsdGVyOiBEZWxldGVzIHZhbHVlcyBmcm9tIHBvaW50cyB0aGF0IHNhdGlzZnkgdGhpcyBmaWx0ZXIgY29uZGl0aW9uXG4gICAgICogICAgIC0gdmVjdG9yOiBWZWN0b3IgbmFtZXNcbiAgICAgKiAgICAgLSBzaGFyZF9rZXk6IFNwZWNpZnkgaW4gd2hpY2ggc2hhcmRzIHRvIGxvb2sgZm9yIHRoZSBwb2ludHMsIGlmIG5vdCBzcGVjaWZpZWQgLSBsb29rIGluIGFsbCBzaGFyZHNcbiAgICAgKiBAcmV0dXJucyBPcGVyYXRpb24gcmVzdWx0XG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlVmVjdG9ycyhjb2xsZWN0aW9uX25hbWUsIHsgd2FpdCA9IHRydWUsIG9yZGVyaW5nLCBwb2ludHMsIGZpbHRlciwgdmVjdG9yLCBzaGFyZF9rZXksIH0pIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9vcGVuQXBpQ2xpZW50LmRlbGV0ZVZlY3RvcnMoe1xuICAgICAgICAgICAgY29sbGVjdGlvbl9uYW1lLFxuICAgICAgICAgICAgd2FpdCxcbiAgICAgICAgICAgIG9yZGVyaW5nLFxuICAgICAgICAgICAgcG9pbnRzLFxuICAgICAgICAgICAgZmlsdGVyLFxuICAgICAgICAgICAgdmVjdG9yLFxuICAgICAgICAgICAgc2hhcmRfa2V5LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1heWJlKHJlc3BvbnNlLmRhdGEucmVzdWx0KS5vclRocm93KCdEZWxldGUgdmVjdG9ycyByZXR1cm5lZCBlbXB0eScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWFyY2ggcG9pbnQgZ3JvdXBzXG4gICAgICogQHBhcmFtIGNvbGxlY3Rpb25fbmFtZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzIC1cbiAgICAgKiAgICAgLSBjb25zaXN0ZW5jeTogUmVhZCBjb25zaXN0ZW5jeSBvZiB0aGUgc2VhcmNoLiBEZWZpbmVzIGhvdyBtYW55IHJlcGxpY2FzIHNob3VsZCBiZSBxdWVyaWVkIGJlZm9yZSByZXR1cm5pbmcgdGhlIHJlc3VsdC5cbiAgICAgKiAgICAgICAgIFZhbHVlczpcbiAgICAgKiAgICAgICAgICAgICBudW1iZXIgLSBudW1iZXIgb2YgcmVwbGljYXMgdG8gcXVlcnksIHZhbHVlcyBzaG91bGQgcHJlc2VudCBpbiBhbGwgcXVlcmllZCByZXBsaWNhc1xuICAgICAqICAgICAgICAgICAgICdtYWpvcml0eScgLSBxdWVyeSBhbGwgcmVwbGljYXMsIGJ1dCByZXR1cm4gdmFsdWVzIHByZXNlbnQgaW4gdGhlIG1ham9yaXR5IG9mIHJlcGxpY2FzXG4gICAgICogICAgICAgICAgICAgJ3F1b3J1bScgLSBxdWVyeSB0aGUgbWFqb3JpdHkgb2YgcmVwbGljYXMsIHJldHVybiB2YWx1ZXMgcHJlc2VudCBpbiBhbGwgb2YgdGhlbVxuICAgICAqICAgICAgICAgICAgICdhbGwnIC0gcXVlcnkgYWxsIHJlcGxpY2FzLCBhbmQgcmV0dXJuIHZhbHVlcyBwcmVzZW50IGluIGFsbCByZXBsaWNhc1xuICAgICAqICAgICAtIHRpbWVvdXQ6IElmIHNldCwgb3ZlcnJpZGVzIGdsb2JhbCB0aW1lb3V0IHNldHRpbmcgZm9yIHRoaXMgcmVxdWVzdC4gVW5pdCBpcyBzZWNvbmRzLlxuICAgICAqICAgICAtIHNoYXJkX2tleTogU3BlY2lmeSBpbiB3aGljaCBzaGFyZHMgdG8gbG9vayBmb3IgdGhlIHBvaW50cywgaWYgbm90IHNwZWNpZmllZCAtIGxvb2sgaW4gYWxsIHNoYXJkc1xuICAgICAqICAgICAtIHZlY3RvcjogcXVlcnkgc2VhcmNoIHZlY3RvclxuICAgICAqICAgICAtIGZpbHRlcjogTG9vayBvbmx5IGZvciBwb2ludHMgd2hpY2ggc2F0aXNmaWVzIHRoaXMgY29uZGl0aW9uc1xuICAgICAqICAgICAtIHBhcmFtczogQWRkaXRpb25hbCBzZWFyY2ggcGFyYW1zXG4gICAgICogICAgIC0gd2l0aF9wYXlsb2FkOiBTZWxlY3Qgd2hpY2ggcGF5bG9hZCB0byByZXR1cm4gd2l0aCB0aGUgcmVzcG9uc2VcbiAgICAgKiAgICAgLSB3aXRoX3ZlY3RvcjogV2hldGhlciB0byByZXR1cm4gdGhlIHBvaW50IHZlY3RvciB3aXRoIHRoZSByZXN1bHQ/XG4gICAgICogICAgIC0gc2NvcmVfdGhyZXNob2xkOiBEZWZpbmUgYSBtaW5pbWFsIHNjb3JlIHRocmVzaG9sZCBmb3IgdGhlIHJlc3VsdC4gSWYgZGVmaW5lZCwgbGVzcyBzaW1pbGFyIHJlc3VsdHMgd2lsbCBub3QgYmUgcmV0dXJuZWQuIFNjb3JlIG9mIHRoZSByZXR1cm5lZCByZXN1bHQgbWlnaHQgYmUgaGlnaGVyIG9yIHNtYWxsZXIgdGhhbiB0aGUgdGhyZXNob2xkIGRlcGVuZGluZyBvbiB0aGUgRGlzdGFuY2UgZnVuY3Rpb24gdXNlZC4gRS5nLiBmb3IgY29zaW5lIHNpbWlsYXJpdHkgb25seSBoaWdoZXIgc2NvcmVzIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICogICAgIC0gZ3JvdXBfYnk6IFBheWxvYWQgZmllbGQgdG8gZ3JvdXAgYnksIG11c3QgYmUgYSBzdHJpbmcgb3IgbnVtYmVyIGZpZWxkLiBJZiB0aGUgZmllbGQgY29udGFpbnMgbW9yZSB0aGFuIDEgdmFsdWUsIGFsbCB2YWx1ZXMgd2lsbCBiZSB1c2VkIGZvciBncm91cGluZy4gT25lIHBvaW50IGNhbiBiZSBpbiBtdWx0aXBsZSBncm91cHMuXG4gICAgICogICAgIC0gZ3JvdXBfc2l6ZTogTWF4aW11bSBhbW91bnQgb2YgcG9pbnRzIHRvIHJldHVybiBwZXIgZ3JvdXBcbiAgICAgKiAgICAgLSBsaW1pdDogTWF4aW11bSBhbW91bnQgb2YgZ3JvdXBzIHRvIHJldHVyblxuICAgICAqIEByZXR1cm5zIE9wZXJhdGlvbiByZXN1bHRcbiAgICAgKi9cbiAgICBhc3luYyBzZWFyY2hQb2ludEdyb3Vwcyhjb2xsZWN0aW9uX25hbWUsIHsgY29uc2lzdGVuY3ksIHRpbWVvdXQsIHNoYXJkX2tleSwgdmVjdG9yLCBmaWx0ZXIsIHBhcmFtcywgd2l0aF9wYXlsb2FkID0gbnVsbCwgd2l0aF92ZWN0b3IgPSBudWxsLCBzY29yZV90aHJlc2hvbGQsIGdyb3VwX2J5LCBncm91cF9zaXplLCBsaW1pdCwgfSkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX29wZW5BcGlDbGllbnQuc2VhcmNoUG9pbnRHcm91cHMoe1xuICAgICAgICAgICAgY29sbGVjdGlvbl9uYW1lLFxuICAgICAgICAgICAgY29uc2lzdGVuY3ksXG4gICAgICAgICAgICB0aW1lb3V0LFxuICAgICAgICAgICAgc2hhcmRfa2V5LFxuICAgICAgICAgICAgdmVjdG9yLFxuICAgICAgICAgICAgZmlsdGVyLFxuICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgd2l0aF9wYXlsb2FkLFxuICAgICAgICAgICAgd2l0aF92ZWN0b3IsXG4gICAgICAgICAgICBzY29yZV90aHJlc2hvbGQsXG4gICAgICAgICAgICBncm91cF9ieSxcbiAgICAgICAgICAgIGdyb3VwX3NpemUsXG4gICAgICAgICAgICBsaW1pdCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtYXliZShyZXNwb25zZS5kYXRhLnJlc3VsdCkub3JUaHJvdygnU2VhcmNoIHBvaW50IGdyb3VwcyByZXR1cm5lZCBlbXB0eScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWNvbW1lbmQgcG9pbnQgZ3JvdXBzXG4gICAgICogQHBhcmFtIGNvbGxlY3Rpb25fbmFtZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzIC1cbiAgICAgKiAgICAgLSBjb25zaXN0ZW5jeTogUmVhZCBjb25zaXN0ZW5jeSBvZiB0aGUgc2VhcmNoLiBEZWZpbmVzIGhvdyBtYW55IHJlcGxpY2FzIHNob3VsZCBiZSBxdWVyaWVkIGJlZm9yZSByZXR1cm5pbmcgdGhlIHJlc3VsdC5cbiAgICAgKiAgICAgICAgIFZhbHVlczpcbiAgICAgKiAgICAgICAgICAgICBudW1iZXIgLSBudW1iZXIgb2YgcmVwbGljYXMgdG8gcXVlcnksIHZhbHVlcyBzaG91bGQgcHJlc2VudCBpbiBhbGwgcXVlcmllZCByZXBsaWNhc1xuICAgICAqICAgICAgICAgICAgICdtYWpvcml0eScgLSBxdWVyeSBhbGwgcmVwbGljYXMsIGJ1dCByZXR1cm4gdmFsdWVzIHByZXNlbnQgaW4gdGhlIG1ham9yaXR5IG9mIHJlcGxpY2FzXG4gICAgICogICAgICAgICAgICAgJ3F1b3J1bScgLSBxdWVyeSB0aGUgbWFqb3JpdHkgb2YgcmVwbGljYXMsIHJldHVybiB2YWx1ZXMgcHJlc2VudCBpbiBhbGwgb2YgdGhlbVxuICAgICAqICAgICAgICAgICAgICdhbGwnIC0gcXVlcnkgYWxsIHJlcGxpY2FzLCBhbmQgcmV0dXJuIHZhbHVlcyBwcmVzZW50IGluIGFsbCByZXBsaWNhc1xuICAgICAqICAgICAtIHRpbWVvdXQ6IElmIHNldCwgb3ZlcnJpZGVzIGdsb2JhbCB0aW1lb3V0IHNldHRpbmcgZm9yIHRoaXMgcmVxdWVzdC4gVW5pdCBpcyBzZWNvbmRzLlxuICAgICAqICAgICAtIHNoYXJkX2tleTogU3BlY2lmeSBpbiB3aGljaCBzaGFyZHMgdG8gbG9vayBmb3IgdGhlIHBvaW50cywgaWYgbm90IHNwZWNpZmllZCAtIGxvb2sgaW4gYWxsIHNoYXJkc1xuICAgICAqICAgICAtIHBvc2l0aXZlOiBMb29rIGZvciB2ZWN0b3JzIGNsb3Nlc3QgdG8gdGhvc2VcbiAgICAgKiAgICAgLSBuZWdhdGl2ZTogVHJ5IHRvIGF2b2lkIHZlY3RvcnMgbGlrZSB0aGlzXG4gICAgICogICAgIC0gc3RyYXRlZ3k6IEhvdyB0byB1c2UgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIGV4YW1wbGVzIHRvIGZpbmQgdGhlIHJlc3VsdHNcbiAgICAgKiAgICAgLSBmaWx0ZXI6IExvb2sgb25seSBmb3IgcG9pbnRzIHdoaWNoIHNhdGlzZmllcyB0aGlzIGNvbmRpdGlvbnNcbiAgICAgKiAgICAgLSBwYXJhbXM6IEFkZGl0aW9uYWwgc2VhcmNoIHBhcmFtc1xuICAgICAqICAgICAtIHdpdGhfcGF5bG9hZDogU2VsZWN0IHdoaWNoIHBheWxvYWQgdG8gcmV0dXJuIHdpdGggdGhlIHJlc3BvbnNlXG4gICAgICogICAgIC0gd2l0aF92ZWN0b3I6IFdoZXRoZXIgdG8gcmV0dXJuIHRoZSBwb2ludCB2ZWN0b3Igd2l0aCB0aGUgcmVzdWx0P1xuICAgICAqICAgICAtIHNjb3JlX3RocmVzaG9sZDogRGVmaW5lIGEgbWluaW1hbCBzY29yZSB0aHJlc2hvbGQgZm9yIHRoZSByZXN1bHQuIElmIGRlZmluZWQsIGxlc3Mgc2ltaWxhciByZXN1bHRzIHdpbGwgbm90IGJlIHJldHVybmVkLiBTY29yZSBvZiB0aGUgcmV0dXJuZWQgcmVzdWx0IG1pZ2h0IGJlIGhpZ2hlciBvciBzbWFsbGVyIHRoYW4gdGhlIHRocmVzaG9sZCBkZXBlbmRpbmcgb24gdGhlIERpc3RhbmNlIGZ1bmN0aW9uIHVzZWQuIEUuZy4gZm9yIGNvc2luZSBzaW1pbGFyaXR5IG9ubHkgaGlnaGVyIHNjb3JlcyB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqICAgICAtIHVzaW5nOiBEZWZpbmUgd2hpY2ggdmVjdG9yIHRvIHVzZSBmb3IgcmVjb21tZW5kYXRpb24sIGlmIG5vdCBzcGVjaWZpZWQgLSB0cnkgdG8gdXNlIGRlZmF1bHQgdmVjdG9yXG4gICAgICogICAgIC0gbG9va3VwX2Zyb206IFRoZSBsb2NhdGlvbiB1c2VkIHRvIGxvb2t1cCB2ZWN0b3JzLiBJZiBub3Qgc3BlY2lmaWVkIC0gdXNlIGN1cnJlbnQgY29sbGVjdGlvbi4gTm90ZTogdGhlIG90aGVyIGNvbGxlY3Rpb24gc2hvdWxkIGhhdmUgdGhlIHNhbWUgdmVjdG9yIHNpemUgYXMgdGhlIGN1cnJlbnQgY29sbGVjdGlvblxuICAgICAqICAgICAtIGdyb3VwX2J5OiBQYXlsb2FkIGZpZWxkIHRvIGdyb3VwIGJ5LCBtdXN0IGJlIGEgc3RyaW5nIG9yIG51bWJlciBmaWVsZC4gSWYgdGhlIGZpZWxkIGNvbnRhaW5zIG1vcmUgdGhhbiAxIHZhbHVlLCBhbGwgdmFsdWVzIHdpbGwgYmUgdXNlZCBmb3IgZ3JvdXBpbmcuIE9uZSBwb2ludCBjYW4gYmUgaW4gbXVsdGlwbGUgZ3JvdXBzLlxuICAgICAqICAgICAtIGdyb3VwX3NpemU6IE1heGltdW0gYW1vdW50IG9mIHBvaW50cyB0byByZXR1cm4gcGVyIGdyb3VwXG4gICAgICogICAgIC0gbGltaXQ6IE1heGltdW0gYW1vdW50IG9mIGdyb3VwcyB0byByZXR1cm5cbiAgICAgKiBAcmV0dXJucyBPcGVyYXRpb24gcmVzdWx0XG4gICAgICovXG4gICAgYXN5bmMgcmVjb21tZW5kUG9pbnRHcm91cHMoY29sbGVjdGlvbl9uYW1lLCB7IGNvbnNpc3RlbmN5LCB0aW1lb3V0LCBzaGFyZF9rZXksIHBvc2l0aXZlLCBzdHJhdGVneSwgbmVnYXRpdmUgPSBbXSwgZmlsdGVyLCBwYXJhbXMsIHdpdGhfcGF5bG9hZCA9IG51bGwsIHdpdGhfdmVjdG9yID0gbnVsbCwgc2NvcmVfdGhyZXNob2xkLCB1c2luZyA9IG51bGwsIGxvb2t1cF9mcm9tID0gbnVsbCwgZ3JvdXBfYnksIGdyb3VwX3NpemUsIGxpbWl0LCB9KSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fb3BlbkFwaUNsaWVudC5yZWNvbW1lbmRQb2ludEdyb3Vwcyh7XG4gICAgICAgICAgICBjb2xsZWN0aW9uX25hbWUsXG4gICAgICAgICAgICBjb25zaXN0ZW5jeSxcbiAgICAgICAgICAgIHRpbWVvdXQsXG4gICAgICAgICAgICBzaGFyZF9rZXksXG4gICAgICAgICAgICBwb3NpdGl2ZSxcbiAgICAgICAgICAgIG5lZ2F0aXZlLFxuICAgICAgICAgICAgc3RyYXRlZ3ksXG4gICAgICAgICAgICBmaWx0ZXIsXG4gICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICB3aXRoX3BheWxvYWQsXG4gICAgICAgICAgICB3aXRoX3ZlY3RvcixcbiAgICAgICAgICAgIHNjb3JlX3RocmVzaG9sZCxcbiAgICAgICAgICAgIHVzaW5nLFxuICAgICAgICAgICAgbG9va3VwX2Zyb20sXG4gICAgICAgICAgICBncm91cF9ieSxcbiAgICAgICAgICAgIGdyb3VwX3NpemUsXG4gICAgICAgICAgICBsaW1pdCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtYXliZShyZXNwb25zZS5kYXRhLnJlc3VsdCkub3JUaHJvdygnUmVjb21tZW5kIHBvaW50IGdyb3VwcyBBUEkgcmV0dXJuZWQgZW1wdHknKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIG9yIGluc2VydCBhIG5ldyBwb2ludCBpbnRvIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqIEBwYXJhbSBjb2xsZWN0aW9uX25hbWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICAgICAqICAgICAtIHdhaXQ6IEF3YWl0IGZvciB0aGUgcmVzdWx0cyB0byBiZSBwcm9jZXNzZWQuXG4gICAgICogICAgICAgICAtIElmIGB0cnVlYCwgcmVzdWx0IHdpbGwgYmUgcmV0dXJuZWQgb25seSB3aGVuIGFsbCBjaGFuZ2VzIGFyZSBhcHBsaWVkXG4gICAgICogICAgICAgICAtIElmIGBmYWxzZWAsIHJlc3VsdCB3aWxsIGJlIHJldHVybmVkIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBjb25maXJtYXRpb24gb2YgcmVjZWl2aW5nLlxuICAgICAqICAgICAgICAgLSBEZWZhdWx0OiBgdHJ1ZWBcbiAgICAgKiAgICAgLSBvcmRlcmluZzogRGVmaW5lIHN0cmF0ZWd5IGZvciBvcmRlcmluZyBvZiB0aGUgcG9pbnRzLiBQb3NzaWJsZSB2YWx1ZXM6XG4gICAgICogICAgICAgICAgLSAnd2VhaycgICAtIHdyaXRlIG9wZXJhdGlvbnMgbWF5IGJlIHJlb3JkZXJlZCwgd29ya3MgZmFzdGVyLCBkZWZhdWx0XG4gICAgICogICAgICAgICAgLSAnbWVkaXVtJyAtIHdyaXRlIG9wZXJhdGlvbnMgZ28gdGhyb3VnaCBkeW5hbWljYWxseSBzZWxlY3RlZCBsZWFkZXIsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgbWF5IGJlIGluY29uc2lzdGVudCBmb3IgYSBzaG9ydCBwZXJpb2Qgb2YgdGltZSBpbiBjYXNlIG9mIGxlYWRlciBjaGFuZ2VcbiAgICAgKiAgICAgICAgICAtICdzdHJvbmcnIC0gV3JpdGUgb3BlcmF0aW9ucyBnbyB0aHJvdWdoIHRoZSBwZXJtYW5lbnQgbGVhZGVyLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIGNvbnNpc3RlbnQsIGJ1dCBtYXkgYmUgdW5hdmFpbGFibGUgaWYgbGVhZGVyIGlzIGRvd25cbiAgICAgKiAgICAgLSBwb2ludHM6IEJhdGNoIG9yIGxpc3Qgb2YgcG9pbnRzIHRvIGluc2VydFxuICAgICAqIEByZXR1cm5zIE9wZXJhdGlvbiByZXN1bHRcbiAgICAgKi9cbiAgICBhc3luYyB1cHNlcnQoY29sbGVjdGlvbl9uYW1lLCB7IHdhaXQgPSB0cnVlLCBvcmRlcmluZywgLi4ucG9pbnRzX29yX2JhdGNoIH0pIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9vcGVuQXBpQ2xpZW50LnVwc2VydFBvaW50cyh7XG4gICAgICAgICAgICBjb2xsZWN0aW9uX25hbWUsXG4gICAgICAgICAgICB3YWl0LFxuICAgICAgICAgICAgb3JkZXJpbmcsXG4gICAgICAgICAgICAuLi5wb2ludHNfb3JfYmF0Y2gsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWF5YmUocmVzcG9uc2UuZGF0YS5yZXN1bHQpLm9yVGhyb3coJ1Vwc2VydCByZXR1cm5lZCBlbXB0eScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSBzdG9yZWQgcG9pbnRzIGJ5IElEc1xuICAgICAqIEBwYXJhbSBjb2xsZWN0aW9uX25hbWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICAgICAqICAgICAtIHNoYXJkX2tleTogU3BlY2lmeSBpbiB3aGljaCBzaGFyZHMgdG8gbG9vayBmb3IgdGhlIHBvaW50cywgaWYgbm90IHNwZWNpZmllZCAtIGxvb2sgaW4gYWxsIHNoYXJkc1xuICAgICAqICAgICAtIGlkczogbGlzdCBvZiBJRHMgdG8gbG9va3VwXG4gICAgICogICAgIC0gd2l0aF9wYXlsb2FkOlxuICAgICAqICAgICAgICAgLSBTcGVjaWZ5IHdoaWNoIHN0b3JlZCBwYXlsb2FkIHNob3VsZCBiZSBhdHRhY2hlZCB0byB0aGUgcmVzdWx0LlxuICAgICAqICAgICAgICAgLSBJZiBgVHJ1ZWAgLSBhdHRhY2ggYWxsIHBheWxvYWRcbiAgICAgKiAgICAgICAgIC0gSWYgYEZhbHNlYCAtIGRvIG5vdCBhdHRhY2ggYW55IHBheWxvYWRcbiAgICAgKiAgICAgICAgIC0gSWYgTGlzdCBvZiBzdHJpbmcgLSBpbmNsdWRlIG9ubHkgc3BlY2lmaWVkIGZpZWxkc1xuICAgICAqICAgICAgICAgLSBJZiBgUGF5bG9hZFNlbGVjdG9yYCAtIHVzZSBleHBsaWNpdCBydWxlc1xuICAgICAqICAgICAgICAgLSBEZWZhdWx0OiBgdHJ1ZWBcbiAgICAgKiAgICAgLSB3aXRoX3ZlY3RvcjpcbiAgICAgKiAgICAgICAgIC0gSWYgYFRydWVgIC0gQXR0YWNoIHN0b3JlZCB2ZWN0b3IgdG8gdGhlIHNlYXJjaCByZXN1bHQuXG4gICAgICogICAgICAgICAtIElmIGBGYWxzZWAgLSBEbyBub3QgYXR0YWNoIHZlY3Rvci5cbiAgICAgKiAgICAgICAgIC0gSWYgTGlzdCBvZiBzdHJpbmcgLSBBdHRhY2ggb25seSBzcGVjaWZpZWQgdmVjdG9ycy5cbiAgICAgKiAgICAgICAgIC0gRGVmYXVsdDogYGZhbHNlYFxuICAgICAqICAgICAtIGNvbnNpc3RlbmN5OlxuICAgICAqICAgICAgICAgUmVhZCBjb25zaXN0ZW5jeSBvZiB0aGUgc2VhcmNoLiBEZWZpbmVzIGhvdyBtYW55IHJlcGxpY2FzIHNob3VsZCBiZSBxdWVyaWVkIGJlZm9yZSByZXR1cm5pbmcgdGhlIHJlc3VsdC5cbiAgICAgKiAgICAgICAgICAgICBWYWx1ZXM6XG4gICAgICogICAgICAgICAgICAgICAgIC0gbnVtYmVyIC0gbnVtYmVyIG9mIHJlcGxpY2FzIHRvIHF1ZXJ5LCB2YWx1ZXMgc2hvdWxkIHByZXNlbnQgaW4gYWxsIHF1ZXJpZWQgcmVwbGljYXNcbiAgICAgKiAgICAgICAgICAgICAgICAgLSAnbWFqb3JpdHknIC0gcXVlcnkgYWxsIHJlcGxpY2FzLCBidXQgcmV0dXJuIHZhbHVlcyBwcmVzZW50IGluIHRoZSBtYWpvcml0eSBvZiByZXBsaWNhc1xuICAgICAqICAgICAgICAgICAgICAgICAtICdxdW9ydW0nIC0gcXVlcnkgdGhlIG1ham9yaXR5IG9mIHJlcGxpY2FzLCByZXR1cm4gdmFsdWVzIHByZXNlbnQgaW4gYWxsIG9mIHRoZW1cbiAgICAgKiAgICAgICAgICAgICAgICAgLSAnYWxsJyAtIHF1ZXJ5IGFsbCByZXBsaWNhcywgYW5kIHJldHVybiB2YWx1ZXMgcHJlc2VudCBpbiBhbGwgcmVwbGljYXNcbiAgICAgKiBAcmV0dXJucyBMaXN0IG9mIHBvaW50c1xuICAgICAqL1xuICAgIGFzeW5jIHJldHJpZXZlKGNvbGxlY3Rpb25fbmFtZSwgeyBzaGFyZF9rZXksIGlkcywgd2l0aF9wYXlsb2FkID0gdHJ1ZSwgd2l0aF92ZWN0b3IsIGNvbnNpc3RlbmN5LCB0aW1lb3V0LCB9KSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fb3BlbkFwaUNsaWVudC5nZXRQb2ludHMoe1xuICAgICAgICAgICAgY29sbGVjdGlvbl9uYW1lLFxuICAgICAgICAgICAgc2hhcmRfa2V5LFxuICAgICAgICAgICAgaWRzLFxuICAgICAgICAgICAgd2l0aF9wYXlsb2FkLFxuICAgICAgICAgICAgd2l0aF92ZWN0b3IsXG4gICAgICAgICAgICBjb25zaXN0ZW5jeSxcbiAgICAgICAgICAgIHRpbWVvdXQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWF5YmUocmVzcG9uc2UuZGF0YS5yZXN1bHQpLm9yVGhyb3coJ1JldHJpZXZlIEFQSSByZXR1cm5lZCBlbXB0eScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIHNlbGVjdGVkIHBvaW50cyBmcm9tIGNvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0gY29sbGVjdGlvbl9uYW1lIE5hbWUgb2YgdGhlIGNvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICAgICAqICAgICAtIHdhaXQ6IEF3YWl0IGZvciB0aGUgcmVzdWx0cyB0byBiZSBwcm9jZXNzZWQuXG4gICAgICogICAgICAgICAtIElmIGB0cnVlYCwgcmVzdWx0IHdpbGwgYmUgcmV0dXJuZWQgb25seSB3aGVuIGFsbCBjaGFuZ2VzIGFyZSBhcHBsaWVkXG4gICAgICogICAgICAgICAtIElmIGBmYWxzZWAsIHJlc3VsdCB3aWxsIGJlIHJldHVybmVkIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBjb25maXJtYXRpb24gb2YgcmVjZWl2aW5nLlxuICAgICAqICAgICAgLSBvcmRlcmluZzogRGVmaW5lIHN0cmF0ZWd5IGZvciBvcmRlcmluZyBvZiB0aGUgcG9pbnRzLiBQb3NzaWJsZSB2YWx1ZXM6XG4gICAgICogICAgICAgICAgLSAnd2VhaycgICAtIHdyaXRlIG9wZXJhdGlvbnMgbWF5IGJlIHJlb3JkZXJlZCwgd29ya3MgZmFzdGVyLCBkZWZhdWx0XG4gICAgICogICAgICAgICAgLSAnbWVkaXVtJyAtIHdyaXRlIG9wZXJhdGlvbnMgZ28gdGhyb3VnaCBkeW5hbWljYWxseSBzZWxlY3RlZCBsZWFkZXIsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgbWF5IGJlIGluY29uc2lzdGVudCBmb3IgYSBzaG9ydCBwZXJpb2Qgb2YgdGltZSBpbiBjYXNlIG9mIGxlYWRlciBjaGFuZ2VcbiAgICAgKiAgICAgICAgICAtICdzdHJvbmcnIC0gV3JpdGUgb3BlcmF0aW9ucyBnbyB0aHJvdWdoIHRoZSBwZXJtYW5lbnQgbGVhZGVyLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIGNvbnNpc3RlbnQsIGJ1dCBtYXkgYmUgdW5hdmFpbGFibGUgaWYgbGVhZGVyIGlzIGRvd25cbiAgICAgKiAgICAgLSBwb2ludHNfc2VsZWN0b3I6IExpc3Qgb2YgYWZmZWN0ZWQgcG9pbnRzLCBmaWx0ZXIgb3IgcG9pbnRzIHNlbGVjdG9yLlxuICAgICAqICAgICAgICAgRXhhbXBsZTpcbiAgICAgKiAgICAgICAgICAgICAtIGBwb2ludHM6IFtcbiAgICAgKiAgICAgICAgICAgICAgICAgICAxLCAyLCAzLCBcImNkM2I1M2YwLTExYTctNDQ5Zi1iYzUwLWQwNjMxMGU3ZWQ5MFwiXG4gICAgICogICAgICAgICAgICAgICBdYFxuICAgICAqICAgICAgICAgICAgIC0gYGZpbHRlcjoge1xuICAgICAqICAgICAgICAgICAgICAgICAgICBtdXN0OiBbXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAncmFuZF9udW1iZXInLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiB7XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGd0ZTogMC43XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAqICAgICAgICAgICAgICAgICAgICBdXG4gICAgICogICAgICAgICAgICAgICAgfWBcbiAgICAgKiBAcmV0dXJucyBPcGVyYXRpb24gcmVzdWx0XG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlKGNvbGxlY3Rpb25fbmFtZSwgeyB3YWl0LCBvcmRlcmluZywgLi4ucG9pbnRzX3NlbGVjdG9yIH0pIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9vcGVuQXBpQ2xpZW50LmRlbGV0ZVBvaW50cyh7XG4gICAgICAgICAgICBjb2xsZWN0aW9uX25hbWUsXG4gICAgICAgICAgICB3YWl0LFxuICAgICAgICAgICAgb3JkZXJpbmcsXG4gICAgICAgICAgICAuLi5wb2ludHNfc2VsZWN0b3IsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWF5YmUocmVzcG9uc2UuZGF0YS5yZXN1bHQpLm9yVGhyb3coJ0RlbGV0ZSBwb2ludHMgcmV0dXJuZWQgZW1wdHknKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBwYXlsb2FkIHZhbHVlcyBmb3Igc3BlY2lmaWVkIHBvaW50cy5cbiAgICAgKiBAcGFyYW0gY29sbGVjdGlvbl9uYW1lIE5hbWUgb2YgdGhlIGNvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICAgICAqICAgICAtIHdhaXQ6IEF3YWl0IGZvciB0aGUgcmVzdWx0cyB0byBiZSBwcm9jZXNzZWQuXG4gICAgICogICAgICAgICAtIElmIGB0cnVlYCwgcmVzdWx0IHdpbGwgYmUgcmV0dXJuZWQgb25seSB3aGVuIGFsbCBjaGFuZ2VzIGFyZSBhcHBsaWVkXG4gICAgICogICAgICAgICAtIElmIGBmYWxzZWAsIHJlc3VsdCB3aWxsIGJlIHJldHVybmVkIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBjb25maXJtYXRpb24gb2YgcmVjZWl2aW5nLlxuICAgICAqICAgICAgLSBvcmRlcmluZzogRGVmaW5lIHN0cmF0ZWd5IGZvciBvcmRlcmluZyBvZiB0aGUgcG9pbnRzLiBQb3NzaWJsZSB2YWx1ZXM6XG4gICAgICogICAgICAgICAgLSAnd2VhaycgICAtIHdyaXRlIG9wZXJhdGlvbnMgbWF5IGJlIHJlb3JkZXJlZCwgd29ya3MgZmFzdGVyLCBkZWZhdWx0XG4gICAgICogICAgICAgICAgLSAnbWVkaXVtJyAtIHdyaXRlIG9wZXJhdGlvbnMgZ28gdGhyb3VnaCBkeW5hbWljYWxseSBzZWxlY3RlZCBsZWFkZXIsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgbWF5IGJlIGluY29uc2lzdGVudCBmb3IgYSBzaG9ydCBwZXJpb2Qgb2YgdGltZSBpbiBjYXNlIG9mIGxlYWRlciBjaGFuZ2VcbiAgICAgKiAgICAgICAgICAtICdzdHJvbmcnIC0gV3JpdGUgb3BlcmF0aW9ucyBnbyB0aHJvdWdoIHRoZSBwZXJtYW5lbnQgbGVhZGVyLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIGNvbnNpc3RlbnQsIGJ1dCBtYXkgYmUgdW5hdmFpbGFibGUgaWYgbGVhZGVyIGlzIGRvd25cbiAgICAgKiAgICAgLSBwYXlsb2FkOiBLZXktdmFsdWUgcGFpcnMgb2YgcGF5bG9hZCB0byBhc3NpZ25cbiAgICAgKiAgICAgLSBzaGFyZF9rZXk6IFNwZWNpZnkgaW4gd2hpY2ggc2hhcmRzIHRvIGxvb2sgZm9yIHRoZSBwb2ludHMsIGlmIG5vdCBzcGVjaWZpZWQgLSBsb29rIGluIGFsbCBzaGFyZHNcbiAgICAgKiAgICAgLSBrZXk6IEFzc2lnbnMgcGF5bG9hZCB0byBlYWNoIHBvaW50IHRoYXQgc2F0aXNmeSB0aGlzIHBhdGggb2YgcHJvcGVydHlcbiAgICAgKiAgICAgLSBwb2ludHN8ZmlsdGVyOiBMaXN0IG9mIGFmZmVjdGVkIHBvaW50cywgZmlsdGVyIG9yIHBvaW50cyBzZWxlY3Rvci5cbiAgICAgKiAgICAgICAgIEV4YW1wbGU6XG4gICAgICogICAgICAgICAgICAgLSBgcG9pbnRzOiBbXG4gICAgICogICAgICAgICAgICAgICAgICAgMSwgMiwgMywgXCJjZDNiNTNmMC0xMWE3LTQ0OWYtYmM1MC1kMDYzMTBlN2VkOTBcIlxuICAgICAqICAgICAgICAgICAgICAgXWBcbiAgICAgKiAgICAgICAgICAgICAtIGBmaWx0ZXI6IHtcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgbXVzdDogW1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ3JhbmRfbnVtYmVyJyxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZToge1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBndGU6IDAuN1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAqICAgICAgICAgICAgICAgIH1gXG4gICAgICogQHJldHVybnMgT3BlcmF0aW9uIHJlc3VsdFxuICAgICAqL1xuICAgIGFzeW5jIHNldFBheWxvYWQoY29sbGVjdGlvbl9uYW1lLCB7IHBheWxvYWQsIHBvaW50cywgZmlsdGVyLCBzaGFyZF9rZXksIGtleSwgb3JkZXJpbmcsIHdhaXQgPSB0cnVlLCB9KSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fb3BlbkFwaUNsaWVudC5zZXRQYXlsb2FkKHtcbiAgICAgICAgICAgIGNvbGxlY3Rpb25fbmFtZSxcbiAgICAgICAgICAgIHBheWxvYWQsXG4gICAgICAgICAgICBwb2ludHMsXG4gICAgICAgICAgICBmaWx0ZXIsXG4gICAgICAgICAgICBzaGFyZF9rZXksXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICB3YWl0LFxuICAgICAgICAgICAgb3JkZXJpbmcsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWF5YmUocmVzcG9uc2UuZGF0YS5yZXN1bHQpLm9yVGhyb3coJ1NldCBwYXlsb2FkIHJldHVybmVkIGVtcHR5Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJ3cml0ZXMgcGF5bG9hZCBvZiB0aGUgc3BlY2lmaWVkIHBvaW50c1xuICAgICAqIEFmdGVyIHRoaXMgb3BlcmF0aW9uIGlzIGFwcGxpZWQsIG9ubHkgdGhlIHNwZWNpZmllZCBwYXlsb2FkIHdpbGwgYmUgcHJlc2VudCBpbiB0aGUgcG9pbnQuXG4gICAgICogVGhlIGV4aXN0aW5nIHBheWxvYWQsIGV2ZW4gaWYgdGhlIGtleSBpcyBub3Qgc3BlY2lmaWVkIGluIHRoZSBwYXlsb2FkLCB3aWxsIGJlIGRlbGV0ZWQuXG4gICAgICogQHBhcmFtIGNvbGxlY3Rpb25fbmFtZSBOYW1lIG9mIHRoZSBjb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAgICAgKiAgICAgLSB3YWl0OiBBd2FpdCBmb3IgdGhlIHJlc3VsdHMgdG8gYmUgcHJvY2Vzc2VkLlxuICAgICAqICAgICAgICAgLSBJZiBgdHJ1ZWAsIHJlc3VsdCB3aWxsIGJlIHJldHVybmVkIG9ubHkgd2hlbiBhbGwgY2hhbmdlcyBhcmUgYXBwbGllZFxuICAgICAqICAgICAgICAgLSBJZiBgZmFsc2VgLCByZXN1bHQgd2lsbCBiZSByZXR1cm5lZCBpbW1lZGlhdGVseSBhZnRlciB0aGUgY29uZmlybWF0aW9uIG9mIHJlY2VpdmluZy5cbiAgICAgKiAgICAgIC0gb3JkZXJpbmc6IERlZmluZSBzdHJhdGVneSBmb3Igb3JkZXJpbmcgb2YgdGhlIHBvaW50cy4gUG9zc2libGUgdmFsdWVzOlxuICAgICAqICAgICAgICAgIC0gJ3dlYWsnICAgLSB3cml0ZSBvcGVyYXRpb25zIG1heSBiZSByZW9yZGVyZWQsIHdvcmtzIGZhc3RlciwgZGVmYXVsdFxuICAgICAqICAgICAgICAgIC0gJ21lZGl1bScgLSB3cml0ZSBvcGVyYXRpb25zIGdvIHRocm91Z2ggZHluYW1pY2FsbHkgc2VsZWN0ZWQgbGVhZGVyLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIG1heSBiZSBpbmNvbnNpc3RlbnQgZm9yIGEgc2hvcnQgcGVyaW9kIG9mIHRpbWUgaW4gY2FzZSBvZiBsZWFkZXIgY2hhbmdlXG4gICAgICogICAgICAgICAgLSAnc3Ryb25nJyAtIFdyaXRlIG9wZXJhdGlvbnMgZ28gdGhyb3VnaCB0aGUgcGVybWFuZW50IGxlYWRlcixcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICBjb25zaXN0ZW50LCBidXQgbWF5IGJlIHVuYXZhaWxhYmxlIGlmIGxlYWRlciBpcyBkb3duXG4gICAgICogICAgIC0gcGF5bG9hZDogS2V5LXZhbHVlIHBhaXJzIG9mIHBheWxvYWQgdG8gYXNzaWduXG4gICAgICogICAgIC0gc2hhcmRfa2V5OiBTcGVjaWZ5IGluIHdoaWNoIHNoYXJkcyB0byBsb29rIGZvciB0aGUgcG9pbnRzLCBpZiBub3Qgc3BlY2lmaWVkIC0gbG9vayBpbiBhbGwgc2hhcmRzXG4gICAgICogICAgIC0ga2V5OiBBc3NpZ25zIHBheWxvYWQgdG8gZWFjaCBwb2ludCB0aGF0IHNhdGlzZnkgdGhpcyBwYXRoIG9mIHByb3BlcnR5XG4gICAgICogICAgIC0gcG9pbnRzfGZpbHRlcjogTGlzdCBvZiBhZmZlY3RlZCBwb2ludHMsIGZpbHRlciBvciBwb2ludHMgc2VsZWN0b3IuXG4gICAgICogICAgICAgICBFeGFtcGxlOlxuICAgICAqICAgICAgICAgICAgIC0gYHBvaW50czogW1xuICAgICAqICAgICAgICAgICAgICAgICAgIDEsIDIsIDMsIFwiY2QzYjUzZjAtMTFhNy00NDlmLWJjNTAtZDA2MzEwZTdlZDkwXCJcbiAgICAgKiAgICAgICAgICAgICAgIF1gXG4gICAgICogICAgICAgICAgICAgLSBgZmlsdGVyOiB7XG4gICAgICogICAgICAgICAgICAgICAgICAgIG11c3Q6IFtcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdyYW5kX251bWJlcicsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHtcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3RlOiAwLjdcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICogICAgICAgICAgICAgICAgICAgIF1cbiAgICAgKiAgICAgICAgICAgICAgICB9YFxuICAgICAqIEByZXR1cm5zIE9wZXJhdGlvbiByZXN1bHRcbiAgICAgKi9cbiAgICBhc3luYyBvdmVyd3JpdGVQYXlsb2FkKGNvbGxlY3Rpb25fbmFtZSwgeyBvcmRlcmluZywgcGF5bG9hZCwgcG9pbnRzLCBmaWx0ZXIsIHNoYXJkX2tleSwga2V5LCB3YWl0ID0gdHJ1ZSwgfSkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX29wZW5BcGlDbGllbnQub3ZlcndyaXRlUGF5bG9hZCh7XG4gICAgICAgICAgICBjb2xsZWN0aW9uX25hbWUsXG4gICAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgICAgcG9pbnRzLFxuICAgICAgICAgICAgZmlsdGVyLFxuICAgICAgICAgICAgc2hhcmRfa2V5LFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgd2FpdCxcbiAgICAgICAgICAgIG9yZGVyaW5nLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1heWJlKHJlc3BvbnNlLmRhdGEucmVzdWx0KS5vclRocm93KCdPdmVyd3JpdGUgcGF5bG9hZCByZXR1cm5lZCBlbXB0eScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdmFsdWVzIGZyb20gcG9pbnQncyBwYXlsb2FkXG4gICAgICogQHBhcmFtIGNvbGxlY3Rpb25fbmFtZSBOYW1lIG9mIHRoZSBjb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAgICAgKiAgICAgLSB3YWl0OiBBd2FpdCBmb3IgdGhlIHJlc3VsdHMgdG8gYmUgcHJvY2Vzc2VkLlxuICAgICAqICAgICAgICAgLSBJZiBgdHJ1ZWAsIHJlc3VsdCB3aWxsIGJlIHJldHVybmVkIG9ubHkgd2hlbiBhbGwgY2hhbmdlcyBhcmUgYXBwbGllZFxuICAgICAqICAgICAgICAgLSBJZiBgZmFsc2VgLCByZXN1bHQgd2lsbCBiZSByZXR1cm5lZCBpbW1lZGlhdGVseSBhZnRlciB0aGUgY29uZmlybWF0aW9uIG9mIHJlY2VpdmluZy5cbiAgICAgKiAgICAgIC0gb3JkZXJpbmc6IERlZmluZSBzdHJhdGVneSBmb3Igb3JkZXJpbmcgb2YgdGhlIHBvaW50cy4gUG9zc2libGUgdmFsdWVzOlxuICAgICAqICAgICAgICAgIC0gJ3dlYWsnICAgLSB3cml0ZSBvcGVyYXRpb25zIG1heSBiZSByZW9yZGVyZWQsIHdvcmtzIGZhc3RlciwgZGVmYXVsdFxuICAgICAqICAgICAgICAgIC0gJ21lZGl1bScgLSB3cml0ZSBvcGVyYXRpb25zIGdvIHRocm91Z2ggZHluYW1pY2FsbHkgc2VsZWN0ZWQgbGVhZGVyLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIG1heSBiZSBpbmNvbnNpc3RlbnQgZm9yIGEgc2hvcnQgcGVyaW9kIG9mIHRpbWUgaW4gY2FzZSBvZiBsZWFkZXIgY2hhbmdlXG4gICAgICogICAgICAgICAgLSAnc3Ryb25nJyAtIFdyaXRlIG9wZXJhdGlvbnMgZ28gdGhyb3VnaCB0aGUgcGVybWFuZW50IGxlYWRlcixcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICBjb25zaXN0ZW50LCBidXQgbWF5IGJlIHVuYXZhaWxhYmxlIGlmIGxlYWRlciBpcyBkb3duXG4gICAgICogICAgIC0ga2V5czogTGlzdCBvZiBwYXlsb2FkIGtleXMgdG8gcmVtb3ZlLlxuICAgICAqICAgICAtIHNoYXJkX2tleTogU3BlY2lmeSBpbiB3aGljaCBzaGFyZHMgdG8gbG9vayBmb3IgdGhlIHBvaW50cywgaWYgbm90IHNwZWNpZmllZCAtIGxvb2sgaW4gYWxsIHNoYXJkc1xuICAgICAqICAgICAtIHBvaW50c3xmaWx0ZXI6IExpc3Qgb2YgYWZmZWN0ZWQgcG9pbnRzLCBmaWx0ZXIgb3IgcG9pbnRzIHNlbGVjdG9yLlxuICAgICAqICAgICAgICAgRXhhbXBsZTpcbiAgICAgKiAgICAgICAgICAgICAtIGBwb2ludHM6IFtcbiAgICAgKiAgICAgICAgICAgICAgICAgICAxLCAyLCAzLCBcImNkM2I1M2YwLTExYTctNDQ5Zi1iYzUwLWQwNjMxMGU3ZWQ5MFwiXG4gICAgICogICAgICAgICAgICAgICBdYFxuICAgICAqICAgICAgICAgICAgIC0gYGZpbHRlcjoge1xuICAgICAqICAgICAgICAgICAgICAgICAgICBtdXN0OiBbXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAncmFuZF9udW1iZXInLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiB7XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGd0ZTogMC43XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAqICAgICAgICAgICAgICAgICAgICBdXG4gICAgICogICAgICAgICAgICAgICAgfWBcbiAgICAgKiBAcmV0dXJucyBPcGVyYXRpb24gcmVzdWx0XG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlUGF5bG9hZChjb2xsZWN0aW9uX25hbWUsIHsgb3JkZXJpbmcsIGtleXMsIHBvaW50cywgZmlsdGVyLCBzaGFyZF9rZXksIHdhaXQgPSB0cnVlLCB9KSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fb3BlbkFwaUNsaWVudC5kZWxldGVQYXlsb2FkKHtcbiAgICAgICAgICAgIGNvbGxlY3Rpb25fbmFtZSxcbiAgICAgICAgICAgIGtleXMsXG4gICAgICAgICAgICBwb2ludHMsXG4gICAgICAgICAgICBmaWx0ZXIsXG4gICAgICAgICAgICBzaGFyZF9rZXksXG4gICAgICAgICAgICB3YWl0LFxuICAgICAgICAgICAgb3JkZXJpbmcsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWF5YmUocmVzcG9uc2UuZGF0YS5yZXN1bHQpLm9yVGhyb3coJ0RlbGV0ZSBwYXlsb2FkIHJldHVybmVkIGVtcHR5Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhbGwgcGF5bG9hZCBmb3Igc2VsZWN0ZWQgcG9pbnRzXG4gICAgICogQHBhcmFtIGNvbGxlY3Rpb25fbmFtZSBOYW1lIG9mIHRoZSBjb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAgICAgKiAgICAgLSB3YWl0OiBBd2FpdCBmb3IgdGhlIHJlc3VsdHMgdG8gYmUgcHJvY2Vzc2VkLlxuICAgICAqICAgICAgICAgLSBJZiBgdHJ1ZWAsIHJlc3VsdCB3aWxsIGJlIHJldHVybmVkIG9ubHkgd2hlbiBhbGwgY2hhbmdlcyBhcmUgYXBwbGllZFxuICAgICAqICAgICAgICAgLSBJZiBgZmFsc2VgLCByZXN1bHQgd2lsbCBiZSByZXR1cm5lZCBpbW1lZGlhdGVseSBhZnRlciB0aGUgY29uZmlybWF0aW9uIG9mIHJlY2VpdmluZy5cbiAgICAgKiAgICAgIC0gb3JkZXJpbmc6IERlZmluZSBzdHJhdGVneSBmb3Igb3JkZXJpbmcgb2YgdGhlIHBvaW50cy4gUG9zc2libGUgdmFsdWVzOlxuICAgICAqICAgICAgICAgIC0gJ3dlYWsnICAgLSB3cml0ZSBvcGVyYXRpb25zIG1heSBiZSByZW9yZGVyZWQsIHdvcmtzIGZhc3RlciwgZGVmYXVsdFxuICAgICAqICAgICAgICAgIC0gJ21lZGl1bScgLSB3cml0ZSBvcGVyYXRpb25zIGdvIHRocm91Z2ggZHluYW1pY2FsbHkgc2VsZWN0ZWQgbGVhZGVyLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIG1heSBiZSBpbmNvbnNpc3RlbnQgZm9yIGEgc2hvcnQgcGVyaW9kIG9mIHRpbWUgaW4gY2FzZSBvZiBsZWFkZXIgY2hhbmdlXG4gICAgICogICAgICAgICAgLSAnc3Ryb25nJyAtIFdyaXRlIG9wZXJhdGlvbnMgZ28gdGhyb3VnaCB0aGUgcGVybWFuZW50IGxlYWRlcixcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICBjb25zaXN0ZW50LCBidXQgbWF5IGJlIHVuYXZhaWxhYmxlIGlmIGxlYWRlciBpcyBkb3duXG4gICAgICogICAgIC0gcG9pbnRzX3NlbGVjdG9yOiBMaXN0IG9mIGFmZmVjdGVkIHBvaW50cywgZmlsdGVyIG9yIHBvaW50cyBzZWxlY3Rvci5cbiAgICAgKiAgICAgICAgIEV4YW1wbGU6XG4gICAgICogICAgICAgICAgICAgLSBgcG9pbnRzOiBbXG4gICAgICogICAgICAgICAgICAgICAgICAgMSwgMiwgMywgXCJjZDNiNTNmMC0xMWE3LTQ0OWYtYmM1MC1kMDYzMTBlN2VkOTBcIlxuICAgICAqICAgICAgICAgICAgICAgXWBcbiAgICAgKiAgICAgICAgICAgICAtIGBmaWx0ZXI6IHtcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgbXVzdDogW1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ3JhbmRfbnVtYmVyJyxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZToge1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBndGU6IDAuN1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAqICAgICAgICAgICAgICAgIH1gXG4gICAgICogQHJldHVybnMgT3BlcmF0aW9uIHJlc3VsdFxuICAgICAqL1xuICAgIGFzeW5jIGNsZWFyUGF5bG9hZChjb2xsZWN0aW9uX25hbWUsIHsgb3JkZXJpbmcsIHdhaXQgPSB0cnVlLCAuLi5wb2ludHNfc2VsZWN0b3IgfSkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX29wZW5BcGlDbGllbnQuY2xlYXJQYXlsb2FkKHtcbiAgICAgICAgICAgIGNvbGxlY3Rpb25fbmFtZSxcbiAgICAgICAgICAgIHdhaXQsXG4gICAgICAgICAgICBvcmRlcmluZyxcbiAgICAgICAgICAgIC4uLnBvaW50c19zZWxlY3RvcixcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtYXliZShyZXNwb25zZS5kYXRhLnJlc3VsdCkub3JUaHJvdygnQ2xlYXIgcGF5bG9hZCByZXR1cm5lZCBlbXB0eScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPcGVyYXRpb24gZm9yIHBlcmZvcm1pbmcgY2hhbmdlcyBvZiBjb2xsZWN0aW9uIGFsaWFzZXMuXG4gICAgICogQWxpYXMgY2hhbmdlcyBhcmUgYXRvbWljLCBtZWFuaW5nIHRoYXQgbm8gY29sbGVjdGlvbiBtb2RpZmljYXRpb25zIGNhbiBoYXBwZW4gYmV0d2VlbiBhbGlhcyBvcGVyYXRpb25zLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gICAgICogICAgIC0gYWN0aW9uczogTGlzdCBvZiBvcGVyYXRpb25zIHRvIHBlcmZvcm1cbiAgICAgKiAgICAgLSB0aW1lb3V0OiBXYWl0IGZvciBvcGVyYXRpb24gY29tbWl0IHRpbWVvdXQgaW4gc2Vjb25kcy4gSWYgdGltZW91dCBpcyByZWFjaGVkLCByZXF1ZXN0IHdpbGwgcmV0dXJuIHdpdGggc2VydmljZSBlcnJvci5cbiAgICAgKiBAcmV0dXJucyBPcGVyYXRpb24gcmVzdWx0XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlQ29sbGVjdGlvbkFsaWFzZXMoeyBhY3Rpb25zLCB0aW1lb3V0IH0pIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9vcGVuQXBpQ2xpZW50LnVwZGF0ZUFsaWFzZXMoeyBhY3Rpb25zLCB0aW1lb3V0IH0pO1xuICAgICAgICByZXR1cm4gbWF5YmUocmVzcG9uc2UuZGF0YS5yZXN1bHQpLm9yVGhyb3coJ1VwZGF0ZSBhbGlhc2VzIHJldHVybmVkIGVtcHR5Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBjb2xsZWN0aW9uIGFsaWFzZXNcbiAgICAgKiBAcGFyYW0gY29sbGVjdGlvbl9uYW1lIE5hbWUgb2YgdGhlIGNvbGxlY3Rpb25cbiAgICAgKiBAcmV0dXJucyBDb2xsZWN0aW9uIGFsaWFzZXNcbiAgICAgKi9cbiAgICBhc3luYyBnZXRDb2xsZWN0aW9uQWxpYXNlcyhjb2xsZWN0aW9uX25hbWUpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9vcGVuQXBpQ2xpZW50LmdldENvbGxlY3Rpb25BbGlhc2VzKHsgY29sbGVjdGlvbl9uYW1lIH0pO1xuICAgICAgICByZXR1cm4gbWF5YmUocmVzcG9uc2UuZGF0YS5yZXN1bHQpLm9yVGhyb3coJ0dldCBjb2xsZWN0aW9uIGFsaWFzZXMgcmV0dXJuZWQgZW1wdHknKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBhbGlhc2VzXG4gICAgICogQHJldHVybnMgQWxsIGFsaWFzZXMgb2YgYWxsIGNvbGxlY3Rpb25zXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QWxpYXNlcygpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9vcGVuQXBpQ2xpZW50LmdldENvbGxlY3Rpb25zQWxpYXNlcyh7fSk7XG4gICAgICAgIHJldHVybiBtYXliZShyZXNwb25zZS5kYXRhLnJlc3VsdCkub3JUaHJvdygnR2V0IGFsaWFzZXMgcmV0dXJuZWQgZW1wdHknKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGxpc3QgbmFtZSBvZiBhbGwgZXhpc3RpbmcgY29sbGVjdGlvbnNcbiAgICAgKiBAcmV0dXJucyBMaXN0IG9mIHRoZSBjb2xsZWN0aW9uc1xuICAgICAqL1xuICAgIGFzeW5jIGdldENvbGxlY3Rpb25zKCkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX29wZW5BcGlDbGllbnQuZ2V0Q29sbGVjdGlvbnMoe30pO1xuICAgICAgICByZXR1cm4gbWF5YmUocmVzcG9uc2UuZGF0YS5yZXN1bHQpLm9yVGhyb3coJ0dldCBjb2xsZWN0aW9ucyByZXR1cm5lZCBlbXB0eScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgZGV0YWlsZWQgaW5mb3JtYXRpb24gYWJvdXQgc3BlY2lmaWVkIGV4aXN0aW5nIGNvbGxlY3Rpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2xsZWN0aW9uX25hbWUgTmFtZSBvZiB0aGUgY29sbGVjdGlvblxuICAgICAqIEByZXR1cm5zIERldGFpbGVkIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjb2xsZWN0aW9uXG4gICAgICovXG4gICAgYXN5bmMgZ2V0Q29sbGVjdGlvbihjb2xsZWN0aW9uX25hbWUpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9vcGVuQXBpQ2xpZW50LmdldENvbGxlY3Rpb24oeyBjb2xsZWN0aW9uX25hbWUgfSk7XG4gICAgICAgIHJldHVybiBtYXliZShyZXNwb25zZS5kYXRhLnJlc3VsdCkub3JUaHJvdygnR2V0IGNvbGxlY3Rpb24gcmV0dXJuZWQgZW1wdHknKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHBhcmFtZXRlcnMgb2YgdGhlIGNvbGxlY3Rpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2xsZWN0aW9uX25hbWUgTmFtZSBvZiB0aGUgY29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gICAgICogICAgIC0gb3B0aW1pemVyX2NvbmZpZzogT3ZlcnJpZGUgZm9yIG9wdGltaXplciBjb25maWd1cmF0aW9uXG4gICAgICogICAgIC0gY29sbGVjdGlvbl9wYXJhbXM6IE92ZXJyaWRlIGZvciBjb2xsZWN0aW9uIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgLSB0aW1lb3V0OiBXYWl0IGZvciBvcGVyYXRpb24gY29tbWl0IHRpbWVvdXQgaW4gc2Vjb25kcy4gSWYgdGltZW91dCBpcyByZWFjaGVkLCByZXF1ZXN0IHdpbGwgcmV0dXJuIHdpdGggc2VydmljZSBlcnJvci5cbiAgICAgKiBAcmV0dXJucyBPcGVyYXRpb24gcmVzdWx0XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlQ29sbGVjdGlvbihjb2xsZWN0aW9uX25hbWUsIGFyZ3MpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9vcGVuQXBpQ2xpZW50LnVwZGF0ZUNvbGxlY3Rpb24oe1xuICAgICAgICAgICAgY29sbGVjdGlvbl9uYW1lLFxuICAgICAgICAgICAgLi4uYXJncyxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtYXliZShyZXNwb25zZS5kYXRhLnJlc3VsdCkub3JUaHJvdygnVXBkYXRlIGNvbGxlY3Rpb24gcmV0dXJuZWQgZW1wdHknKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBjb2xsZWN0aW9uIGFuZCBhbGwgaXQncyBkYXRhXG4gICAgICogQHBhcmFtIGNvbGxlY3Rpb25fbmFtZSBOYW1lIG9mIHRoZSBjb2xsZWN0aW9uIHRvIGRlbGV0ZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gICAgICogICAgIC0gdGltZW91dDpcbiAgICAgKiAgICAgICAgIFdhaXQgZm9yIG9wZXJhdGlvbiBjb21taXQgdGltZW91dCBpbiBzZWNvbmRzLlxuICAgICAqICAgICAgICAgSWYgdGltZW91dCBpcyByZWFjaGVkLCByZXF1ZXN0IHdpbGwgcmV0dXJuIHdpdGggc2VydmljZSBlcnJvci5cbiAgICAgKiBAcmV0dXJucyBPcGVyYXRpb24gcmVzdWx0XG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlQ29sbGVjdGlvbihjb2xsZWN0aW9uX25hbWUsIGFyZ3MpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9vcGVuQXBpQ2xpZW50LmRlbGV0ZUNvbGxlY3Rpb24oeyBjb2xsZWN0aW9uX25hbWUsIC4uLmFyZ3MgfSk7XG4gICAgICAgIHJldHVybiBtYXliZShyZXNwb25zZS5kYXRhLnJlc3VsdCkub3JUaHJvdygnRGVsZXRlIGNvbGxlY3Rpb24gcmV0dXJuZWQgZW1wdHknKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGVtcHR5IGNvbGxlY3Rpb24gd2l0aCBnaXZlbiBwYXJhbWV0ZXJzXG4gICAgICogQHJldHVybnMgT3BlcmF0aW9uIHJlc3VsdFxuICAgICAqIEBwYXJhbSBjb2xsZWN0aW9uTmFtZSBOYW1lIG9mIHRoZSBjb2xsZWN0aW9uIHRvIHJlY3JlYXRlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAgICAgKiAgICAgLSB2ZWN0b3JzX2NvbmZpZzpcbiAgICAgKiAgICAgICAgIENvbmZpZ3VyYXRpb24gb2YgdGhlIHZlY3RvciBzdG9yYWdlLiBWZWN0b3IgcGFyYW1zIGNvbnRhaW5zIHNpemUgYW5kIGRpc3RhbmNlIGZvciB0aGUgdmVjdG9yIHN0b3JhZ2UuXG4gICAgICogICAgICAgICBJZiBkaWN0IGlzIHBhc3NlZCwgc2VydmljZSB3aWxsIGNyZWF0ZSBhIHZlY3RvciBzdG9yYWdlIGZvciBlYWNoIGtleSBpbiB0aGUgZGljdC5cbiAgICAgKiAgICAgICAgIElmIHNpbmdsZSBWZWN0b3JQYXJhbXMgaXMgcGFzc2VkLCBzZXJ2aWNlIHdpbGwgY3JlYXRlIGEgc2luZ2xlIGFub255bW91cyB2ZWN0b3Igc3RvcmFnZS5cbiAgICAgKiAgICAgLSBzaGFyZF9udW1iZXI6IE51bWJlciBvZiBzaGFyZHMgaW4gY29sbGVjdGlvbi4gRGVmYXVsdCBpcyAxLCBtaW5pbXVtIGlzIDEuXG4gICAgICogICAgIC0gc2hhcmRpbmdfbWV0aG9kOiBTaGFyZGluZyBtZXRob2QgRGVmYXVsdCBpcyBBdXRvIC0gcG9pbnRzIGFyZSBkaXN0cmlidXRlZCBhY3Jvc3MgYWxsIGF2YWlsYWJsZSBzaGFyZHMgQ3VzdG9tIC0gcG9pbnRzIGFyZSBkaXN0cmlidXRlZCBhY3Jvc3Mgc2hhcmRzIGFjY29yZGluZyB0byBzaGFyZCBrZXlcbiAgICAgKiAgICAgLSByZXBsaWNhdGlvbl9mYWN0b3I6XG4gICAgICogICAgICAgICBSZXBsaWNhdGlvbiBmYWN0b3IgZm9yIGNvbGxlY3Rpb24uIERlZmF1bHQgaXMgMSwgbWluaW11bSBpcyAxLlxuICAgICAqICAgICAgICAgRGVmaW5lcyBob3cgbWFueSBjb3BpZXMgb2YgZWFjaCBzaGFyZCB3aWxsIGJlIGNyZWF0ZWQuXG4gICAgICogICAgICAgICBIYXZlIGVmZmVjdCBvbmx5IGluIGRpc3RyaWJ1dGVkIG1vZGUuXG4gICAgICogICAgIC0gd3JpdGVfY29uc2lzdGVuY3lfZmFjdG9yOlxuICAgICAqICAgICAgICAgV3JpdGUgY29uc2lzdGVuY3kgZmFjdG9yIGZvciBjb2xsZWN0aW9uLiBEZWZhdWx0IGlzIDEsIG1pbmltdW0gaXMgMS5cbiAgICAgKiAgICAgICAgIERlZmluZXMgaG93IG1hbnkgcmVwbGljYXMgc2hvdWxkIGFwcGx5IHRoZSBvcGVyYXRpb24gZm9yIHVzIHRvIGNvbnNpZGVyIGl0IHN1Y2Nlc3NmdWwuXG4gICAgICogICAgICAgICBJbmNyZWFzaW5nIHRoaXMgbnVtYmVyIHdpbGwgbWFrZSB0aGUgY29sbGVjdGlvbiBtb3JlIHJlc2lsaWVudCB0byBpbmNvbnNpc3RlbmNpZXMsIGJ1dCB3aWxsXG4gICAgICogICAgICAgICBhbHNvIG1ha2UgaXQgZmFpbCBpZiBub3QgZW5vdWdoIHJlcGxpY2FzIGFyZSBhdmFpbGFibGUuXG4gICAgICogICAgICAgICBEb2VzIG5vdCBoYXZlIGFueSBwZXJmb3JtYW5jZSBpbXBhY3QuXG4gICAgICogICAgICAgICBIYXZlIGVmZmVjdCBvbmx5IGluIGRpc3RyaWJ1dGVkIG1vZGUuXG4gICAgICogICAgIC0gb25fZGlza19wYXlsb2FkOlxuICAgICAqICAgICAgICAgSWYgdHJ1ZSAtIHBvaW50YHMgcGF5bG9hZCB3aWxsIG5vdCBiZSBzdG9yZWQgaW4gbWVtb3J5LlxuICAgICAqICAgICAgICAgSXQgd2lsbCBiZSByZWFkIGZyb20gdGhlIGRpc2sgZXZlcnkgdGltZSBpdCBpcyByZXF1ZXN0ZWQuXG4gICAgICogICAgICAgICBUaGlzIHNldHRpbmcgc2F2ZXMgUkFNIGJ5IChzbGlnaHRseSkgaW5jcmVhc2luZyB0aGUgcmVzcG9uc2UgdGltZS5cbiAgICAgKiAgICAgICAgIE5vdGU6IHRob3NlIHBheWxvYWQgdmFsdWVzIHRoYXQgYXJlIGludm9sdmVkIGluIGZpbHRlcmluZyBhbmQgYXJlIGluZGV4ZWQgLSByZW1haW4gaW4gUkFNLlxuICAgICAqICAgICAtIGhuc3dfY29uZmlnOiBQYXJhbXMgZm9yIEhOU1cgaW5kZXhcbiAgICAgKiAgICAgLSBvcHRpbWl6ZXJzX2NvbmZpZzogUGFyYW1zIGZvciBvcHRpbWl6ZXJcbiAgICAgKiAgICAgLSB3YWxfY29uZmlnOiBQYXJhbXMgZm9yIFdyaXRlLUFoZWFkLUxvZ1xuICAgICAqICAgICAtIHF1YW50aXphdGlvbl9jb25maWc6IFBhcmFtcyBmb3IgcXVhbnRpemF0aW9uLCBpZiBOb25lIC0gcXVhbnRpemF0aW9uIHdpbGwgYmUgZGlzYWJsZWRcbiAgICAgKiAgICAgLSBpbml0X2Zyb206IFVzZSBkYXRhIHN0b3JlZCBpbiBhbm90aGVyIGNvbGxlY3Rpb24gdG8gaW5pdGlhbGl6ZSB0aGlzIGNvbGxlY3Rpb25cbiAgICAgKiAgICAgLSBzcGFyc2VfdmVjdG9yczogU3BhcnNlIHZlY3RvciBkYXRhIGNvbmZpZ1xuICAgICAqICAgICAtIHN0cmljdF9tb2RlX2NvbmZpZzogU3RyaWN0IG1vZGUgY29uZmlndXJhdGlvblxuICAgICAqICAgICAtIHRpbWVvdXQ6XG4gICAgICogICAgICAgICBXYWl0IGZvciBvcGVyYXRpb24gY29tbWl0IHRpbWVvdXQgaW4gc2Vjb25kcy5cbiAgICAgKiAgICAgICAgIElmIHRpbWVvdXQgaXMgcmVhY2hlZCwgcmVxdWVzdCB3aWxsIHJldHVybiB3aXRoIHNlcnZpY2UgZXJyb3IuXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlQ29sbGVjdGlvbihjb2xsZWN0aW9uX25hbWUsIHsgdGltZW91dCwgdmVjdG9ycywgaG5zd19jb25maWcsIGluaXRfZnJvbSwgb25fZGlza19wYXlsb2FkLCBvcHRpbWl6ZXJzX2NvbmZpZywgcXVhbnRpemF0aW9uX2NvbmZpZywgcmVwbGljYXRpb25fZmFjdG9yLCBzaGFyZF9udW1iZXIsIHNoYXJkaW5nX21ldGhvZCwgd2FsX2NvbmZpZywgd3JpdGVfY29uc2lzdGVuY3lfZmFjdG9yLCBzcGFyc2VfdmVjdG9ycywgc3RyaWN0X21vZGVfY29uZmlnLCB9KSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fb3BlbkFwaUNsaWVudC5jcmVhdGVDb2xsZWN0aW9uKHtcbiAgICAgICAgICAgIGNvbGxlY3Rpb25fbmFtZSxcbiAgICAgICAgICAgIHRpbWVvdXQsXG4gICAgICAgICAgICB2ZWN0b3JzLFxuICAgICAgICAgICAgaG5zd19jb25maWcsXG4gICAgICAgICAgICBpbml0X2Zyb20sXG4gICAgICAgICAgICBvbl9kaXNrX3BheWxvYWQsXG4gICAgICAgICAgICBvcHRpbWl6ZXJzX2NvbmZpZyxcbiAgICAgICAgICAgIHF1YW50aXphdGlvbl9jb25maWcsXG4gICAgICAgICAgICByZXBsaWNhdGlvbl9mYWN0b3IsXG4gICAgICAgICAgICBzaGFyZF9udW1iZXIsXG4gICAgICAgICAgICBzaGFyZGluZ19tZXRob2QsXG4gICAgICAgICAgICB3YWxfY29uZmlnLFxuICAgICAgICAgICAgd3JpdGVfY29uc2lzdGVuY3lfZmFjdG9yLFxuICAgICAgICAgICAgc3BhcnNlX3ZlY3RvcnMsXG4gICAgICAgICAgICBzdHJpY3RfbW9kZV9jb25maWcsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWF5YmUocmVzcG9uc2UuZGF0YS5yZXN1bHQpLm9yVGhyb3coJ0NyZWF0ZSBjb2xsZWN0aW9uIHJldHVybmVkIGVtcHR5Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhbmQgY3JlYXRlIGVtcHR5IGNvbGxlY3Rpb24gd2l0aCBnaXZlbiBwYXJhbWV0ZXJzXG4gICAgICogQHJldHVybnMgT3BlcmF0aW9uIHJlc3VsdFxuICAgICAqIEBwYXJhbSBjb2xsZWN0aW9uTmFtZSBOYW1lIG9mIHRoZSBjb2xsZWN0aW9uIHRvIHJlY3JlYXRlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAgICAgKiAgICAgLSB2ZWN0b3JzQ29uZmlnOlxuICAgICAqICAgICAgICAgQ29uZmlndXJhdGlvbiBvZiB0aGUgdmVjdG9yIHN0b3JhZ2UuIFZlY3RvciBwYXJhbXMgY29udGFpbnMgc2l6ZSBhbmQgZGlzdGFuY2UgZm9yIHRoZSB2ZWN0b3Igc3RvcmFnZS5cbiAgICAgKiAgICAgICAgIElmIGRpY3QgaXMgcGFzc2VkLCBzZXJ2aWNlIHdpbGwgY3JlYXRlIGEgdmVjdG9yIHN0b3JhZ2UgZm9yIGVhY2gga2V5IGluIHRoZSBkaWN0LlxuICAgICAqICAgICAgICAgSWYgc2luZ2xlIFZlY3RvclBhcmFtcyBpcyBwYXNzZWQsIHNlcnZpY2Ugd2lsbCBjcmVhdGUgYSBzaW5nbGUgYW5vbnltb3VzIHZlY3RvciBzdG9yYWdlLlxuICAgICAqICAgICAtIHNoYXJkTnVtYmVyOiBOdW1iZXIgb2Ygc2hhcmRzIGluIGNvbGxlY3Rpb24uIERlZmF1bHQgaXMgMSwgbWluaW11bSBpcyAxLlxuICAgICAqICAgICAtIHNoYXJkaW5nX21ldGhvZDogU2hhcmRpbmcgbWV0aG9kIERlZmF1bHQgaXMgQXV0byAtIHBvaW50cyBhcmUgZGlzdHJpYnV0ZWQgYWNyb3NzIGFsbCBhdmFpbGFibGUgc2hhcmRzIEN1c3RvbSAtIHBvaW50cyBhcmUgZGlzdHJpYnV0ZWQgYWNyb3NzIHNoYXJkcyBhY2NvcmRpbmcgdG8gc2hhcmQga2V5XG4gICAgICogICAgIC0gcmVwbGljYXRpb25GYWN0b3I6XG4gICAgICogICAgICAgICBSZXBsaWNhdGlvbiBmYWN0b3IgZm9yIGNvbGxlY3Rpb24uIERlZmF1bHQgaXMgMSwgbWluaW11bSBpcyAxLlxuICAgICAqICAgICAgICAgRGVmaW5lcyBob3cgbWFueSBjb3BpZXMgb2YgZWFjaCBzaGFyZCB3aWxsIGJlIGNyZWF0ZWQuXG4gICAgICogICAgICAgICBIYXZlIGVmZmVjdCBvbmx5IGluIGRpc3RyaWJ1dGVkIG1vZGUuXG4gICAgICogICAgIC0gd3JpdGVDb25zaXN0ZW5jeUZhY3RvcjpcbiAgICAgKiAgICAgICAgIFdyaXRlIGNvbnNpc3RlbmN5IGZhY3RvciBmb3IgY29sbGVjdGlvbi4gRGVmYXVsdCBpcyAxLCBtaW5pbXVtIGlzIDEuXG4gICAgICogICAgICAgICBEZWZpbmVzIGhvdyBtYW55IHJlcGxpY2FzIHNob3VsZCBhcHBseSB0aGUgb3BlcmF0aW9uIGZvciB1cyB0byBjb25zaWRlciBpdCBzdWNjZXNzZnVsLlxuICAgICAqICAgICAgICAgSW5jcmVhc2luZyB0aGlzIG51bWJlciB3aWxsIG1ha2UgdGhlIGNvbGxlY3Rpb24gbW9yZSByZXNpbGllbnQgdG8gaW5jb25zaXN0ZW5jaWVzLCBidXQgd2lsbFxuICAgICAqICAgICAgICAgYWxzbyBtYWtlIGl0IGZhaWwgaWYgbm90IGVub3VnaCByZXBsaWNhcyBhcmUgYXZhaWxhYmxlLlxuICAgICAqICAgICAgICAgRG9lcyBub3QgaGF2ZSBhbnkgcGVyZm9ybWFuY2UgaW1wYWN0LlxuICAgICAqICAgICAgICAgSGF2ZSBlZmZlY3Qgb25seSBpbiBkaXN0cmlidXRlZCBtb2RlLlxuICAgICAqICAgICAtIG9uRGlza1BheWxvYWQ6XG4gICAgICogICAgICAgICBJZiB0cnVlIC0gcG9pbnRgcyBwYXlsb2FkIHdpbGwgbm90IGJlIHN0b3JlZCBpbiBtZW1vcnkuXG4gICAgICogICAgICAgICBJdCB3aWxsIGJlIHJlYWQgZnJvbSB0aGUgZGlzayBldmVyeSB0aW1lIGl0IGlzIHJlcXVlc3RlZC5cbiAgICAgKiAgICAgICAgIFRoaXMgc2V0dGluZyBzYXZlcyBSQU0gYnkgKHNsaWdodGx5KSBpbmNyZWFzaW5nIHRoZSByZXNwb25zZSB0aW1lLlxuICAgICAqICAgICAgICAgTm90ZTogdGhvc2UgcGF5bG9hZCB2YWx1ZXMgdGhhdCBhcmUgaW52b2x2ZWQgaW4gZmlsdGVyaW5nIGFuZCBhcmUgaW5kZXhlZCAtIHJlbWFpbiBpbiBSQU0uXG4gICAgICogICAgIC0gaG5zd0NvbmZpZzogUGFyYW1zIGZvciBITlNXIGluZGV4XG4gICAgICogICAgIC0gb3B0aW1pemVyc0NvbmZpZzogUGFyYW1zIGZvciBvcHRpbWl6ZXJcbiAgICAgKiAgICAgLSB3YWxDb25maWc6IFBhcmFtcyBmb3IgV3JpdGUtQWhlYWQtTG9nXG4gICAgICogICAgIC0gcXVhbnRpemF0aW9uQ29uZmlnOiBQYXJhbXMgZm9yIHF1YW50aXphdGlvbiwgaWYgTm9uZSAtIHF1YW50aXphdGlvbiB3aWxsIGJlIGRpc2FibGVkXG4gICAgICogICAgIC0gaW5pdEZyb206IFVzZSBkYXRhIHN0b3JlZCBpbiBhbm90aGVyIGNvbGxlY3Rpb24gdG8gaW5pdGlhbGl6ZSB0aGlzIGNvbGxlY3Rpb25cbiAgICAgKiAgICAgLSBzcGFyc2VfdmVjdG9yczogU3BhcnNlIHZlY3RvciBkYXRhIGNvbmZpZ1xuICAgICAqICAgICAtIHN0cmljdF9tb2RlX2NvbmZpZzogU3RyaWN0IG1vZGUgY29uZmlndXJhdGlvblxuICAgICAqICAgICAtIHRpbWVvdXQ6XG4gICAgICogICAgICAgICBXYWl0IGZvciBvcGVyYXRpb24gY29tbWl0IHRpbWVvdXQgaW4gc2Vjb25kcy5cbiAgICAgKiAgICAgICAgIElmIHRpbWVvdXQgaXMgcmVhY2hlZCwgcmVxdWVzdCB3aWxsIHJldHVybiB3aXRoIHNlcnZpY2UgZXJyb3IuXG4gICAgICovXG4gICAgYXN5bmMgcmVjcmVhdGVDb2xsZWN0aW9uKGNvbGxlY3Rpb25fbmFtZSwgeyB0aW1lb3V0LCB2ZWN0b3JzLCBobnN3X2NvbmZpZywgaW5pdF9mcm9tLCBvbl9kaXNrX3BheWxvYWQsIG9wdGltaXplcnNfY29uZmlnLCBxdWFudGl6YXRpb25fY29uZmlnLCByZXBsaWNhdGlvbl9mYWN0b3IsIHNoYXJkX251bWJlciwgc2hhcmRpbmdfbWV0aG9kLCB3YWxfY29uZmlnLCB3cml0ZV9jb25zaXN0ZW5jeV9mYWN0b3IsIHNwYXJzZV92ZWN0b3JzLCBzdHJpY3RfbW9kZV9jb25maWcsIH0pIHtcbiAgICAgICAgbWF5YmUoYXdhaXQgdGhpcy5fb3BlbkFwaUNsaWVudC5kZWxldGVDb2xsZWN0aW9uKHtcbiAgICAgICAgICAgIGNvbGxlY3Rpb25fbmFtZSxcbiAgICAgICAgICAgIHRpbWVvdXQsXG4gICAgICAgIH0pKVxuICAgICAgICAgICAgLmdldCgnb2snKVxuICAgICAgICAgICAgLm9yVGhyb3coJ0RlbGV0ZSBjb2xsZWN0aW9uIHJldHVybmVkIGZhaWxlZCcpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX29wZW5BcGlDbGllbnQuY3JlYXRlQ29sbGVjdGlvbih7XG4gICAgICAgICAgICBjb2xsZWN0aW9uX25hbWUsXG4gICAgICAgICAgICB0aW1lb3V0LFxuICAgICAgICAgICAgdmVjdG9ycyxcbiAgICAgICAgICAgIGhuc3dfY29uZmlnLFxuICAgICAgICAgICAgaW5pdF9mcm9tLFxuICAgICAgICAgICAgb25fZGlza19wYXlsb2FkLFxuICAgICAgICAgICAgb3B0aW1pemVyc19jb25maWcsXG4gICAgICAgICAgICBxdWFudGl6YXRpb25fY29uZmlnLFxuICAgICAgICAgICAgcmVwbGljYXRpb25fZmFjdG9yLFxuICAgICAgICAgICAgc2hhcmRfbnVtYmVyLFxuICAgICAgICAgICAgc2hhcmRpbmdfbWV0aG9kLFxuICAgICAgICAgICAgd2FsX2NvbmZpZyxcbiAgICAgICAgICAgIHdyaXRlX2NvbnNpc3RlbmN5X2ZhY3RvcixcbiAgICAgICAgICAgIHNwYXJzZV92ZWN0b3JzLFxuICAgICAgICAgICAgc3RyaWN0X21vZGVfY29uZmlnLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1heWJlKHJlc3BvbnNlKS5vclRocm93KCdDcmVhdGUgY29sbGVjdGlvbiByZXR1cm5lZCBlbXB0eScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGluZGV4IGZvciBhIGdpdmVuIHBheWxvYWQgZmllbGQuXG4gICAgICogSW5kZXhlZCBmaWVsZHMgYWxsb3cgdG8gcGVyZm9ybSBmaWx0ZXJlZCBzZWFyY2ggb3BlcmF0aW9ucyBmYXN0ZXIuXG4gICAgICogQHBhcmFtIGNvbGxlY3Rpb25OYW1lIE5hbWUgb2YgdGhlIGNvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICAgICAqICAgICAtIGZpZWxkTmFtZTogTmFtZSBvZiB0aGUgcGF5bG9hZCBmaWVsZC5cbiAgICAgKiAgICAgLSBmaWVsZFNjaGVtYTogVHlwZSBvZiBkYXRhIHRvIGluZGV4LlxuICAgICAqICAgICAtIHdhaXQ6IEF3YWl0IGZvciB0aGUgcmVzdWx0cyB0byBiZSBwcm9jZXNzZWQuXG4gICAgICogICAgICAgICAtIElmIGB0cnVlYCwgcmVzdWx0IHdpbGwgYmUgcmV0dXJuZWQgb25seSB3aGVuIGFsbCBjaGFuZ2VzIGFyZSBhcHBsaWVkXG4gICAgICogICAgICAgICAtIElmIGBmYWxzZWAsIHJlc3VsdCB3aWxsIGJlIHJldHVybmVkIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBjb25maXJtYXRpb24gb2YgcmVjZWl2aW5nLlxuICAgICAqICAgICAtIG9yZGVyaW5nOlxuICAgICAqICAgICAgICAgRGVmaW5lIHN0cmF0ZWd5IGZvciBvcmRlcmluZyBvZiB0aGUgcG9pbnRzLiBQb3NzaWJsZSB2YWx1ZXM6XG4gICAgICogICAgICAgICAtICd3ZWFrJyAgIC0gd3JpdGUgb3BlcmF0aW9ucyBtYXkgYmUgcmVvcmRlcmVkLCB3b3JrcyBmYXN0ZXIsIGRlZmF1bHRcbiAgICAgKiAgICAgICAgIC0gJ21lZGl1bScgLSB3cml0ZSBvcGVyYXRpb25zIGdvIHRocm91Z2ggZHluYW1pY2FsbHkgc2VsZWN0ZWQgbGVhZGVyLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIG1heSBiZSBpbmNvbnNpc3RlbnQgZm9yIGEgc2hvcnQgcGVyaW9kIG9mIHRpbWUgaW4gY2FzZSBvZiBsZWFkZXIgY2hhbmdlXG4gICAgICogICAgICAgICAtICdzdHJvbmcnIC0gV3JpdGUgb3BlcmF0aW9ucyBnbyB0aHJvdWdoIHRoZSBwZXJtYW5lbnQgbGVhZGVyLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIGNvbnNpc3RlbnQsIGJ1dCBtYXkgYmUgdW5hdmFpbGFibGUgaWYgbGVhZGVyIGlzIGRvd25cbiAgICAgKiBAcmV0dXJucyBPcGVyYXRpb24gUmVzdWx0XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlUGF5bG9hZEluZGV4KGNvbGxlY3Rpb25fbmFtZSwgeyB3YWl0LCBvcmRlcmluZywgZmllbGRfbmFtZSwgZmllbGRfc2NoZW1hLCB9KSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fb3BlbkFwaUNsaWVudC5jcmVhdGVGaWVsZEluZGV4KHtcbiAgICAgICAgICAgIGNvbGxlY3Rpb25fbmFtZSxcbiAgICAgICAgICAgIGZpZWxkX25hbWUsXG4gICAgICAgICAgICBmaWVsZF9zY2hlbWEsXG4gICAgICAgICAgICB3YWl0LFxuICAgICAgICAgICAgb3JkZXJpbmcsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWF5YmUocmVzcG9uc2UuZGF0YS5yZXN1bHQpLm9yVGhyb3coJ0NyZWF0ZSBmaWVsZCBpbmRleCByZXR1cm5lZCBlbXB0eScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGluZGV4IGZvciBhIGdpdmVuIHBheWxvYWQgZmllbGQuXG4gICAgICogQHBhcmFtIGNvbGxlY3Rpb25fbmFtZSBOYW1lIG9mIHRoZSBjb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIGZpZWxkX25hbWUgTmFtZSBvZiB0aGUgcGF5bG9hZCBmaWVsZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gICAgICogICAgIC0gd2FpdDogQXdhaXQgZm9yIHRoZSByZXN1bHRzIHRvIGJlIHByb2Nlc3NlZC5cbiAgICAgKiAgICAgICAgIC0gSWYgYHRydWVgLCByZXN1bHQgd2lsbCBiZSByZXR1cm5lZCBvbmx5IHdoZW4gYWxsIGNoYW5nZXMgYXJlIGFwcGxpZWRcbiAgICAgKiAgICAgICAgIC0gSWYgYGZhbHNlYCwgcmVzdWx0IHdpbGwgYmUgcmV0dXJuZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGNvbmZpcm1hdGlvbiBvZiByZWNlaXZpbmcuXG4gICAgICogICAgIC0gb3JkZXJpbmc6XG4gICAgICogICAgICAgICBEZWZpbmUgc3RyYXRlZ3kgZm9yIG9yZGVyaW5nIG9mIHRoZSBwb2ludHMuIFBvc3NpYmxlIHZhbHVlczpcbiAgICAgKiAgICAgICAgIC0gJ3dlYWsnICAgLSB3cml0ZSBvcGVyYXRpb25zIG1heSBiZSByZW9yZGVyZWQsIHdvcmtzIGZhc3RlciwgZGVmYXVsdFxuICAgICAqICAgICAgICAgLSAnbWVkaXVtJyAtIHdyaXRlIG9wZXJhdGlvbnMgZ28gdGhyb3VnaCBkeW5hbWljYWxseSBzZWxlY3RlZCBsZWFkZXIsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgbWF5IGJlIGluY29uc2lzdGVudCBmb3IgYSBzaG9ydCBwZXJpb2Qgb2YgdGltZSBpbiBjYXNlIG9mIGxlYWRlciBjaGFuZ2VcbiAgICAgKiAgICAgICAgIC0gJ3N0cm9uZycgLSBXcml0ZSBvcGVyYXRpb25zIGdvIHRocm91Z2ggdGhlIHBlcm1hbmVudCBsZWFkZXIsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgY29uc2lzdGVudCwgYnV0IG1heSBiZSB1bmF2YWlsYWJsZSBpZiBsZWFkZXIgaXMgZG93blxuICAgICAqIEByZXR1cm5zIE9wZXJhdGlvbiBSZXN1bHRcbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGVQYXlsb2FkSW5kZXgoY29sbGVjdGlvbl9uYW1lLCBmaWVsZF9uYW1lLCB7IHdhaXQgPSB0cnVlLCBvcmRlcmluZyB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9vcGVuQXBpQ2xpZW50LmRlbGV0ZUZpZWxkSW5kZXgoe1xuICAgICAgICAgICAgY29sbGVjdGlvbl9uYW1lLFxuICAgICAgICAgICAgZmllbGRfbmFtZSxcbiAgICAgICAgICAgIHdhaXQsXG4gICAgICAgICAgICBvcmRlcmluZyxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtYXliZShyZXNwb25zZS5kYXRhLnJlc3VsdCkub3JUaHJvdygnRGVsZXRlIGZpZWxkIGluZGV4IHJldHVybmVkIGVtcHR5Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgYWxsIHNuYXBzaG90cyBmb3IgYSBnaXZlbiBjb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIGNvbGxlY3Rpb25fbmFtZSBOYW1lIG9mIHRoZSBjb2xsZWN0aW9uXG4gICAgICogQHJldHVybnMgTGlzdCBvZiBzbmFwc2hvdHNcbiAgICAgKi9cbiAgICBhc3luYyBsaXN0U25hcHNob3RzKGNvbGxlY3Rpb25fbmFtZSkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX29wZW5BcGlDbGllbnQubGlzdFNuYXBzaG90cyh7IGNvbGxlY3Rpb25fbmFtZSB9KTtcbiAgICAgICAgcmV0dXJuIG1heWJlKHJlc3BvbnNlLmRhdGEucmVzdWx0KS5vclRocm93KCdMaXN0IHNuYXBzaG90cyBBUEkgcmV0dXJuZWQgZW1wdHknKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHNuYXBzaG90IGZvciBhIGdpdmVuIGNvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0gY29sbGVjdGlvbl9uYW1lIE5hbWUgb2YgdGhlIGNvbGxlY3Rpb25cbiAgICAgKiBAcmV0dXJucyBTbmFwc2hvdCBkZXNjcmlwdGlvblxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVNuYXBzaG90KGNvbGxlY3Rpb25fbmFtZSwgYXJncykge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX29wZW5BcGlDbGllbnQuY3JlYXRlU25hcHNob3QoeyBjb2xsZWN0aW9uX25hbWUsIC4uLmFyZ3MgfSk7XG4gICAgICAgIHJldHVybiBtYXliZShyZXNwb25zZS5kYXRhLnJlc3VsdCkub3JOdWxsKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBzbmFwc2hvdCBmb3IgYSBnaXZlbiBjb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIGNvbGxlY3Rpb25fbmFtZSBOYW1lIG9mIHRoZSBjb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHNuYXBzaG90X25hbWUgU25hcHNob3QgaWRcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHNuYXBzaG90IHdhcyBkZWxldGVkXG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlU25hcHNob3QoY29sbGVjdGlvbl9uYW1lLCBzbmFwc2hvdF9uYW1lLCBhcmdzKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fb3BlbkFwaUNsaWVudC5kZWxldGVTbmFwc2hvdCh7IGNvbGxlY3Rpb25fbmFtZSwgc25hcHNob3RfbmFtZSwgLi4uYXJncyB9KTtcbiAgICAgICAgcmV0dXJuIG1heWJlKHJlc3BvbnNlLmRhdGEucmVzdWx0KS5vclRocm93KCdEZWxldGUgc25hcHNob3QgQVBJIHJldHVybmVkIGVtcHR5Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgYWxsIHNuYXBzaG90cyBmb3IgYSB3aG9sZSBzdG9yYWdlXG4gICAgICogQHJldHVybnMgTGlzdCBvZiBzbmFwc2hvdHNcbiAgICAgKi9cbiAgICBhc3luYyBsaXN0RnVsbFNuYXBzaG90cygpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9vcGVuQXBpQ2xpZW50Lmxpc3RGdWxsU25hcHNob3RzKHt9KTtcbiAgICAgICAgcmV0dXJuIG1heWJlKHJlc3BvbnNlLmRhdGEucmVzdWx0KS5vclRocm93KCdMaXN0IGZ1bGwgc25hcHNob3RzIEFQSSByZXR1cm5lZCBlbXB0eScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgc25hcHNob3QgZm9yIGEgd2hvbGUgc3RvcmFnZVxuICAgICAqIEByZXR1cm5zIFNuYXBzaG90IGRlc2NyaXB0aW9uXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlRnVsbFNuYXBzaG90KGFyZ3MpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9vcGVuQXBpQ2xpZW50LmNyZWF0ZUZ1bGxTbmFwc2hvdChhcmdzID8/IHt9KTtcbiAgICAgICAgcmV0dXJuIG1heWJlKHJlc3BvbnNlLmRhdGEucmVzdWx0KS5vclRocm93KCdDcmVhdGUgZnVsbCBzbmFwc2hvdCBBUEkgcmV0dXJuZWQgZW1wdHknKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIHNuYXBzaG90IGZvciBhIHdob2xlIHN0b3JhZ2VcbiAgICAgKiBAcGFyYW0gc25hcHNob3RfbmFtZSBTbmFwc2hvdCBuYW1lXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgc25hcHNob3Qgd2FzIGRlbGV0ZWRcbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGVGdWxsU25hcHNob3Qoc25hcHNob3RfbmFtZSwgYXJncykge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX29wZW5BcGlDbGllbnQuZGVsZXRlRnVsbFNuYXBzaG90KHsgc25hcHNob3RfbmFtZSwgLi4uYXJncyB9KTtcbiAgICAgICAgcmV0dXJuIG1heWJlKHJlc3BvbnNlLmRhdGEucmVzdWx0KS5vclRocm93KCdEZWxldGUgZnVsbCBzbmFwc2hvdCBBUEkgcmV0dXJuZWQgZW1wdHknKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVjb3ZlciBjb2xsZWN0aW9uIGZyb20gc25hcHNob3RcbiAgICAgKiBAcGFyYW0gY29sbGVjdGlvbl9uYW1lIE5hbWUgb2YgdGhlIGNvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICAgICAqICAgICAtIGxvY2F0aW9uOlxuICAgICAqICAgICAgICAgVVJMIG9mIHRoZSBzbmFwc2hvdC5cbiAgICAgKiAgICAgICAgIEV4YW1wbGU6XG4gICAgICogICAgICAgICAgICAgLSBVUkwgYGh0dHA6Ly9sb2NhbGhvc3Q6ODA4MC9jb2xsZWN0aW9ucy9teV9jb2xsZWN0aW9uL3NuYXBzaG90cy9teV9zbmFwc2hvdGBcbiAgICAgKiAgICAgICAgICAgICAtIExvY2FsIHBhdGggYGZpbGU6Ly8vcWRyYW50L3NuYXBzaG90cy90ZXN0X2NvbGxlY3Rpb24tMjAyMi0wOC0wNC0xMC00OS0xMC5zbmFwc2hvdGBcbiAgICAgKiAgICAgLSBwcmlvcml0eTpcbiAgICAgKiAgICAgICAgIERlZmluZXMgc291cmNlIG9mIHRydXRoIGZvciBzbmFwc2hvdCByZWNvdmVyeVxuICAgICAqICAgICAgICAgICAgIC0gYHNuYXBzaG90YCBtZWFucyAtIHByZWZlciBzbmFwc2hvdCBkYXRhIG92ZXIgdGhlIGN1cnJlbnQgc3RhdGVcbiAgICAgKiAgICAgICAgICAgICAtIGByZXBsaWNhYCBtZWFucyAtIHByZWZlciBleGlzdGluZyBkYXRhIG92ZXIgdGhlIHNuYXBzaG90XG4gICAgICogICAgICAgICBEZWZhdWx0OiBgcmVwbGljYWBcbiAgICAgKiAgICAgLSBjaGVja3N1bTpcbiAgICAgKiAgICAgICAgIFNIQTI1NiBjaGVja3N1bSB0byB2ZXJpZnkgc25hcHNob3QgaW50ZWdyaXR5IGJlZm9yZSByZWNvdmVyeVxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHNuYXBzaG90IHdhcyByZWNvdmVyZWRcbiAgICAgKi9cbiAgICBhc3luYyByZWNvdmVyU25hcHNob3QoY29sbGVjdGlvbl9uYW1lLCB7IGxvY2F0aW9uLCBwcmlvcml0eSwgY2hlY2tzdW0sIGFwaV9rZXkgfSkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX29wZW5BcGlDbGllbnQucmVjb3ZlckZyb21TbmFwc2hvdCh7XG4gICAgICAgICAgICBjb2xsZWN0aW9uX25hbWUsXG4gICAgICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgICAgIHByaW9yaXR5LFxuICAgICAgICAgICAgY2hlY2tzdW0sXG4gICAgICAgICAgICBhcGlfa2V5LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1heWJlKHJlc3BvbnNlLmRhdGEucmVzdWx0KS5vclRocm93KCdSZWNvdmVyIGZyb20gc25hcHNob3QgQVBJIHJldHVybmVkIGVtcHR5Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvY2sgc3RvcmFnZSBmb3Igd3JpdGluZ1xuICAgICAqL1xuICAgIGFzeW5jIGxvY2tTdG9yYWdlKHJlYXNvbikge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX29wZW5BcGlDbGllbnQucG9zdExvY2tzKHsgd3JpdGU6IHRydWUsIGVycm9yX21lc3NhZ2U6IHJlYXNvbiB9KTtcbiAgICAgICAgcmV0dXJuIG1heWJlKHJlc3BvbnNlLmRhdGEucmVzdWx0KS5vclRocm93KCdMb2NrIHN0b3JhZ2UgcmV0dXJuZWQgZW1wdHknKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5sb2NrIHN0b3JhZ2UgZm9yIHdyaXRpbmcuXG4gICAgICovXG4gICAgYXN5bmMgdW5sb2NrU3RvcmFnZSgpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9vcGVuQXBpQ2xpZW50LnBvc3RMb2Nrcyh7IHdyaXRlOiBmYWxzZSB9KTtcbiAgICAgICAgcmV0dXJuIG1heWJlKHJlc3BvbnNlLmRhdGEucmVzdWx0KS5vclRocm93KCdQb3N0IGxvY2tzIHJldHVybmVkIGVtcHR5Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBjdXJyZW50IGxvY2tzIHN0YXRlLlxuICAgICAqL1xuICAgIGFzeW5jIGdldExvY2tzKCkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX29wZW5BcGlDbGllbnQuZ2V0TG9ja3Moe30pO1xuICAgICAgICByZXR1cm4gbWF5YmUocmVzcG9uc2UuZGF0YS5yZXN1bHQpLm9yVGhyb3coJ0dldCBsb2NrcyByZXR1cm5lZCBlbXB0eScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCYXRjaCB1cGRhdGUgcG9pbnRzXG4gICAgICogQXBwbHkgYSBzZXJpZXMgb2YgdXBkYXRlIG9wZXJhdGlvbnMgZm9yIHBvaW50cywgdmVjdG9ycyBhbmQgcGF5bG9hZHMuXG4gICAgICogQHBhcmFtIGNvbGxlY3Rpb25fbmFtZSBOYW1lIG9mIHRoZSBjb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAgICAgKiAgICAgLSB3YWl0OiBBd2FpdCBmb3IgdGhlIHJlc3VsdHMgdG8gYmUgcHJvY2Vzc2VkLlxuICAgICAqICAgICAgICAgLSBJZiBgdHJ1ZWAsIHJlc3VsdCB3aWxsIGJlIHJldHVybmVkIG9ubHkgd2hlbiBhbGwgY2hhbmdlcyBhcmUgYXBwbGllZFxuICAgICAqICAgICAgICAgLSBJZiBgZmFsc2VgLCByZXN1bHQgd2lsbCBiZSByZXR1cm5lZCBpbW1lZGlhdGVseSBhZnRlciB0aGUgY29uZmlybWF0aW9uIG9mIHJlY2VpdmluZy5cbiAgICAgKiAgICAgIC0gb3JkZXJpbmc6IERlZmluZSBzdHJhdGVneSBmb3Igb3JkZXJpbmcgb2YgdGhlIHBvaW50cy4gUG9zc2libGUgdmFsdWVzOlxuICAgICAqICAgICAgICAgIC0gJ3dlYWsnICAgLSB3cml0ZSBvcGVyYXRpb25zIG1heSBiZSByZW9yZGVyZWQsIHdvcmtzIGZhc3RlciwgZGVmYXVsdFxuICAgICAqICAgICAgICAgIC0gJ21lZGl1bScgLSB3cml0ZSBvcGVyYXRpb25zIGdvIHRocm91Z2ggZHluYW1pY2FsbHkgc2VsZWN0ZWQgbGVhZGVyLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIG1heSBiZSBpbmNvbnNpc3RlbnQgZm9yIGEgc2hvcnQgcGVyaW9kIG9mIHRpbWUgaW4gY2FzZSBvZiBsZWFkZXIgY2hhbmdlXG4gICAgICogICAgICAgICAgLSAnc3Ryb25nJyAtIFdyaXRlIG9wZXJhdGlvbnMgZ28gdGhyb3VnaCB0aGUgcGVybWFuZW50IGxlYWRlcixcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICBjb25zaXN0ZW50LCBidXQgbWF5IGJlIHVuYXZhaWxhYmxlIGlmIGxlYWRlciBpcyBkb3duXG4gICAgICogICAgICAtIG9wZXJhdGlvbnM6IExpc3Qgb2Ygb3BlcmF0aW9ucyB0byBwZXJmb3JtXG4gICAgICogQHJldHVybnMgT3BlcmF0aW9uIHJlc3VsdFxuICAgICAqL1xuICAgIGFzeW5jIGJhdGNoVXBkYXRlKGNvbGxlY3Rpb25fbmFtZSwgeyB3YWl0ID0gdHJ1ZSwgb3JkZXJpbmcsIC4uLm9wZXJhdGlvbnMgfSkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX29wZW5BcGlDbGllbnQuYmF0Y2hVcGRhdGUoe1xuICAgICAgICAgICAgY29sbGVjdGlvbl9uYW1lLFxuICAgICAgICAgICAgd2FpdCxcbiAgICAgICAgICAgIG9yZGVyaW5nLFxuICAgICAgICAgICAgLi4ub3BlcmF0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtYXliZShyZXNwb25zZS5kYXRhLnJlc3VsdCkub3JUaHJvdygnQmF0Y2ggdXBkYXRlIHJldHVybmVkIGVtcHR5Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlY292ZXIgZnJvbSBhIHNuYXBzaG90XG4gICAgICogQHBhcmFtIGNvbGxlY3Rpb25fbmFtZSBOYW1lIG9mIHRoZSBjb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHNoYXJkX2lkIFNoYXJkIElEXG4gICAgICogQHJldHVybnMgT3BlcmF0aW9uIHJlc3VsdFxuICAgICAqL1xuICAgIGFzeW5jIHJlY292ZXJTaGFyZEZyb21TbmFwc2hvdChjb2xsZWN0aW9uX25hbWUsIHNoYXJkX2lkLCB7IHdhaXQgPSB0cnVlLCAuLi5zaGFyZF9zbmFwc2hvdF9yZWNvdmVyIH0pIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9vcGVuQXBpQ2xpZW50LnJlY292ZXJTaGFyZEZyb21TbmFwc2hvdCh7XG4gICAgICAgICAgICBjb2xsZWN0aW9uX25hbWUsXG4gICAgICAgICAgICBzaGFyZF9pZCxcbiAgICAgICAgICAgIHdhaXQsXG4gICAgICAgICAgICAuLi5zaGFyZF9zbmFwc2hvdF9yZWNvdmVyLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1heWJlKHJlc3BvbnNlLmRhdGEucmVzdWx0KS5vclRocm93KCdSZWNvdmVyIHNoYXJkIGZyb20gc25hcHNob3QgcmV0dXJuZWQgZW1wdHknKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGxpc3Qgb2Ygc25hcHNob3RzIGZvciBhIHNoYXJkIG9mIGEgY29sbGVjdGlvblxuICAgICAqIEBwYXJhbSBjb2xsZWN0aW9uX25hbWUgTmFtZSBvZiB0aGUgY29sbGVjdGlvblxuICAgICAqIEBwYXJhbSBzaGFyZF9pZCBTaGFyZCBJRFxuICAgICAqIEByZXR1cm5zIE9wZXJhdGlvbiByZXN1bHRcbiAgICAgKi9cbiAgICBhc3luYyBsaXN0U2hhcmRTbmFwc2hvdHMoY29sbGVjdGlvbl9uYW1lLCBzaGFyZF9pZCkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX29wZW5BcGlDbGllbnQubGlzdFNoYXJkU25hcHNob3RzKHtcbiAgICAgICAgICAgIGNvbGxlY3Rpb25fbmFtZSxcbiAgICAgICAgICAgIHNoYXJkX2lkLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1heWJlKHJlc3BvbnNlLmRhdGEucmVzdWx0KS5vclRocm93KCdMaXN0IHNoYXJkIHNuYXBzaG90cyByZXR1cm5lZCBlbXB0eScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgbmV3IHNuYXBzaG90IG9mIGEgc2hhcmQgZm9yIGEgY29sbGVjdGlvblxuICAgICAqIEBwYXJhbSBjb2xsZWN0aW9uX25hbWUgTmFtZSBvZiB0aGUgY29sbGVjdGlvblxuICAgICAqIEBwYXJhbSBzaGFyZF9pZCBTaGFyZCBJRFxuICAgICAqIEByZXR1cm5zIE9wZXJhdGlvbiByZXN1bHRcbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVTaGFyZFNuYXBzaG90KGNvbGxlY3Rpb25fbmFtZSwgc2hhcmRfaWQsIHsgd2FpdCA9IHRydWUgfSkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX29wZW5BcGlDbGllbnQuY3JlYXRlU2hhcmRTbmFwc2hvdCh7XG4gICAgICAgICAgICBjb2xsZWN0aW9uX25hbWUsXG4gICAgICAgICAgICBzaGFyZF9pZCxcbiAgICAgICAgICAgIHdhaXQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWF5YmUocmVzcG9uc2UuZGF0YS5yZXN1bHQpLm9yVGhyb3coJ0NyZWF0ZSBzaGFyZCBzbmFwc2hvdCByZXR1cm5lZCBlbXB0eScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgc25hcHNob3Qgb2YgYSBzaGFyZCBmb3IgYSBjb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIGNvbGxlY3Rpb25fbmFtZSBOYW1lIG9mIHRoZSBjb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHNoYXJkX2lkIFNoYXJkIElEXG4gICAgICogQHBhcmFtIHNuYXBzaG90X25hbWUgU25hcHNob3QgbmFtZVxuICAgICAqIEByZXR1cm5zIE9wZXJhdGlvbiByZXN1bHRcbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGVTaGFyZFNuYXBzaG90KGNvbGxlY3Rpb25fbmFtZSwgc2hhcmRfaWQsIHNuYXBzaG90X25hbWUsIHsgd2FpdCA9IHRydWUgfSkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX29wZW5BcGlDbGllbnQuZGVsZXRlU2hhcmRTbmFwc2hvdCh7XG4gICAgICAgICAgICBjb2xsZWN0aW9uX25hbWUsXG4gICAgICAgICAgICBzaGFyZF9pZCxcbiAgICAgICAgICAgIHNuYXBzaG90X25hbWUsXG4gICAgICAgICAgICB3YWl0LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1heWJlKHJlc3BvbnNlLmRhdGEucmVzdWx0KS5vclRocm93KCdDcmVhdGUgc2hhcmQgc25hcHNob3QgcmV0dXJuZWQgZW1wdHknKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHNoYXJkIGtleVxuICAgICAqIEBwYXJhbSBjb2xsZWN0aW9uX25hbWUgTmFtZSBvZiB0aGUgY29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzIC1cbiAgICAgKiAgICAgLSBzaGFyZF9rZXk6IFNwZWNpZnkgaW4gd2hpY2ggc2hhcmRzIHRvIGxvb2sgZm9yIHRoZSBwb2ludHMsIGlmIG5vdCBzcGVjaWZpZWQgLSBsb29rIGluIGFsbCBzaGFyZHNcbiAgICAgKiAgICAgLSBzaGFyZHNfbnVtYmVyOiBIb3cgbWFueSBzaGFyZHMgdG8gY3JlYXRlIGZvciB0aGlzIGtleSBJZiBub3Qgc3BlY2lmaWVkLCB3aWxsIHVzZSB0aGUgZGVmYXVsdCB2YWx1ZSBmcm9tIGNvbmZpZ1xuICAgICAqICAgICAtIHJlcGxpY2F0aW9uX2ZhY3RvcjogSG93IG1hbnkgcmVwbGljYXMgdG8gY3JlYXRlIGZvciBlYWNoIHNoYXJkIElmIG5vdCBzcGVjaWZpZWQsIHdpbGwgdXNlIHRoZSBkZWZhdWx0IHZhbHVlIGZyb20gY29uZmlnXG4gICAgICogICAgIC0gcGxhY2VtZW50OiBQbGFjZW1lbnQgb2Ygc2hhcmRzIGZvciB0aGlzIGtleSBMaXN0IG9mIHBlZXIgaWRzLCB0aGF0IGNhbiBiZSB1c2VkIHRvIHBsYWNlIHNoYXJkcyBmb3IgdGhpcyBrZXkgSWYgbm90IHNwZWNpZmllZCwgd2lsbCBiZSByYW5kb21seSBwbGFjZWQgYW1vbmcgYWxsIHBlZXJzXG4gICAgICogICAgIC0gdGltZW91dDogSWYgc2V0LCBvdmVycmlkZXMgZ2xvYmFsIHRpbWVvdXQgc2V0dGluZyBmb3IgdGhpcyByZXF1ZXN0LiBVbml0IGlzIHNlY29uZHMuXG4gICAgICogQHJldHVybnMgT3BlcmF0aW9uIHJlc3VsdFxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVNoYXJkS2V5KGNvbGxlY3Rpb25fbmFtZSwgeyBzaGFyZF9rZXksIHNoYXJkc19udW1iZXIsIHJlcGxpY2F0aW9uX2ZhY3RvciwgcGxhY2VtZW50LCB0aW1lb3V0LCB9KSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fb3BlbkFwaUNsaWVudC5jcmVhdGVTaGFyZEtleSh7XG4gICAgICAgICAgICBjb2xsZWN0aW9uX25hbWUsXG4gICAgICAgICAgICBzaGFyZF9rZXksXG4gICAgICAgICAgICBzaGFyZHNfbnVtYmVyLFxuICAgICAgICAgICAgcmVwbGljYXRpb25fZmFjdG9yLFxuICAgICAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICAgICAgdGltZW91dCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtYXliZShyZXNwb25zZS5kYXRhLnJlc3VsdCkub3JUaHJvdygnQ3JlYXRlIHNoYXJkIGtleSByZXR1cm5lZCBlbXB0eScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgc2hhcmQga2V5XG4gICAgICogQHBhcmFtIGNvbGxlY3Rpb25fbmFtZSBOYW1lIG9mIHRoZSBjb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGFyZ3MgLVxuICAgICAqICAgICAtIHNoYXJkX2tleTogU3BlY2lmeSBpbiB3aGljaCBzaGFyZHMgdG8gbG9vayBmb3IgdGhlIHBvaW50cywgaWYgbm90IHNwZWNpZmllZCAtIGxvb2sgaW4gYWxsIHNoYXJkc1xuICAgICAqICAgICAtIHRpbWVvdXQ6IElmIHNldCwgb3ZlcnJpZGVzIGdsb2JhbCB0aW1lb3V0IHNldHRpbmcgZm9yIHRoaXMgcmVxdWVzdC4gVW5pdCBpcyBzZWNvbmRzLlxuICAgICAqIEByZXR1cm5zIE9wZXJhdGlvbiByZXN1bHRcbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGVTaGFyZEtleShjb2xsZWN0aW9uX25hbWUsIHsgc2hhcmRfa2V5LCB0aW1lb3V0IH0pIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9vcGVuQXBpQ2xpZW50LmRlbGV0ZVNoYXJkS2V5KHtcbiAgICAgICAgICAgIGNvbGxlY3Rpb25fbmFtZSxcbiAgICAgICAgICAgIHNoYXJkX2tleSxcbiAgICAgICAgICAgIHRpbWVvdXQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWF5YmUocmVzcG9uc2UuZGF0YS5yZXN1bHQpLm9yVGhyb3coJ0NyZWF0ZSBzaGFyZCBrZXkgcmV0dXJuZWQgZW1wdHknKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzY292ZXIgcG9pbnRzXG4gICAgICogQGRlc2NyaXB0aW9uIFVzZSBjb250ZXh0IGFuZCBhIHRhcmdldCB0byBmaW5kIHRoZSBtb3N0IHNpbWlsYXIgcG9pbnRzIHRvIHRoZSB0YXJnZXQsIGNvbnN0cmFpbmVkIGJ5IHRoZSBjb250ZXh0LlxuICAgICAqIFdoZW4gdXNpbmcgb25seSB0aGUgY29udGV4dCAod2l0aG91dCBhIHRhcmdldCksIGEgc3BlY2lhbCBzZWFyY2ggLSBjYWxsZWQgY29udGV4dCBzZWFyY2ggLSBpcyBwZXJmb3JtZWQgd2hlcmUgcGFpcnMgb2YgcG9pbnRzIGFyZSB1c2VkIHRvIGdlbmVyYXRlIGEgbG9zcyB0aGF0IGd1aWRlcyB0aGUgc2VhcmNoIHRvd2FyZHMgdGhlIHpvbmUgd2hlcmUgbW9zdCBwb3NpdGl2ZSBleGFtcGxlcyBvdmVybGFwLiBUaGlzIG1lYW5zIHRoYXQgdGhlIHNjb3JlIG1pbmltaXplcyB0aGUgc2NlbmFyaW8gb2YgZmluZGluZyBhIHBvaW50IGNsb3NlciB0byBhIG5lZ2F0aXZlIHRoYW4gdG8gYSBwb3NpdGl2ZSBwYXJ0IG9mIGEgcGFpci5cbiAgICAgKiBTaW5jZSB0aGUgc2NvcmUgb2YgYSBjb250ZXh0IHJlbGF0ZXMgdG8gbG9zcywgdGhlIG1heGltdW0gc2NvcmUgYSBwb2ludCBjYW4gZ2V0IGlzIDAuMCwgYW5kIGl0IGJlY29tZXMgbm9ybWFsIHRoYXQgbWFueSBwb2ludHMgY2FuIGhhdmUgYSBzY29yZSBvZiAwLjAuXG4gICAgICogV2hlbiB1c2luZyB0YXJnZXQgKHdpdGggb3Igd2l0aG91dCBjb250ZXh0KSwgdGhlIHNjb3JlIGJlaGF2ZXMgYSBsaXR0bGUgZGlmZmVyZW50OiBUaGUgIGludGVnZXIgcGFydCBvZiB0aGUgc2NvcmUgcmVwcmVzZW50cyB0aGUgcmFuayB3aXRoIHJlc3BlY3QgdG8gdGhlIGNvbnRleHQsIHdoaWxlIHRoZSBkZWNpbWFsIHBhcnQgb2YgdGhlIHNjb3JlIHJlbGF0ZXMgdG8gdGhlIGRpc3RhbmNlIHRvIHRoZSB0YXJnZXQuIFRoZSBjb250ZXh0IHBhcnQgb2YgdGhlIHNjb3JlIGZvciAgZWFjaCBwYWlyIGlzIGNhbGN1bGF0ZWQgKzEgaWYgdGhlIHBvaW50IGlzIGNsb3NlciB0byBhIHBvc2l0aXZlIHRoYW4gdG8gYSBuZWdhdGl2ZSBwYXJ0IG9mIGEgcGFpciwgIGFuZCAtMSBvdGhlcndpc2UuXG4gICAgICogQHBhcmFtIGNvbGxlY3Rpb25fbmFtZSBOYW1lIG9mIHRoZSBjb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGFyZ3MgLVxuICAgICAqICAgICAtIGNvbnNpc3RlbmN5OiBSZWFkIGNvbnNpc3RlbmN5IG9mIHRoZSBzZWFyY2guIERlZmluZXMgaG93IG1hbnkgcmVwbGljYXMgc2hvdWxkIGJlIHF1ZXJpZWQgYmVmb3JlIHJldHVybmluZyB0aGUgcmVzdWx0LlxuICAgICAqICAgICAgICAgVmFsdWVzOlxuICAgICAqICAgICAgICAgICAgIG51bWJlciAtIG51bWJlciBvZiByZXBsaWNhcyB0byBxdWVyeSwgdmFsdWVzIHNob3VsZCBwcmVzZW50IGluIGFsbCBxdWVyaWVkIHJlcGxpY2FzXG4gICAgICogICAgICAgICAgICAgJ21ham9yaXR5JyAtIHF1ZXJ5IGFsbCByZXBsaWNhcywgYnV0IHJldHVybiB2YWx1ZXMgcHJlc2VudCBpbiB0aGUgbWFqb3JpdHkgb2YgcmVwbGljYXNcbiAgICAgKiAgICAgICAgICAgICAncXVvcnVtJyAtIHF1ZXJ5IHRoZSBtYWpvcml0eSBvZiByZXBsaWNhcywgcmV0dXJuIHZhbHVlcyBwcmVzZW50IGluIGFsbCBvZiB0aGVtXG4gICAgICogICAgICAgICAgICAgJ2FsbCcgLSBxdWVyeSBhbGwgcmVwbGljYXMsIGFuZCByZXR1cm4gdmFsdWVzIHByZXNlbnQgaW4gYWxsIHJlcGxpY2FzXG4gICAgICogICAgIC0gdGltZW91dDogSWYgc2V0LCBvdmVycmlkZXMgZ2xvYmFsIHRpbWVvdXQgc2V0dGluZyBmb3IgdGhpcyByZXF1ZXN0LiBVbml0IGlzIHNlY29uZHMuXG4gICAgICogICAgIC0gc2hhcmRfa2V5OiBTcGVjaWZ5IGluIHdoaWNoIHNoYXJkcyB0byBsb29rIGZvciB0aGUgcG9pbnRzLCBpZiBub3Qgc3BlY2lmaWVkIC0gbG9vayBpbiBhbGwgc2hhcmRzXG4gICAgICogICAgIC0gdGFyZ2V0OiBMb29rIGZvciB2ZWN0b3JzIGNsb3Nlc3QgdG8gdGhpcy4gV2hlbiB1c2luZyB0aGUgdGFyZ2V0ICh3aXRoIG9yIHdpdGhvdXQgY29udGV4dCksIHRoZSBpbnRlZ2VyIHBhcnQgb2YgdGhlIHNjb3JlIHJlcHJlc2VudHMgdGhlIHJhbmsgd2l0aCByZXNwZWN0IHRvIHRoZSBjb250ZXh0LCB3aGlsZSB0aGUgZGVjaW1hbCBwYXJ0IG9mIHRoZSBzY29yZSByZWxhdGVzIHRvIHRoZSBkaXN0YW5jZSB0byB0aGUgdGFyZ2V0LlxuICAgICAqICAgICAtIGNvbnRleHQ6IFBhaXJzIG9mIHsgcG9zaXRpdmUsIG5lZ2F0aXZlIH0gZXhhbXBsZXMgdG8gY29uc3RyYWluIHRoZSBzZWFyY2guIFdoZW4gdXNpbmcgb25seSB0aGUgY29udGV4dCAod2l0aG91dCBhIHRhcmdldCksIGEgc3BlY2lhbCBzZWFyY2ggLSBjYWxsZWQgY29udGV4dCBzZWFyY2ggLSBpcyBwZXJmb3JtZWQgd2hlcmUgcGFpcnMgb2YgcG9pbnRzIGFyZSB1c2VkIHRvIGdlbmVyYXRlIGEgbG9zcyB0aGF0IGd1aWRlcyB0aGUgc2VhcmNoIHRvd2FyZHMgdGhlIHpvbmUgd2hlcmUgbW9zdCBwb3NpdGl2ZSBleGFtcGxlcyBvdmVybGFwLiBUaGlzIG1lYW5zIHRoYXQgdGhlIHNjb3JlIG1pbmltaXplcyB0aGUgc2NlbmFyaW8gb2YgZmluZGluZyBhIHBvaW50IGNsb3NlciB0byBhIG5lZ2F0aXZlIHRoYW4gdG8gYSBwb3NpdGl2ZSBwYXJ0IG9mIGEgcGFpci4gU2luY2UgdGhlIHNjb3JlIG9mIGEgY29udGV4dCByZWxhdGVzIHRvIGxvc3MsIHRoZSBtYXhpbXVtIHNjb3JlIGEgcG9pbnQgY2FuIGdldCBpcyAwLjAsIGFuZCBpdCBiZWNvbWVzIG5vcm1hbCB0aGF0IG1hbnkgcG9pbnRzIGNhbiBoYXZlIGEgc2NvcmUgb2YgMC4wLiBGb3IgZGlzY292ZXJ5IHNlYXJjaCAod2hlbiBpbmNsdWRpbmcgYSB0YXJnZXQpLCB0aGUgY29udGV4dCBwYXJ0IG9mIHRoZSBzY29yZSBmb3IgZWFjaCBwYWlyIGlzIGNhbGN1bGF0ZWQgKzEgaWYgdGhlIHBvaW50IGlzIGNsb3NlciB0byBhIHBvc2l0aXZlIHRoYW4gdG8gYSBuZWdhdGl2ZSBwYXJ0IG9mIGEgcGFpciwgYW5kIC0xIG90aGVyd2lzZS5cbiAgICAgKiAgICAgLSBmaWx0ZXI6IExvb2sgb25seSBmb3IgcG9pbnRzIHdoaWNoIHNhdGlzZmllcyB0aGlzIGNvbmRpdGlvbnNcbiAgICAgKiAgICAgLSBwYXJhbXM6IEFkZGl0aW9uYWwgc2VhcmNoIHBhcmFtc1xuICAgICAqICAgICAtIGxpbWl0OiBNYXggbnVtYmVyIG9mIHJlc3VsdCB0byByZXR1cm5cbiAgICAgKiAgICAgLSBvZmZzZXQ6IE9mZnNldCBvZiB0aGUgZmlyc3QgcmVzdWx0IHRvIHJldHVybi4gTWF5IGJlIHVzZWQgdG8gcGFnaW5hdGUgcmVzdWx0cy4gTm90ZTogbGFyZ2Ugb2Zmc2V0IHZhbHVlcyBtYXkgY2F1c2UgcGVyZm9ybWFuY2UgaXNzdWVzLlxuICAgICAqICAgICAtIHdpdGhfcGF5bG9hZDogU2VsZWN0IHdoaWNoIHBheWxvYWQgdG8gcmV0dXJuIHdpdGggdGhlIHJlc3BvbnNlXG4gICAgICogICAgIC0gd2l0aF92ZWN0b3I6IFdoZXRoZXIgdG8gcmV0dXJuIHRoZSBwb2ludCB2ZWN0b3Igd2l0aCB0aGUgcmVzdWx0P1xuICAgICAqICAgICAtIHVzaW5nOiBEZWZpbmUgd2hpY2ggdmVjdG9yIHRvIHVzZSBmb3IgcmVjb21tZW5kYXRpb24sIGlmIG5vdCBzcGVjaWZpZWQgLSB0cnkgdG8gdXNlIGRlZmF1bHQgdmVjdG9yXG4gICAgICogICAgIC0gbG9va3VwX2Zyb20gVGhlIGxvY2F0aW9uIHVzZWQgdG8gbG9va3VwIHZlY3RvcnMuIElmIG5vdCBzcGVjaWZpZWQgLSB1c2UgY3VycmVudCBjb2xsZWN0aW9uLiBOb3RlOiB0aGUgb3RoZXIgY29sbGVjdGlvbiBzaG91bGQgaGF2ZSB0aGUgc2FtZSB2ZWN0b3Igc2l6ZSBhcyB0aGUgY3VycmVudCBjb2xsZWN0aW9uXG4gICAgICogQHJldHVybnMgT3BlcmF0aW9uIHJlc3VsdFxuICAgICAqL1xuICAgIGFzeW5jIGRpc2NvdmVyUG9pbnRzKGNvbGxlY3Rpb25fbmFtZSwgeyBjb25zaXN0ZW5jeSwgdGltZW91dCwgc2hhcmRfa2V5LCB0YXJnZXQsIGNvbnRleHQsIHBhcmFtcywgbGltaXQsIG9mZnNldCwgd2l0aF9wYXlsb2FkLCB3aXRoX3ZlY3RvciwgdXNpbmcsIGxvb2t1cF9mcm9tLCB9KSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fb3BlbkFwaUNsaWVudC5kaXNjb3ZlclBvaW50cyh7XG4gICAgICAgICAgICBjb2xsZWN0aW9uX25hbWUsXG4gICAgICAgICAgICBjb25zaXN0ZW5jeSxcbiAgICAgICAgICAgIHRpbWVvdXQsXG4gICAgICAgICAgICBzaGFyZF9rZXksXG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgbGltaXQsXG4gICAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgICB3aXRoX3BheWxvYWQsXG4gICAgICAgICAgICB3aXRoX3ZlY3RvcixcbiAgICAgICAgICAgIHVzaW5nLFxuICAgICAgICAgICAgbG9va3VwX2Zyb20sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWF5YmUocmVzcG9uc2UuZGF0YS5yZXN1bHQpLm9yVGhyb3coJ0Rpc2NvdmVyIHBvaW50cyByZXR1cm5lZCBlbXB0eScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNjb3ZlciBiYXRjaCBwb2ludHNcbiAgICAgKiBAZGVzY3JpcHRpb24gTG9vayBmb3IgcG9pbnRzIGJhc2VkIG9uIHRhcmdldCBhbmQvb3IgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIGV4YW1wbGUgcGFpcnMsIGluIGJhdGNoLlxuICAgICAqIEBwYXJhbSBjb2xsZWN0aW9uX25hbWUgTmFtZSBvZiB0aGUgY29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzIC1cbiAgICAgKiAgICAgLSBjb25zaXN0ZW5jeTogUmVhZCBjb25zaXN0ZW5jeSBvZiB0aGUgc2VhcmNoLiBEZWZpbmVzIGhvdyBtYW55IHJlcGxpY2FzIHNob3VsZCBiZSBxdWVyaWVkIGJlZm9yZSByZXR1cm5pbmcgdGhlIHJlc3VsdC5cbiAgICAgKiAgICAgICAgIFZhbHVlczpcbiAgICAgKiAgICAgICAgICAgICBudW1iZXIgLSBudW1iZXIgb2YgcmVwbGljYXMgdG8gcXVlcnksIHZhbHVlcyBzaG91bGQgcHJlc2VudCBpbiBhbGwgcXVlcmllZCByZXBsaWNhc1xuICAgICAqICAgICAgICAgICAgICdtYWpvcml0eScgLSBxdWVyeSBhbGwgcmVwbGljYXMsIGJ1dCByZXR1cm4gdmFsdWVzIHByZXNlbnQgaW4gdGhlIG1ham9yaXR5IG9mIHJlcGxpY2FzXG4gICAgICogICAgICAgICAgICAgJ3F1b3J1bScgLSBxdWVyeSB0aGUgbWFqb3JpdHkgb2YgcmVwbGljYXMsIHJldHVybiB2YWx1ZXMgcHJlc2VudCBpbiBhbGwgb2YgdGhlbVxuICAgICAqICAgICAgICAgICAgICdhbGwnIC0gcXVlcnkgYWxsIHJlcGxpY2FzLCBhbmQgcmV0dXJuIHZhbHVlcyBwcmVzZW50IGluIGFsbCByZXBsaWNhc1xuICAgICAqICAgICAtIHRpbWVvdXQ6IElmIHNldCwgb3ZlcnJpZGVzIGdsb2JhbCB0aW1lb3V0IHNldHRpbmcgZm9yIHRoaXMgcmVxdWVzdC4gVW5pdCBpcyBzZWNvbmRzLlxuICAgICAqICAgICAtIHNlYXJjaGVzOiBMaXN0IG9mIHNlYXJjaGVzXG4gICAgICogQHJldHVybnMgT3BlcmF0aW9uIHJlc3VsdFxuICAgICAqL1xuICAgIGFzeW5jIGRpc2NvdmVyQmF0Y2hQb2ludHMoY29sbGVjdGlvbl9uYW1lLCB7IGNvbnNpc3RlbmN5LCB0aW1lb3V0LCBzZWFyY2hlcywgfSkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX29wZW5BcGlDbGllbnQuZGlzY292ZXJCYXRjaFBvaW50cyh7XG4gICAgICAgICAgICBjb2xsZWN0aW9uX25hbWUsXG4gICAgICAgICAgICBjb25zaXN0ZW5jeSxcbiAgICAgICAgICAgIHRpbWVvdXQsXG4gICAgICAgICAgICBzZWFyY2hlcyxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtYXliZShyZXNwb25zZS5kYXRhLnJlc3VsdCkub3JUaHJvdygnRGlzY292ZXIgYmF0Y2ggcG9pbnRzIHJldHVybmVkIGVtcHR5Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJ1bm5pbmcgUWRyYW50IGluc3RhbmNlXG4gICAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJ1bm5pbmcgUWRyYW50IGluc3RhbmNlIGxpa2UgdmVyc2lvbiBhbmQgY29tbWl0IGlkXG4gICAgICogQHJldHVybnMgT3BlcmF0aW9uIHJlc3VsdFxuICAgICAqL1xuICAgIGFzeW5jIHZlcnNpb25JbmZvKCkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX29wZW5BcGlDbGllbnQucm9vdCh7fSk7XG4gICAgICAgIHJldHVybiBtYXliZShyZXNwb25zZS5kYXRhKS5vclRocm93KCdWZXJzaW9uIEluZm8gcmV0dXJuZWQgZW1wdHknKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhlIGV4aXN0ZW5jZSBvZiBhIGNvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0gY29sbGVjdGlvbl9uYW1lIE5hbWUgb2YgdGhlIGNvbGxlY3Rpb25cbiAgICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyBcInRydWVcIiBpZiB0aGUgZ2l2ZW4gY29sbGVjdGlvbiBuYW1lIGV4aXN0cywgYW5kIFwiZmFsc2VcIiBvdGhlcndpc2VcbiAgICAgKiBAcmV0dXJucyBPcGVyYXRpb24gcmVzdWx0XG4gICAgICovXG4gICAgYXN5bmMgY29sbGVjdGlvbkV4aXN0cyhjb2xsZWN0aW9uX25hbWUpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9vcGVuQXBpQ2xpZW50LmNvbGxlY3Rpb25FeGlzdHMoeyBjb2xsZWN0aW9uX25hbWUgfSk7XG4gICAgICAgIHJldHVybiBtYXliZShyZXNwb25zZS5kYXRhLnJlc3VsdCkub3JUaHJvdygnQ29sbGVjdGlvbiBleGlzdHMgcmV0dXJuZWQgZW1wdHknKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUXVlcnkgcG9pbnRzXG4gICAgICogQGRlc2NyaXB0aW9uIFVuaXZlcnNhbGx5IHF1ZXJ5IHBvaW50cy4gVGhpcyBlbmRwb2ludCBjb3ZlcnMgYWxsIGNhcGFiaWxpdGllcyBvZiBzZWFyY2gsIHJlY29tbWVuZCwgZGlzY292ZXIsIGZpbHRlcnMuIEJ1dCBhbHNvIGVuYWJsZXMgaHlicmlkIGFuZCBtdWx0aS1zdGFnZSBxdWVyaWVzLlxuICAgICAqIEBwYXJhbSBjb2xsZWN0aW9uX25hbWUgTmFtZSBvZiB0aGUgY29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzIC1cbiAgICAgKiAgICAgLSBjb25zaXN0ZW5jeTogUmVhZCBjb25zaXN0ZW5jeSBvZiB0aGUgc2VhcmNoLiBEZWZpbmVzIGhvdyBtYW55IHJlcGxpY2FzIHNob3VsZCBiZSBxdWVyaWVkIGJlZm9yZSByZXR1cm5pbmcgdGhlIHJlc3VsdC5cbiAgICAgKiAgICAgICAgIFZhbHVlczpcbiAgICAgKiAgICAgICAgICAgICBudW1iZXIgLSBudW1iZXIgb2YgcmVwbGljYXMgdG8gcXVlcnksIHZhbHVlcyBzaG91bGQgcHJlc2VudCBpbiBhbGwgcXVlcmllZCByZXBsaWNhc1xuICAgICAqICAgICAgICAgICAgICdtYWpvcml0eScgLSBxdWVyeSBhbGwgcmVwbGljYXMsIGJ1dCByZXR1cm4gdmFsdWVzIHByZXNlbnQgaW4gdGhlIG1ham9yaXR5IG9mIHJlcGxpY2FzXG4gICAgICogICAgICAgICAgICAgJ3F1b3J1bScgLSBxdWVyeSB0aGUgbWFqb3JpdHkgb2YgcmVwbGljYXMsIHJldHVybiB2YWx1ZXMgcHJlc2VudCBpbiBhbGwgb2YgdGhlbVxuICAgICAqICAgICAgICAgICAgICdhbGwnIC0gcXVlcnkgYWxsIHJlcGxpY2FzLCBhbmQgcmV0dXJuIHZhbHVlcyBwcmVzZW50IGluIGFsbCByZXBsaWNhc1xuICAgICAqICAgICAtIHRpbWVvdXQ6IElmIHNldCwgb3ZlcnJpZGVzIGdsb2JhbCB0aW1lb3V0IHNldHRpbmcgZm9yIHRoaXMgcmVxdWVzdC4gVW5pdCBpcyBzZWNvbmRzLlxuICAgICAqICAgICAtIHNoYXJkX2tleTogU3BlY2lmeSBpbiB3aGljaCBzaGFyZHMgdG8gbG9vayBmb3IgdGhlIHBvaW50cywgaWYgbm90IHNwZWNpZmllZCAtIGxvb2sgaW4gYWxsIHNoYXJkcy5cbiAgICAgKiAgICAgLSBwcmVmZXRjaDogU3ViLXJlcXVlc3RzIHRvIHBlcmZvcm0gZmlyc3QuIElmIHByZXNlbnQsIHRoZSBxdWVyeSB3aWxsIGJlIHBlcmZvcm1lZCBvbiB0aGUgcmVzdWx0cyBvZiB0aGUgcHJlZmV0Y2goZXMpLlxuICAgICAqICAgICAtIHF1ZXJ5OiBRdWVyeSB0byBwZXJmb3JtLiBJZiBtaXNzaW5nIHdpdGhvdXQgcHJlZmV0Y2hlcywgcmV0dXJucyBwb2ludHMgb3JkZXJlZCBieSB0aGVpciBJRHMuXG4gICAgICogICAgIC0gdXNpbmc6IERlZmluZSB3aGljaCB2ZWN0b3IgbmFtZSB0byB1c2UgZm9yIHF1ZXJ5aW5nLiBJZiBtaXNzaW5nLCB0aGUgZGVmYXVsdCB2ZWN0b3IgaXMgdXNlZC5cbiAgICAgKiAgICAgLSBmaWx0ZXI6IEZpbHRlciBjb25kaXRpb25zIC0gcmV0dXJuIG9ubHkgdGhvc2UgcG9pbnRzIHRoYXQgc2F0aXNmeSB0aGUgc3BlY2lmaWVkIGNvbmRpdGlvbnMuXG4gICAgICogICAgIC0gcGFyYW1zOiBTZWFyY2ggcGFyYW1zIGZvciB3aGVuIHRoZXJlIGlzIG5vIHByZWZldGNoXG4gICAgICogICAgIC0gc2NvcmVfdGhyZXNob2xkOiBSZXR1cm4gcG9pbnRzIHdpdGggc2NvcmVzIGJldHRlciB0aGFuIHRoaXMgdGhyZXNob2xkLlxuICAgICAqICAgICAtIGxpbWl0OiBNYXggbnVtYmVyIG9mIHBvaW50cyB0byByZXR1cm4uIERlZmF1bHQgaXMgMTAuXG4gICAgICogICAgIC0gb2Zmc2V0OiBPZmZzZXQgb2YgdGhlIHJlc3VsdC4gU2tpcCB0aGlzIG1hbnkgcG9pbnRzLiBEZWZhdWx0IGlzIDBcbiAgICAgKiAgICAgLSB3aXRoX3ZlY3RvcjogT3B0aW9ucyBmb3Igc3BlY2lmeWluZyB3aGljaCB2ZWN0b3JzIHRvIGluY2x1ZGUgaW50byB0aGUgcmVzcG9uc2UuIERlZmF1bHQgaXMgZmFsc2UuXG4gICAgICogICAgIC0gd2l0aF9wYXlsb2FkOiBPcHRpb25zIGZvciBzcGVjaWZ5aW5nIHdoaWNoIHBheWxvYWQgdG8gaW5jbHVkZSBvciBub3QuIERlZmF1bHQgaXMgZmFsc2UuXG4gICAgICogICAgIC0gbG9va3VwX2Zyb206IFRoZSBsb2NhdGlvbiB0byB1c2UgZm9yIElEcyBsb29rdXAsIGlmIG5vdCBzcGVjaWZpZWQgLSB1c2UgdGhlIGN1cnJlbnQgY29sbGVjdGlvbiBhbmQgdGhlICd1c2luZycgdmVjdG9yIE5vdGU6IHRoZSBvdGhlciBjb2xsZWN0aW9uIHZlY3RvcnMgc2hvdWxkIGhhdmUgdGhlIHNhbWUgdmVjdG9yIHNpemUgYXMgdGhlICd1c2luZycgdmVjdG9yIGluIHRoZSBjdXJyZW50IGNvbGxlY3Rpb24uXG4gICAgICogQHJldHVybnMgT3BlcmF0aW9uIHJlc3VsdFxuICAgICAqL1xuICAgIGFzeW5jIHF1ZXJ5KGNvbGxlY3Rpb25fbmFtZSwgeyBjb25zaXN0ZW5jeSwgdGltZW91dCwgc2hhcmRfa2V5LCBwcmVmZXRjaCwgcXVlcnksIHVzaW5nLCBmaWx0ZXIsIHBhcmFtcywgc2NvcmVfdGhyZXNob2xkLCBsaW1pdCwgb2Zmc2V0LCB3aXRoX3ZlY3Rvciwgd2l0aF9wYXlsb2FkLCBsb29rdXBfZnJvbSwgfSkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX29wZW5BcGlDbGllbnQucXVlcnlQb2ludHMoe1xuICAgICAgICAgICAgY29sbGVjdGlvbl9uYW1lLFxuICAgICAgICAgICAgY29uc2lzdGVuY3ksXG4gICAgICAgICAgICB0aW1lb3V0LFxuICAgICAgICAgICAgc2hhcmRfa2V5LFxuICAgICAgICAgICAgcHJlZmV0Y2gsXG4gICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgIHVzaW5nLFxuICAgICAgICAgICAgZmlsdGVyLFxuICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgc2NvcmVfdGhyZXNob2xkLFxuICAgICAgICAgICAgbGltaXQsXG4gICAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgICB3aXRoX3ZlY3RvcixcbiAgICAgICAgICAgIHdpdGhfcGF5bG9hZCxcbiAgICAgICAgICAgIGxvb2t1cF9mcm9tLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1heWJlKHJlc3BvbnNlLmRhdGEucmVzdWx0KS5vclRocm93KCdRdWVyeSBwb2ludHMgcmV0dXJuZWQgZW1wdHknKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUXVlcnkgcG9pbnRzIGluIGJhdGNoXG4gICAgICogQGRlc2NyaXB0aW9uIFVuaXZlcnNhbGx5IHF1ZXJ5IHBvaW50cyBpbiBiYXRjaC4gVGhpcyBlbmRwb2ludCBjb3ZlcnMgYWxsIGNhcGFiaWxpdGllcyBvZiBzZWFyY2gsIHJlY29tbWVuZCwgZGlzY292ZXIsIGZpbHRlcnMuIEJ1dCBhbHNvIGVuYWJsZXMgaHlicmlkIGFuZCBtdWx0aS1zdGFnZSBxdWVyaWVzLlxuICAgICAqIEBwYXJhbSBjb2xsZWN0aW9uX25hbWUgTmFtZSBvZiB0aGUgY29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzIC1cbiAgICAgKiAgICAgLSBjb25zaXN0ZW5jeTogUmVhZCBjb25zaXN0ZW5jeSBvZiB0aGUgc2VhcmNoLiBEZWZpbmVzIGhvdyBtYW55IHJlcGxpY2FzIHNob3VsZCBiZSBxdWVyaWVkIGJlZm9yZSByZXR1cm5pbmcgdGhlIHJlc3VsdC5cbiAgICAgKiAgICAgICAgIFZhbHVlczpcbiAgICAgKiAgICAgICAgICAgICBudW1iZXIgLSBudW1iZXIgb2YgcmVwbGljYXMgdG8gcXVlcnksIHZhbHVlcyBzaG91bGQgcHJlc2VudCBpbiBhbGwgcXVlcmllZCByZXBsaWNhc1xuICAgICAqICAgICAgICAgICAgICdtYWpvcml0eScgLSBxdWVyeSBhbGwgcmVwbGljYXMsIGJ1dCByZXR1cm4gdmFsdWVzIHByZXNlbnQgaW4gdGhlIG1ham9yaXR5IG9mIHJlcGxpY2FzXG4gICAgICogICAgICAgICAgICAgJ3F1b3J1bScgLSBxdWVyeSB0aGUgbWFqb3JpdHkgb2YgcmVwbGljYXMsIHJldHVybiB2YWx1ZXMgcHJlc2VudCBpbiBhbGwgb2YgdGhlbVxuICAgICAqICAgICAgICAgICAgICdhbGwnIC0gcXVlcnkgYWxsIHJlcGxpY2FzLCBhbmQgcmV0dXJuIHZhbHVlcyBwcmVzZW50IGluIGFsbCByZXBsaWNhc1xuICAgICAqICAgICAtIHRpbWVvdXQ6IElmIHNldCwgb3ZlcnJpZGVzIGdsb2JhbCB0aW1lb3V0IHNldHRpbmcgZm9yIHRoaXMgcmVxdWVzdC4gVW5pdCBpcyBzZWNvbmRzLlxuICAgICAqICAgICAtIHNlYXJjaGVzOiBMaXN0IG9mIHF1ZXJpZXNcbiAgICAgKiBAcmV0dXJucyBPcGVyYXRpb24gcmVzdWx0XG4gICAgICovXG4gICAgYXN5bmMgcXVlcnlCYXRjaChjb2xsZWN0aW9uX25hbWUsIHsgY29uc2lzdGVuY3ksIHRpbWVvdXQsIHNlYXJjaGVzLCB9KSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fb3BlbkFwaUNsaWVudC5xdWVyeUJhdGNoUG9pbnRzKHtcbiAgICAgICAgICAgIGNvbGxlY3Rpb25fbmFtZSxcbiAgICAgICAgICAgIGNvbnNpc3RlbmN5LFxuICAgICAgICAgICAgdGltZW91dCxcbiAgICAgICAgICAgIHNlYXJjaGVzLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1heWJlKHJlc3BvbnNlLmRhdGEucmVzdWx0KS5vclRocm93KCdRdWVyeSBwb2ludHMgcmV0dXJuZWQgZW1wdHknKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUXVlcnkgcG9pbnRzLCBncm91cGVkIGJ5IGEgZ2l2ZW4gcGF5bG9hZCBmaWVsZFxuICAgICAqIEBkZXNjcmlwdGlvbiBVbml2ZXJzYWxseSBxdWVyeSBwb2ludHMsIGdyb3VwZWQgYnkgYSBnaXZlbiBwYXlsb2FkIGZpZWxkXG4gICAgICogQHBhcmFtIGNvbGxlY3Rpb25fbmFtZSBOYW1lIG9mIHRoZSBjb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGFyZ3MgLVxuICAgICAqICAgICAtIGNvbnNpc3RlbmN5OiBSZWFkIGNvbnNpc3RlbmN5IG9mIHRoZSBzZWFyY2guIERlZmluZXMgaG93IG1hbnkgcmVwbGljYXMgc2hvdWxkIGJlIHF1ZXJpZWQgYmVmb3JlIHJldHVybmluZyB0aGUgcmVzdWx0LlxuICAgICAqICAgICAgICAgVmFsdWVzOlxuICAgICAqICAgICAgICAgICAgIG51bWJlciAtIG51bWJlciBvZiByZXBsaWNhcyB0byBxdWVyeSwgdmFsdWVzIHNob3VsZCBwcmVzZW50IGluIGFsbCBxdWVyaWVkIHJlcGxpY2FzXG4gICAgICogICAgICAgICAgICAgJ21ham9yaXR5JyAtIHF1ZXJ5IGFsbCByZXBsaWNhcywgYnV0IHJldHVybiB2YWx1ZXMgcHJlc2VudCBpbiB0aGUgbWFqb3JpdHkgb2YgcmVwbGljYXNcbiAgICAgKiAgICAgICAgICAgICAncXVvcnVtJyAtIHF1ZXJ5IHRoZSBtYWpvcml0eSBvZiByZXBsaWNhcywgcmV0dXJuIHZhbHVlcyBwcmVzZW50IGluIGFsbCBvZiB0aGVtXG4gICAgICogICAgICAgICAgICAgJ2FsbCcgLSBxdWVyeSBhbGwgcmVwbGljYXMsIGFuZCByZXR1cm4gdmFsdWVzIHByZXNlbnQgaW4gYWxsIHJlcGxpY2FzXG4gICAgICogICAgIC0gdGltZW91dDogSWYgc2V0LCBvdmVycmlkZXMgZ2xvYmFsIHRpbWVvdXQgc2V0dGluZyBmb3IgdGhpcyByZXF1ZXN0LiBVbml0IGlzIHNlY29uZHMuXG4gICAgICogICAgIC0gc2hhcmRfa2V5OiBTcGVjaWZ5IGluIHdoaWNoIHNoYXJkcyB0byBsb29rIGZvciB0aGUgcG9pbnRzLCBpZiBub3Qgc3BlY2lmaWVkIC0gbG9vayBpbiBhbGwgc2hhcmRzLlxuICAgICAqICAgICAtIHByZWZldGNoOiBTdWItcmVxdWVzdHMgdG8gcGVyZm9ybSBmaXJzdC4gSWYgcHJlc2VudCwgdGhlIHF1ZXJ5IHdpbGwgYmUgcGVyZm9ybWVkIG9uIHRoZSByZXN1bHRzIG9mIHRoZSBwcmVmZXRjaChlcykuXG4gICAgICogICAgIC0gcXVlcnk6IFF1ZXJ5IHRvIHBlcmZvcm0uIElmIG1pc3Npbmcgd2l0aG91dCBwcmVmZXRjaGVzLCByZXR1cm5zIHBvaW50cyBvcmRlcmVkIGJ5IHRoZWlyIElEcy5cbiAgICAgKiAgICAgLSB1c2luZzogRGVmaW5lIHdoaWNoIHZlY3RvciBuYW1lIHRvIHVzZSBmb3IgcXVlcnlpbmcuIElmIG1pc3NpbmcsIHRoZSBkZWZhdWx0IHZlY3RvciBpcyB1c2VkLlxuICAgICAqICAgICAtIGZpbHRlcjogRmlsdGVyIGNvbmRpdGlvbnMgLSByZXR1cm4gb25seSB0aG9zZSBwb2ludHMgdGhhdCBzYXRpc2Z5IHRoZSBzcGVjaWZpZWQgY29uZGl0aW9ucy5cbiAgICAgKiAgICAgLSBwYXJhbXM6IFNlYXJjaCBwYXJhbXMgZm9yIHdoZW4gdGhlcmUgaXMgbm8gcHJlZmV0Y2hcbiAgICAgKiAgICAgLSBzY29yZV90aHJlc2hvbGQ6IFJldHVybiBwb2ludHMgd2l0aCBzY29yZXMgYmV0dGVyIHRoYW4gdGhpcyB0aHJlc2hvbGQuXG4gICAgICogICAgIC0gd2l0aF92ZWN0b3I6IE9wdGlvbnMgZm9yIHNwZWNpZnlpbmcgd2hpY2ggdmVjdG9ycyB0byBpbmNsdWRlIGludG8gdGhlIHJlc3BvbnNlLiBEZWZhdWx0IGlzIGZhbHNlLlxuICAgICAqICAgICAtIHdpdGhfcGF5bG9hZDogT3B0aW9ucyBmb3Igc3BlY2lmeWluZyB3aGljaCBwYXlsb2FkIHRvIGluY2x1ZGUgb3Igbm90LiBEZWZhdWx0IGlzIGZhbHNlLlxuICAgICAqICAgICAtIGdyb3VwX2J5OiBQYXlsb2FkIGZpZWxkIHRvIGdyb3VwIGJ5LCBtdXN0IGJlIGEgc3RyaW5nIG9yIG51bWJlciBmaWVsZC4gSWYgdGhlIGZpZWxkIGNvbnRhaW5zIG1vcmUgdGhhbiAxIHZhbHVlLCBhbGwgdmFsdWVzIHdpbGwgYmUgdXNlZCBmb3IgZ3JvdXBpbmcuIE9uZSBwb2ludCBjYW4gYmUgaW4gbXVsdGlwbGUgZ3JvdXBzLlxuICAgICAqICAgICAtIGdyb3VwX3NpemU6IE1heGltdW0gYW1vdW50IG9mIHBvaW50cyB0byByZXR1cm4gcGVyIGdyb3VwLiBEZWZhdWx0IGlzIDMuXG4gICAgICogICAgIC0gbGltaXQ6IE1heGltdW0gYW1vdW50IG9mIGdyb3VwcyB0byByZXR1cm4uIERlZmF1bHQgaXMgMTAuXG4gICAgICogICAgIC0gd2l0aF9sb29rdXA6IExvb2sgZm9yIHBvaW50cyBpbiBhbm90aGVyIGNvbGxlY3Rpb24gdXNpbmcgdGhlIGdyb3VwIGlkcy5cbiAgICAgKiBAcmV0dXJucyBPcGVyYXRpb24gcmVzdWx0XG4gICAgICovXG4gICAgYXN5bmMgcXVlcnlHcm91cHMoY29sbGVjdGlvbl9uYW1lLCB7IGNvbnNpc3RlbmN5LCB0aW1lb3V0LCBzaGFyZF9rZXksIHByZWZldGNoLCBxdWVyeSwgdXNpbmcsIGZpbHRlciwgcGFyYW1zLCBzY29yZV90aHJlc2hvbGQsIHdpdGhfdmVjdG9yLCB3aXRoX3BheWxvYWQsIGdyb3VwX2J5LCBncm91cF9zaXplLCBsaW1pdCwgd2l0aF9sb29rdXAsIH0pIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9vcGVuQXBpQ2xpZW50LnF1ZXJ5UG9pbnRzR3JvdXBzKHtcbiAgICAgICAgICAgIGNvbGxlY3Rpb25fbmFtZSxcbiAgICAgICAgICAgIGNvbnNpc3RlbmN5LFxuICAgICAgICAgICAgdGltZW91dCxcbiAgICAgICAgICAgIHNoYXJkX2tleSxcbiAgICAgICAgICAgIHByZWZldGNoLFxuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICB1c2luZyxcbiAgICAgICAgICAgIGZpbHRlcixcbiAgICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICAgIHNjb3JlX3RocmVzaG9sZCxcbiAgICAgICAgICAgIHdpdGhfdmVjdG9yLFxuICAgICAgICAgICAgd2l0aF9wYXlsb2FkLFxuICAgICAgICAgICAgZ3JvdXBfYnksXG4gICAgICAgICAgICBncm91cF9zaXplLFxuICAgICAgICAgICAgbGltaXQsXG4gICAgICAgICAgICB3aXRoX2xvb2t1cCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtYXliZShyZXNwb25zZS5kYXRhLnJlc3VsdCkub3JUaHJvdygnUXVlcnkgZ3JvdXBzIHJldHVybmVkIGVtcHR5Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZhY2V0IGEgcGF5bG9hZCBrZXkgd2l0aCBhIGdpdmVuIGZpbHRlci5cbiAgICAgKiBAZGVzY3JpcHRpb24gQ291bnQgcG9pbnRzIHRoYXQgc2F0aXNmeSB0aGUgZ2l2ZW4gZmlsdGVyIGZvciBlYWNoIHVuaXF1ZSB2YWx1ZSBvZiBhIHBheWxvYWQga2V5LlxuICAgICAqIEBwYXJhbSBjb2xsZWN0aW9uX25hbWUgTmFtZSBvZiB0aGUgY29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzIC1cbiAgICAgKiAgICAgLSBjb25zaXN0ZW5jeTogUmVhZCBjb25zaXN0ZW5jeSBvZiB0aGUgc2VhcmNoLiBEZWZpbmVzIGhvdyBtYW55IHJlcGxpY2FzIHNob3VsZCBiZSBxdWVyaWVkIGJlZm9yZSByZXR1cm5pbmcgdGhlIHJlc3VsdC5cbiAgICAgKiAgICAgICAgIFZhbHVlczpcbiAgICAgKiAgICAgICAgICAgICBudW1iZXIgLSBudW1iZXIgb2YgcmVwbGljYXMgdG8gcXVlcnksIHZhbHVlcyBzaG91bGQgcHJlc2VudCBpbiBhbGwgcXVlcmllZCByZXBsaWNhc1xuICAgICAqICAgICAgICAgICAgICdtYWpvcml0eScgLSBxdWVyeSBhbGwgcmVwbGljYXMsIGJ1dCByZXR1cm4gdmFsdWVzIHByZXNlbnQgaW4gdGhlIG1ham9yaXR5IG9mIHJlcGxpY2FzXG4gICAgICogICAgICAgICAgICAgJ3F1b3J1bScgLSBxdWVyeSB0aGUgbWFqb3JpdHkgb2YgcmVwbGljYXMsIHJldHVybiB2YWx1ZXMgcHJlc2VudCBpbiBhbGwgb2YgdGhlbVxuICAgICAqICAgICAgICAgICAgICdhbGwnIC0gcXVlcnkgYWxsIHJlcGxpY2FzLCBhbmQgcmV0dXJuIHZhbHVlcyBwcmVzZW50IGluIGFsbCByZXBsaWNhc1xuICAgICAqICAgICAtIHRpbWVvdXQ6IElmIHNldCwgb3ZlcnJpZGVzIGdsb2JhbCB0aW1lb3V0IHNldHRpbmcgZm9yIHRoaXMgcmVxdWVzdC4gVW5pdCBpcyBzZWNvbmRzLlxuICAgICAqICAgICAtIHNoYXJkX2tleTogU3BlY2lmeSBpbiB3aGljaCBzaGFyZHMgdG8gbG9vayBmb3IgdGhlIHBvaW50cywgaWYgbm90IHNwZWNpZmllZCAtIGxvb2sgaW4gYWxsIHNoYXJkcy5cbiAgICAgKiAgICAgLSBrZXk6IFBheWxvYWQga2V5IHRvIHVzZSBmb3IgZmFjZXRpbmcuXG4gICAgICogICAgIC0gbGltaXQ6IE1heCBudW1iZXIgb2YgaGl0cyB0byByZXR1cm4uIERlZmF1bHQgaXMgMTAuXG4gICAgICogICAgIC0gZmlsdGVyOiBGaWx0ZXIgY29uZGl0aW9ucyAtIG9ubHkgY29uc2lkZXIgcG9pbnRzIHRoYXQgc2F0aXNmeSB0aGVzZSBjb25kaXRpb25zLlxuICAgICAqICAgICAtIGV4YWN0OiBXaGV0aGVyIHRvIGRvIGEgbW9yZSBleHBlbnNpdmUgZXhhY3QgY291bnQgZm9yIGVhY2ggb2YgdGhlIHZhbHVlcyBpbiB0aGUgZmFjZXQuIERlZmF1bHQgaXMgZmFsc2UuXG4gICAgICogQHJldHVybnMgT3BlcmF0aW9uIHJlc3VsdFxuICAgICAqL1xuICAgIGFzeW5jIGZhY2V0KGNvbGxlY3Rpb25fbmFtZSwgeyBjb25zaXN0ZW5jeSwgdGltZW91dCwgc2hhcmRfa2V5LCBrZXksIGxpbWl0LCBmaWx0ZXIsIGV4YWN0LCB9KSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fb3BlbkFwaUNsaWVudC5mYWNldCh7XG4gICAgICAgICAgICBjb2xsZWN0aW9uX25hbWUsXG4gICAgICAgICAgICBjb25zaXN0ZW5jeSxcbiAgICAgICAgICAgIHRpbWVvdXQsXG4gICAgICAgICAgICBzaGFyZF9rZXksXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBsaW1pdCxcbiAgICAgICAgICAgIGZpbHRlcixcbiAgICAgICAgICAgIGV4YWN0LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1heWJlKHJlc3BvbnNlLmRhdGEucmVzdWx0KS5vclRocm93KCdGYWNldCByZXR1cm5lZCBlbXB0eScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWFyY2ggcG9pbnRzIG1hdHJpeCBkaXN0YW5jZSBwYWlycy5cbiAgICAgKiBAZGVzY3JpcHRpb24gQ29tcHV0ZSBkaXN0YW5jZSBtYXRyaXggZm9yIHNhbXBsZWQgcG9pbnRzIHdpdGggYSBwYWlyIGJhc2VkIG91dHB1dCBmb3JtYXQuXG4gICAgICogQHBhcmFtIGNvbGxlY3Rpb25fbmFtZSBOYW1lIG9mIHRoZSBjb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGFyZ3MgLVxuICAgICAqICAgICAtIGNvbnNpc3RlbmN5OiBSZWFkIGNvbnNpc3RlbmN5IG9mIHRoZSBzZWFyY2guIERlZmluZXMgaG93IG1hbnkgcmVwbGljYXMgc2hvdWxkIGJlIHF1ZXJpZWQgYmVmb3JlIHJldHVybmluZyB0aGUgcmVzdWx0LlxuICAgICAqICAgICAgICAgVmFsdWVzOlxuICAgICAqICAgICAgICAgICAgIG51bWJlciAtIG51bWJlciBvZiByZXBsaWNhcyB0byBxdWVyeSwgdmFsdWVzIHNob3VsZCBwcmVzZW50IGluIGFsbCBxdWVyaWVkIHJlcGxpY2FzXG4gICAgICogICAgICAgICAgICAgJ21ham9yaXR5JyAtIHF1ZXJ5IGFsbCByZXBsaWNhcywgYnV0IHJldHVybiB2YWx1ZXMgcHJlc2VudCBpbiB0aGUgbWFqb3JpdHkgb2YgcmVwbGljYXNcbiAgICAgKiAgICAgICAgICAgICAncXVvcnVtJyAtIHF1ZXJ5IHRoZSBtYWpvcml0eSBvZiByZXBsaWNhcywgcmV0dXJuIHZhbHVlcyBwcmVzZW50IGluIGFsbCBvZiB0aGVtXG4gICAgICogICAgICAgICAgICAgJ2FsbCcgLSBxdWVyeSBhbGwgcmVwbGljYXMsIGFuZCByZXR1cm4gdmFsdWVzIHByZXNlbnQgaW4gYWxsIHJlcGxpY2FzXG4gICAgICogICAgIC0gdGltZW91dDogSWYgc2V0LCBvdmVycmlkZXMgZ2xvYmFsIHRpbWVvdXQgc2V0dGluZyBmb3IgdGhpcyByZXF1ZXN0LiBVbml0IGlzIHNlY29uZHMuXG4gICAgICogICAgIC0gc2hhcmRfa2V5OiBTcGVjaWZ5IGluIHdoaWNoIHNoYXJkcyB0byBsb29rIGZvciB0aGUgcG9pbnRzLCBpZiBub3Qgc3BlY2lmaWVkIC0gbG9vayBpbiBhbGwgc2hhcmRzLlxuICAgICAqICAgICAtIGZpbHRlcjogTG9vayBvbmx5IGZvciBwb2ludHMgd2hpY2ggc2F0aXNmaWVzIHRoaXMgY29uZGl0aW9ucy5cbiAgICAgKiAgICAgLSBzYW1wbGU6IEhvdyBtYW55IHBvaW50cyB0byBzZWxlY3QgYW5kIHNlYXJjaCB3aXRoaW4uIERlZmF1bHQgaXMgMTAuXG4gICAgICogICAgIC0gbGltaXQ6IEhvdyBtYW55IG5laWdoYm91cnMgcGVyIHNhbXBsZSB0byBmaW5kLiBEZWZhdWx0IGlzIDMuXG4gICAgICogICAgIC0gdXNpbmc6IERlZmluZSB3aGljaCB2ZWN0b3IgbmFtZSB0byB1c2UgZm9yIHF1ZXJ5aW5nLiBJZiBtaXNzaW5nLCB0aGUgZGVmYXVsdCB2ZWN0b3IgaXMgdXNlZC5cbiAgICAgKiBAcmV0dXJucyBPcGVyYXRpb24gcmVzdWx0XG4gICAgICovXG4gICAgYXN5bmMgc2VhcmNoTWF0cml4UGFpcnMoY29sbGVjdGlvbl9uYW1lLCB7IGNvbnNpc3RlbmN5LCB0aW1lb3V0LCBzaGFyZF9rZXksIGZpbHRlciwgc2FtcGxlLCBsaW1pdCwgdXNpbmcsIH0pIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9vcGVuQXBpQ2xpZW50LnNlYXJjaE1hdHJpeFBhaXJzKHtcbiAgICAgICAgICAgIGNvbGxlY3Rpb25fbmFtZSxcbiAgICAgICAgICAgIGNvbnNpc3RlbmN5LFxuICAgICAgICAgICAgdGltZW91dCxcbiAgICAgICAgICAgIHNoYXJkX2tleSxcbiAgICAgICAgICAgIGZpbHRlcixcbiAgICAgICAgICAgIHNhbXBsZSxcbiAgICAgICAgICAgIGxpbWl0LFxuICAgICAgICAgICAgdXNpbmcsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWF5YmUocmVzcG9uc2UuZGF0YS5yZXN1bHQpLm9yVGhyb3coJ1NlYXJjaCBwb2ludHMgbWF0cml4IHBhaXJzIHJldHVybmVkIGVtcHR5Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlYXJjaCBwb2ludHMgbWF0cml4IGRpc3RhbmNlIG9mZnNldHMuXG4gICAgICogQGRlc2NyaXB0aW9uIENvbXB1dGUgZGlzdGFuY2UgbWF0cml4IGZvciBzYW1wbGVkIHBvaW50cyB3aXRoIGFuIG9mZnNldCBiYXNlZCBvdXRwdXQgZm9ybWF0LlxuICAgICAqIEBwYXJhbSBjb2xsZWN0aW9uX25hbWUgTmFtZSBvZiB0aGUgY29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzIC1cbiAgICAgKiAgICAgLSBjb25zaXN0ZW5jeTogUmVhZCBjb25zaXN0ZW5jeSBvZiB0aGUgc2VhcmNoLiBEZWZpbmVzIGhvdyBtYW55IHJlcGxpY2FzIHNob3VsZCBiZSBxdWVyaWVkIGJlZm9yZSByZXR1cm5pbmcgdGhlIHJlc3VsdC5cbiAgICAgKiAgICAgICAgIFZhbHVlczpcbiAgICAgKiAgICAgICAgICAgICBudW1iZXIgLSBudW1iZXIgb2YgcmVwbGljYXMgdG8gcXVlcnksIHZhbHVlcyBzaG91bGQgcHJlc2VudCBpbiBhbGwgcXVlcmllZCByZXBsaWNhc1xuICAgICAqICAgICAgICAgICAgICdtYWpvcml0eScgLSBxdWVyeSBhbGwgcmVwbGljYXMsIGJ1dCByZXR1cm4gdmFsdWVzIHByZXNlbnQgaW4gdGhlIG1ham9yaXR5IG9mIHJlcGxpY2FzXG4gICAgICogICAgICAgICAgICAgJ3F1b3J1bScgLSBxdWVyeSB0aGUgbWFqb3JpdHkgb2YgcmVwbGljYXMsIHJldHVybiB2YWx1ZXMgcHJlc2VudCBpbiBhbGwgb2YgdGhlbVxuICAgICAqICAgICAgICAgICAgICdhbGwnIC0gcXVlcnkgYWxsIHJlcGxpY2FzLCBhbmQgcmV0dXJuIHZhbHVlcyBwcmVzZW50IGluIGFsbCByZXBsaWNhc1xuICAgICAqICAgICAtIHRpbWVvdXQ6IElmIHNldCwgb3ZlcnJpZGVzIGdsb2JhbCB0aW1lb3V0IHNldHRpbmcgZm9yIHRoaXMgcmVxdWVzdC4gVW5pdCBpcyBzZWNvbmRzLlxuICAgICAqICAgICAtIHNoYXJkX2tleTogU3BlY2lmeSBpbiB3aGljaCBzaGFyZHMgdG8gbG9vayBmb3IgdGhlIHBvaW50cywgaWYgbm90IHNwZWNpZmllZCAtIGxvb2sgaW4gYWxsIHNoYXJkcy5cbiAgICAgKiAgICAgLSBmaWx0ZXI6IExvb2sgb25seSBmb3IgcG9pbnRzIHdoaWNoIHNhdGlzZmllcyB0aGlzIGNvbmRpdGlvbnMuXG4gICAgICogICAgIC0gc2FtcGxlOiBIb3cgbWFueSBwb2ludHMgdG8gc2VsZWN0IGFuZCBzZWFyY2ggd2l0aGluLiBEZWZhdWx0IGlzIDEwLlxuICAgICAqICAgICAtIGxpbWl0OiBIb3cgbWFueSBuZWlnaGJvdXJzIHBlciBzYW1wbGUgdG8gZmluZC4gRGVmYXVsdCBpcyAzLlxuICAgICAqICAgICAtIHVzaW5nOiBEZWZpbmUgd2hpY2ggdmVjdG9yIG5hbWUgdG8gdXNlIGZvciBxdWVyeWluZy4gSWYgbWlzc2luZywgdGhlIGRlZmF1bHQgdmVjdG9yIGlzIHVzZWQuXG4gICAgICogQHJldHVybnMgT3BlcmF0aW9uIHJlc3VsdFxuICAgICAqL1xuICAgIGFzeW5jIHNlYXJjaE1hdHJpeE9mZnNldHMoY29sbGVjdGlvbl9uYW1lLCB7IGNvbnNpc3RlbmN5LCB0aW1lb3V0LCBzaGFyZF9rZXksIGZpbHRlciwgc2FtcGxlLCBsaW1pdCwgdXNpbmcsIH0pIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9vcGVuQXBpQ2xpZW50LnNlYXJjaE1hdHJpeE9mZnNldHMoe1xuICAgICAgICAgICAgY29sbGVjdGlvbl9uYW1lLFxuICAgICAgICAgICAgY29uc2lzdGVuY3ksXG4gICAgICAgICAgICB0aW1lb3V0LFxuICAgICAgICAgICAgc2hhcmRfa2V5LFxuICAgICAgICAgICAgZmlsdGVyLFxuICAgICAgICAgICAgc2FtcGxlLFxuICAgICAgICAgICAgbGltaXQsXG4gICAgICAgICAgICB1c2luZyxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtYXliZShyZXNwb25zZS5kYXRhLnJlc3VsdCkub3JUaHJvdygnU2VhcmNoIHBvaW50cyBtYXRyaXggb2Zmc2V0cyByZXR1cm5lZCBlbXB0eScpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@qdrant/js-client-rest/dist/esm/qdrant-client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@qdrant/openapi-typescript-fetch/dist/esm/fetcher.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@qdrant/openapi-typescript-fetch/dist/esm/fetcher.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Fetcher: () => (/* binding */ Fetcher)\n/* harmony export */ });\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types.js */ \"(rsc)/./node_modules/@qdrant/openapi-typescript-fetch/dist/esm/types.js\");\n\nlet bigintReviver;\nlet bigintReplacer;\nif ('rawJSON' in JSON) {\n    bigintReviver = function (_key, val, context) {\n        if (Number.isInteger(val) && !Number.isSafeInteger(val)) {\n            try {\n                return BigInt(context.source);\n            }\n            catch {\n                return val;\n            }\n        }\n        return val;\n    };\n    bigintReplacer = function (_key, val) {\n        if (typeof val === 'bigint') {\n            return JSON.rawJSON(String(val));\n        }\n        return val;\n    };\n}\nconst sendBody = (method) => method === 'post' ||\n    method === 'put' ||\n    method === 'patch' ||\n    method === 'delete';\nfunction queryString(params) {\n    const qs = [];\n    const encode = (key, value) => `${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`;\n    Object.keys(params).forEach((key) => {\n        const value = params[key];\n        if (value != null) {\n            if (Array.isArray(value)) {\n                value.forEach((value) => qs.push(encode(key, value)));\n            }\n            else {\n                qs.push(encode(key, value));\n            }\n        }\n    });\n    if (qs.length > 0) {\n        return `?${qs.join('&')}`;\n    }\n    return '';\n}\nfunction getPath(path, payload) {\n    return path.replace(/\\{([^}]+)\\}/g, (_, key) => {\n        const value = encodeURIComponent(payload[key]);\n        delete payload[key];\n        return value;\n    });\n}\nfunction getQuery(method, payload, query) {\n    let queryObj = {};\n    if (sendBody(method)) {\n        query.forEach((key) => {\n            queryObj[key] = payload[key];\n            delete payload[key];\n        });\n    }\n    else {\n        queryObj = { ...payload };\n    }\n    return queryString(queryObj);\n}\nfunction getHeaders(body, init) {\n    const headers = new Headers(init);\n    if (body !== undefined &&\n        !(body instanceof FormData) &&\n        !headers.has('Content-Type')) {\n        headers.append('Content-Type', 'application/json');\n    }\n    if (!headers.has('Accept')) {\n        headers.append('Accept', 'application/json');\n    }\n    return headers;\n}\nfunction getBody(method, payload) {\n    if (!sendBody(method)) {\n        return;\n    }\n    const body = payload instanceof FormData\n        ? payload\n        : JSON.stringify(payload, bigintReplacer);\n    return method === 'delete' && body === '{}' ? undefined : body;\n}\nfunction mergeRequestInit(first, second) {\n    const headers = new Headers(first?.headers);\n    const other = new Headers(second?.headers);\n    for (const key of other.keys()) {\n        const value = other.get(key);\n        if (value != null) {\n            headers.set(key, value);\n        }\n    }\n    return { ...first, ...second, headers };\n}\nfunction getFetchParams(request) {\n    const payload = Object.assign(Array.isArray(request.payload) ? [] : {}, request.payload);\n    const path = getPath(request.path, payload);\n    const query = getQuery(request.method, payload, request.queryParams);\n    const body = getBody(request.method, payload);\n    const headers = sendBody(request.method)\n        ? getHeaders(body, request.init?.headers)\n        : new Headers(request.init?.headers);\n    const url = request.baseUrl + path + query;\n    const init = {\n        ...request.init,\n        method: request.method.toUpperCase(),\n        headers,\n        body,\n    };\n    return { url, init };\n}\nasync function getResponseData(response) {\n    if (response.status === 204) {\n        return;\n    }\n    const contentType = response.headers.get('content-type');\n    const responseText = await response.text();\n    if (contentType && contentType.includes('application/json')) {\n        return JSON.parse(responseText, bigintReviver);\n    }\n    try {\n        return JSON.parse(responseText, bigintReviver);\n    }\n    catch (e) {\n        return responseText;\n    }\n}\nasync function fetchJson(url, init) {\n    const response = await fetch(url, init);\n    const data = await getResponseData(response);\n    const result = {\n        headers: response.headers,\n        url: response.url,\n        ok: response.ok,\n        status: response.status,\n        statusText: response.statusText,\n        data,\n    };\n    if (result.ok) {\n        return result;\n    }\n    throw new _types_js__WEBPACK_IMPORTED_MODULE_0__.ApiError(result);\n}\nfunction wrapMiddlewares(middlewares, fetch) {\n    const handler = async (index, url, init) => {\n        if (middlewares == null || index === middlewares.length) {\n            return fetch(url, init);\n        }\n        const current = middlewares[index];\n        return await current(url, init, (nextUrl, nextInit) => handler(index + 1, nextUrl, nextInit));\n    };\n    return (url, init) => handler(0, url, init);\n}\nasync function fetchUrl(request) {\n    const { url, init } = getFetchParams(request);\n    const response = await request.fetch(url, init);\n    return response;\n}\nfunction createFetch(fetch) {\n    const fun = async (payload, init) => {\n        try {\n            return await fetch(payload, init);\n        }\n        catch (err) {\n            if (err instanceof _types_js__WEBPACK_IMPORTED_MODULE_0__.ApiError) {\n                throw new fun.Error(err);\n            }\n            throw err;\n        }\n    };\n    fun.Error = class extends _types_js__WEBPACK_IMPORTED_MODULE_0__.ApiError {\n        constructor(error) {\n            super(error);\n            Object.setPrototypeOf(this, new.target.prototype);\n        }\n        getActualType() {\n            return {\n                status: this.status,\n                data: this.data,\n            };\n        }\n    };\n    return fun;\n}\nfunction fetcher() {\n    let baseUrl = '';\n    let defaultInit = {};\n    const middlewares = [];\n    const fetch = wrapMiddlewares(middlewares, fetchJson);\n    return {\n        configure: (config) => {\n            baseUrl = config.baseUrl || '';\n            defaultInit = config.init || {};\n            middlewares.splice(0);\n            middlewares.push(...(config.use || []));\n        },\n        use: (mw) => middlewares.push(mw),\n        path: (path) => ({\n            method: (method) => ({\n                create: ((queryParams) => createFetch((payload, init) => fetchUrl({\n                    baseUrl: baseUrl || '',\n                    path: path,\n                    method: method,\n                    queryParams: Object.keys(queryParams || {}),\n                    payload,\n                    init: mergeRequestInit(defaultInit, init),\n                    fetch,\n                }))),\n            }),\n        }),\n    };\n}\nconst Fetcher = {\n    for: () => fetcher(),\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHFkcmFudC9vcGVuYXBpLXR5cGVzY3JpcHQtZmV0Y2gvZGlzdC9lc20vZmV0Y2hlci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msd0JBQXdCLEdBQUcsa0NBQWtDO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsbUJBQW1CLGFBQWE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsSUFBSSxLQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLCtDQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsK0NBQVE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwrQ0FBUTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXNhZ2UtYm90Ly4vbm9kZV9tb2R1bGVzL0BxZHJhbnQvb3BlbmFwaS10eXBlc2NyaXB0LWZldGNoL2Rpc3QvZXNtL2ZldGNoZXIuanM/MTViOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBcGlFcnJvciwgfSBmcm9tICcuL3R5cGVzLmpzJztcbmxldCBiaWdpbnRSZXZpdmVyO1xubGV0IGJpZ2ludFJlcGxhY2VyO1xuaWYgKCdyYXdKU09OJyBpbiBKU09OKSB7XG4gICAgYmlnaW50UmV2aXZlciA9IGZ1bmN0aW9uIChfa2V5LCB2YWwsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIodmFsKSAmJiAhTnVtYmVyLmlzU2FmZUludGVnZXIodmFsKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQmlnSW50KGNvbnRleHQuc291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfTtcbiAgICBiaWdpbnRSZXBsYWNlciA9IGZ1bmN0aW9uIChfa2V5LCB2YWwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5yYXdKU09OKFN0cmluZyh2YWwpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH07XG59XG5jb25zdCBzZW5kQm9keSA9IChtZXRob2QpID0+IG1ldGhvZCA9PT0gJ3Bvc3QnIHx8XG4gICAgbWV0aG9kID09PSAncHV0JyB8fFxuICAgIG1ldGhvZCA9PT0gJ3BhdGNoJyB8fFxuICAgIG1ldGhvZCA9PT0gJ2RlbGV0ZSc7XG5mdW5jdGlvbiBxdWVyeVN0cmluZyhwYXJhbXMpIHtcbiAgICBjb25zdCBxcyA9IFtdO1xuICAgIGNvbnN0IGVuY29kZSA9IChrZXksIHZhbHVlKSA9PiBgJHtlbmNvZGVVUklDb21wb25lbnQoa2V5KX09JHtlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHZhbHVlKSl9YDtcbiAgICBPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBhcmFtc1trZXldO1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUuZm9yRWFjaCgodmFsdWUpID0+IHFzLnB1c2goZW5jb2RlKGtleSwgdmFsdWUpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBxcy5wdXNoKGVuY29kZShrZXksIHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAocXMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gYD8ke3FzLmpvaW4oJyYnKX1gO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG59XG5mdW5jdGlvbiBnZXRQYXRoKHBhdGgsIHBheWxvYWQpIHtcbiAgICByZXR1cm4gcGF0aC5yZXBsYWNlKC9cXHsoW159XSspXFx9L2csIChfLCBrZXkpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBlbmNvZGVVUklDb21wb25lbnQocGF5bG9hZFtrZXldKTtcbiAgICAgICAgZGVsZXRlIHBheWxvYWRba2V5XTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0UXVlcnkobWV0aG9kLCBwYXlsb2FkLCBxdWVyeSkge1xuICAgIGxldCBxdWVyeU9iaiA9IHt9O1xuICAgIGlmIChzZW5kQm9keShtZXRob2QpKSB7XG4gICAgICAgIHF1ZXJ5LmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgcXVlcnlPYmpba2V5XSA9IHBheWxvYWRba2V5XTtcbiAgICAgICAgICAgIGRlbGV0ZSBwYXlsb2FkW2tleV07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcXVlcnlPYmogPSB7IC4uLnBheWxvYWQgfTtcbiAgICB9XG4gICAgcmV0dXJuIHF1ZXJ5U3RyaW5nKHF1ZXJ5T2JqKTtcbn1cbmZ1bmN0aW9uIGdldEhlYWRlcnMoYm9keSwgaW5pdCkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbml0KTtcbiAgICBpZiAoYm9keSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICEoYm9keSBpbnN0YW5jZW9mIEZvcm1EYXRhKSAmJlxuICAgICAgICAhaGVhZGVycy5oYXMoJ0NvbnRlbnQtVHlwZScpKSB7XG4gICAgICAgIGhlYWRlcnMuYXBwZW5kKCdDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgIH1cbiAgICBpZiAoIWhlYWRlcnMuaGFzKCdBY2NlcHQnKSkge1xuICAgICAgICBoZWFkZXJzLmFwcGVuZCgnQWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIGhlYWRlcnM7XG59XG5mdW5jdGlvbiBnZXRCb2R5KG1ldGhvZCwgcGF5bG9hZCkge1xuICAgIGlmICghc2VuZEJvZHkobWV0aG9kKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGJvZHkgPSBwYXlsb2FkIGluc3RhbmNlb2YgRm9ybURhdGFcbiAgICAgICAgPyBwYXlsb2FkXG4gICAgICAgIDogSlNPTi5zdHJpbmdpZnkocGF5bG9hZCwgYmlnaW50UmVwbGFjZXIpO1xuICAgIHJldHVybiBtZXRob2QgPT09ICdkZWxldGUnICYmIGJvZHkgPT09ICd7fScgPyB1bmRlZmluZWQgOiBib2R5O1xufVxuZnVuY3Rpb24gbWVyZ2VSZXF1ZXN0SW5pdChmaXJzdCwgc2Vjb25kKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKGZpcnN0Py5oZWFkZXJzKTtcbiAgICBjb25zdCBvdGhlciA9IG5ldyBIZWFkZXJzKHNlY29uZD8uaGVhZGVycyk7XG4gICAgZm9yIChjb25zdCBrZXkgb2Ygb3RoZXIua2V5cygpKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gb3RoZXIuZ2V0KGtleSk7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBoZWFkZXJzLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyAuLi5maXJzdCwgLi4uc2Vjb25kLCBoZWFkZXJzIH07XG59XG5mdW5jdGlvbiBnZXRGZXRjaFBhcmFtcyhyZXF1ZXN0KSB7XG4gICAgY29uc3QgcGF5bG9hZCA9IE9iamVjdC5hc3NpZ24oQXJyYXkuaXNBcnJheShyZXF1ZXN0LnBheWxvYWQpID8gW10gOiB7fSwgcmVxdWVzdC5wYXlsb2FkKTtcbiAgICBjb25zdCBwYXRoID0gZ2V0UGF0aChyZXF1ZXN0LnBhdGgsIHBheWxvYWQpO1xuICAgIGNvbnN0IHF1ZXJ5ID0gZ2V0UXVlcnkocmVxdWVzdC5tZXRob2QsIHBheWxvYWQsIHJlcXVlc3QucXVlcnlQYXJhbXMpO1xuICAgIGNvbnN0IGJvZHkgPSBnZXRCb2R5KHJlcXVlc3QubWV0aG9kLCBwYXlsb2FkKTtcbiAgICBjb25zdCBoZWFkZXJzID0gc2VuZEJvZHkocmVxdWVzdC5tZXRob2QpXG4gICAgICAgID8gZ2V0SGVhZGVycyhib2R5LCByZXF1ZXN0LmluaXQ/LmhlYWRlcnMpXG4gICAgICAgIDogbmV3IEhlYWRlcnMocmVxdWVzdC5pbml0Py5oZWFkZXJzKTtcbiAgICBjb25zdCB1cmwgPSByZXF1ZXN0LmJhc2VVcmwgKyBwYXRoICsgcXVlcnk7XG4gICAgY29uc3QgaW5pdCA9IHtcbiAgICAgICAgLi4ucmVxdWVzdC5pbml0LFxuICAgICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLnRvVXBwZXJDYXNlKCksXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIGJvZHksXG4gICAgfTtcbiAgICByZXR1cm4geyB1cmwsIGluaXQgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFJlc3BvbnNlRGF0YShyZXNwb25zZSkge1xuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwNCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpO1xuICAgIGNvbnN0IHJlc3BvbnNlVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICBpZiAoY29udGVudFR5cGUgJiYgY29udGVudFR5cGUuaW5jbHVkZXMoJ2FwcGxpY2F0aW9uL2pzb24nKSkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShyZXNwb25zZVRleHQsIGJpZ2ludFJldml2ZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShyZXNwb25zZVRleHQsIGJpZ2ludFJldml2ZXIpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2VUZXh0O1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGZldGNoSnNvbih1cmwsIGluaXQpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwgaW5pdCk7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IGdldFJlc3BvbnNlRGF0YShyZXNwb25zZSk7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICBoZWFkZXJzOiByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICB1cmw6IHJlc3BvbnNlLnVybCxcbiAgICAgICAgb2s6IHJlc3BvbnNlLm9rLFxuICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgZGF0YSxcbiAgICB9O1xuICAgIGlmIChyZXN1bHQub2spIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEFwaUVycm9yKHJlc3VsdCk7XG59XG5mdW5jdGlvbiB3cmFwTWlkZGxld2FyZXMobWlkZGxld2FyZXMsIGZldGNoKSB7XG4gICAgY29uc3QgaGFuZGxlciA9IGFzeW5jIChpbmRleCwgdXJsLCBpbml0KSA9PiB7XG4gICAgICAgIGlmIChtaWRkbGV3YXJlcyA9PSBudWxsIHx8IGluZGV4ID09PSBtaWRkbGV3YXJlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmZXRjaCh1cmwsIGluaXQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSBtaWRkbGV3YXJlc1tpbmRleF07XG4gICAgICAgIHJldHVybiBhd2FpdCBjdXJyZW50KHVybCwgaW5pdCwgKG5leHRVcmwsIG5leHRJbml0KSA9PiBoYW5kbGVyKGluZGV4ICsgMSwgbmV4dFVybCwgbmV4dEluaXQpKTtcbiAgICB9O1xuICAgIHJldHVybiAodXJsLCBpbml0KSA9PiBoYW5kbGVyKDAsIHVybCwgaW5pdCk7XG59XG5hc3luYyBmdW5jdGlvbiBmZXRjaFVybChyZXF1ZXN0KSB7XG4gICAgY29uc3QgeyB1cmwsIGluaXQgfSA9IGdldEZldGNoUGFyYW1zKHJlcXVlc3QpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdC5mZXRjaCh1cmwsIGluaXQpO1xuICAgIHJldHVybiByZXNwb25zZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZldGNoKGZldGNoKSB7XG4gICAgY29uc3QgZnVuID0gYXN5bmMgKHBheWxvYWQsIGluaXQpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBmZXRjaChwYXlsb2FkLCBpbml0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgQXBpRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZnVuLkVycm9yKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZ1bi5FcnJvciA9IGNsYXNzIGV4dGVuZHMgQXBpRXJyb3Ige1xuICAgICAgICBjb25zdHJ1Y3RvcihlcnJvcikge1xuICAgICAgICAgICAgc3VwZXIoZXJyb3IpO1xuICAgICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIG5ldy50YXJnZXQucHJvdG90eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBnZXRBY3R1YWxUeXBlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgICAgICAgICAgIGRhdGE6IHRoaXMuZGF0YSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBmdW47XG59XG5mdW5jdGlvbiBmZXRjaGVyKCkge1xuICAgIGxldCBiYXNlVXJsID0gJyc7XG4gICAgbGV0IGRlZmF1bHRJbml0ID0ge307XG4gICAgY29uc3QgbWlkZGxld2FyZXMgPSBbXTtcbiAgICBjb25zdCBmZXRjaCA9IHdyYXBNaWRkbGV3YXJlcyhtaWRkbGV3YXJlcywgZmV0Y2hKc29uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb25maWd1cmU6IChjb25maWcpID0+IHtcbiAgICAgICAgICAgIGJhc2VVcmwgPSBjb25maWcuYmFzZVVybCB8fCAnJztcbiAgICAgICAgICAgIGRlZmF1bHRJbml0ID0gY29uZmlnLmluaXQgfHwge307XG4gICAgICAgICAgICBtaWRkbGV3YXJlcy5zcGxpY2UoMCk7XG4gICAgICAgICAgICBtaWRkbGV3YXJlcy5wdXNoKC4uLihjb25maWcudXNlIHx8IFtdKSk7XG4gICAgICAgIH0sXG4gICAgICAgIHVzZTogKG13KSA9PiBtaWRkbGV3YXJlcy5wdXNoKG13KSxcbiAgICAgICAgcGF0aDogKHBhdGgpID0+ICh7XG4gICAgICAgICAgICBtZXRob2Q6IChtZXRob2QpID0+ICh7XG4gICAgICAgICAgICAgICAgY3JlYXRlOiAoKHF1ZXJ5UGFyYW1zKSA9PiBjcmVhdGVGZXRjaCgocGF5bG9hZCwgaW5pdCkgPT4gZmV0Y2hVcmwoe1xuICAgICAgICAgICAgICAgICAgICBiYXNlVXJsOiBiYXNlVXJsIHx8ICcnLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IE9iamVjdC5rZXlzKHF1ZXJ5UGFyYW1zIHx8IHt9KSxcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgICAgICAgICAgICAgaW5pdDogbWVyZ2VSZXF1ZXN0SW5pdChkZWZhdWx0SW5pdCwgaW5pdCksXG4gICAgICAgICAgICAgICAgICAgIGZldGNoLFxuICAgICAgICAgICAgICAgIH0pKSksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfSksXG4gICAgfTtcbn1cbmV4cG9ydCBjb25zdCBGZXRjaGVyID0ge1xuICAgIGZvcjogKCkgPT4gZmV0Y2hlcigpLFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@qdrant/openapi-typescript-fetch/dist/esm/fetcher.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@qdrant/openapi-typescript-fetch/dist/esm/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@qdrant/openapi-typescript-fetch/dist/esm/index.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ApiError: () => (/* reexport safe */ _types_js__WEBPACK_IMPORTED_MODULE_2__.ApiError),\n/* harmony export */   Fetcher: () => (/* reexport safe */ _fetcher_js__WEBPACK_IMPORTED_MODULE_0__.Fetcher),\n/* harmony export */   arrayRequestBody: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_1__.arrayRequestBody)\n/* harmony export */ });\n/* harmony import */ var _fetcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fetcher.js */ \"(rsc)/./node_modules/@qdrant/openapi-typescript-fetch/dist/esm/fetcher.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/@qdrant/openapi-typescript-fetch/dist/esm/utils.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types.js */ \"(rsc)/./node_modules/@qdrant/openapi-typescript-fetch/dist/esm/types.js\");\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHFkcmFudC9vcGVuYXBpLXR5cGVzY3JpcHQtZmV0Y2gvZGlzdC9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQXVDO0FBQ087QUFDUjtBQUNTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtc2FnZS1ib3QvLi9ub2RlX21vZHVsZXMvQHFkcmFudC9vcGVuYXBpLXR5cGVzY3JpcHQtZmV0Y2gvZGlzdC9lc20vaW5kZXguanM/ODE2MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBGZXRjaGVyIH0gZnJvbSAnLi9mZXRjaGVyLmpzJztcbmltcG9ydCB7IGFycmF5UmVxdWVzdEJvZHkgfSBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7IEFwaUVycm9yIH0gZnJvbSAnLi90eXBlcy5qcyc7XG5leHBvcnQgeyBGZXRjaGVyLCBBcGlFcnJvciwgYXJyYXlSZXF1ZXN0Qm9keSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@qdrant/openapi-typescript-fetch/dist/esm/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@qdrant/openapi-typescript-fetch/dist/esm/types.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@qdrant/openapi-typescript-fetch/dist/esm/types.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ApiError: () => (/* binding */ ApiError)\n/* harmony export */ });\nconst never = Symbol();\nclass ApiError extends Error {\n    constructor(response) {\n        super(response.statusText);\n        Object.setPrototypeOf(this, new.target.prototype);\n        this.headers = response.headers;\n        this.url = response.url;\n        this.status = response.status;\n        this.statusText = response.statusText;\n        this.data = response.data;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHFkcmFudC9vcGVuYXBpLXR5cGVzY3JpcHQtZmV0Y2gvZGlzdC9lc20vdHlwZXMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXNhZ2UtYm90Ly4vbm9kZV9tb2R1bGVzL0BxZHJhbnQvb3BlbmFwaS10eXBlc2NyaXB0LWZldGNoL2Rpc3QvZXNtL3R5cGVzLmpzPzMzYTYiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgbmV2ZXIgPSBTeW1ib2woKTtcbmV4cG9ydCBjbGFzcyBBcGlFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihyZXNwb25zZSkge1xuICAgICAgICBzdXBlcihyZXNwb25zZS5zdGF0dXNUZXh0KTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIG5ldy50YXJnZXQucHJvdG90eXBlKTtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gcmVzcG9uc2UuaGVhZGVycztcbiAgICAgICAgdGhpcy51cmwgPSByZXNwb25zZS51cmw7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzO1xuICAgICAgICB0aGlzLnN0YXR1c1RleHQgPSByZXNwb25zZS5zdGF0dXNUZXh0O1xuICAgICAgICB0aGlzLmRhdGEgPSByZXNwb25zZS5kYXRhO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@qdrant/openapi-typescript-fetch/dist/esm/types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@qdrant/openapi-typescript-fetch/dist/esm/utils.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@qdrant/openapi-typescript-fetch/dist/esm/utils.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrayRequestBody: () => (/* binding */ arrayRequestBody)\n/* harmony export */ });\nfunction arrayRequestBody(array, params) {\n    return Object.assign([...array], params);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHFkcmFudC9vcGVuYXBpLXR5cGVzY3JpcHQtZmV0Y2gvZGlzdC9lc20vdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXNhZ2UtYm90Ly4vbm9kZV9tb2R1bGVzL0BxZHJhbnQvb3BlbmFwaS10eXBlc2NyaXB0LWZldGNoL2Rpc3QvZXNtL3V0aWxzLmpzP2NjZDQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGFycmF5UmVxdWVzdEJvZHkoYXJyYXksIHBhcmFtcykge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKFsuLi5hcnJheV0sIHBhcmFtcyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@qdrant/openapi-typescript-fetch/dist/esm/utils.js\n");

/***/ })

};
;